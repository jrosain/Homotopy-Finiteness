#+TITLE: Homotopy Finiteness
#+NAME: Homotopy Finiteness
#+AUTHOR: Johann Rosain

* Homotopy Finiteness

  #+begin_src ctt
  module HomotopyFiniteness where
  #+end_src

This file is a formalization of the proof presented by Rijke in his [[https://www.cirm-math.fr/RepOrga/2689/Slides/s_rijke_3.pdf][CIRM talk]] about the finiteness of structures up to isomorphism.

** Packages imports

The imported packages can be accessed via the following links:
   - [[file:Lib/IsFinite.org][Lib/IsFinite]]
   - [[file:Lib/SetTrunc.org][Lib/SetTrunc]]
   #+begin_src ctt
  import Lib.IsFinite
  import Lib.SetTrunc
   #+end_src

** Homotopy finite
A type =A= is said n^th-/homotopy finite/ if it has finitely many connected components and all its homotopy groups \pi_i(A, x) are finite, for every i \le n and /x : A/.
#+begin_src ctt
  is-htpy-finite : Nat -> U -> U = split
    zero -> \ A. is-finite (Set-trunc A)
    suc k -> \ A. is-finite (Set-trunc A) *
                ( (x y : A) -> is-htpy-finite k (Path A x y))
#+end_src

** =is-htpy-finite= is a proposition
As propositions are closed under products, we can show by induction that =is-htpy-finite n= is a proposition.
#+begin_src ctt
  is-htpy-finite/is-prop : (k : Nat) -> (A : U) -> is-prop (is-htpy-finite k A) = split
    zero -> \ A. is-finite/is-prop (Set-trunc A)
    suc k -> \ A.
      is-prop/prod
        ( is-finite (Set-trunc A))
        ( (x y : A) -> is-htpy-finite k (Path A x y))
        ( is-finite/is-prop (Set-trunc A))
        ( is-prop/pi-2 A
          ( \ _. A)
          ( \ x y. is-htpy-finite k (Path A x y))
          ( \ x y. is-htpy-finite/is-prop k (Path A x y)))

  is-htpy-finite/Prop (k : Nat) (A : U) : UU-Prop =
    ( is-htpy-finite k A,
      is-htpy-finite/is-prop k A)
#+end_src

** Empty is \pi_n finite
The empty type is \pi_n finite.
#+begin_src ctt
  Empty/is-htpy-finite : (n : Nat) -> is-htpy-finite n Empty = split
    zero ->
      is-finite/closed-Equiv' Empty
        ( Set-trunc Empty)
        ( Set/Equiv-Set-trunc
          ( Prop/Set (Empty/Prop)))
        ( Empty/is-finite)
    suc n ->
      ( Empty/is-htpy-finite zero,
        \ x y. ex-falso (is-htpy-finite n (Path Empty x y)) x)
#+end_src

** Any contractible type is \pi_n finite (in particular, Unit is \pi_n finite)
#+begin_src ctt
  is-contr/is-htpy-finite : (n : Nat) -> (X : U) -> is-contr X -> is-htpy-finite n X = split
    zero -> \ X H.
      is-contr/is-finite
        ( Set-trunc X)
        ( Set-trunc/closed-contr X H)
    suc n -> \ X H.
      ( is-contr/is-htpy-finite zero X H,
        \ x y. is-contr/is-htpy-finite n
              ( Path X x y)
              ( is-contr/closed-upwards X H x y))

  Unit/is-htpy-finite (n : Nat) : is-htpy-finite n Unit =
    is-contr/is-htpy-finite n Unit
      ( Unit/is-contr)
#+end_src

** Homotopy finiteness is closed downwards
If a type A is \pi_n-finite, then its set truncation is finite.
#+begin_src ctt
  is-htpy-finite/is-finite-Set-trunc (A : U) : (n : Nat) -> is-htpy-finite n A -> is-finite (Set-trunc A) = split
    zero -> id (is-finite (Set-trunc A))
    suc n -> \ H. H.1
#+end_src

If is-\pi_{n+1}-finite A, then is-\pi_n-finite A.
#+begin_src ctt
  is-htpy-finite/pred : (n : Nat) -> (A : U) -> is-htpy-finite (suc n) A -> is-htpy-finite n A = split
    zero -> \ A H. H.1
    suc n -> \ A H.
        ( H.1,
          \ x y.
            is-htpy-finite/pred n
              ( Path A x y) (H.2 x y))
#+end_src
If a type A is \pi_{n+1} finite, then it is \pi_1 finite.
   #+begin_src ctt
  is-htpy-finite/is-htpy-one-finite (A : U) : (n : Nat) -> is-htpy-finite (suc n) A -> is-htpy-finite one-Nat A = split
    zero -> id (is-htpy-finite one-Nat A)
    suc n -> \ HA.
      is-htpy-finite/is-htpy-one-finite A n
        ( is-htpy-finite/pred (suc n) A HA)
   #+end_src

** Closure under equivalence
If =A= and =B= are equivalent, then whenever one of them is \pi_n finite, the other one is also \pi_n finite.
#+begin_src ctt
  is-htpy-finite/closed-Equiv/aux : (n : Nat) -> (A B : U) -> Equiv A B -> is-htpy-finite n B -> is-htpy-finite n A = split
    zero -> \ A B e.
      is-finite/closed-Equiv
        ( Set-trunc A)
        ( Set-trunc B)
        ( Set-trunc/Equiv A B e)
    suc n -> \ A B e is-htpy-finite-B.
      ( is-finite/closed-Equiv
          ( Set-trunc A)
          ( Set-trunc B)
          ( Set-trunc/Equiv A B e)
          ( is-htpy-finite-B.1),
        \ x y.
          is-htpy-finite/closed-Equiv/aux n
          ( Path A x y)
          ( Path B (Equiv/map A B e x) (Equiv/map A B e y))
          ( Equiv/Equiv-id A B e x y)
          ( is-htpy-finite-B.2
            ( Equiv/map A B e x)
            ( Equiv/map A B e y)))

  is-htpy-finite/closed-Equiv (A B : U) (e : Equiv A B) (n : Nat) (is-htpy-finite-B : is-htpy-finite n B) : is-htpy-finite n A =
    is-htpy-finite/closed-Equiv/aux n A B e is-htpy-finite-B

  is-htpy-finite/closed-Equiv' (A B : U) (e : Equiv A B) (n : Nat) (is-htpy-finite-A : is-htpy-finite n A) : is-htpy-finite n B =
    is-htpy-finite/closed-Equiv B A (Equiv/sym A B e) n is-htpy-finite-A
#+end_src
** Closure under coproduct
If A and B are both \pi_n finite, then the coproduct A + B is also \pi_n finite.
#+begin_src ctt
  is-htpy-finite/closed-Coprod/inl (A B : U) (n : Nat) (is-htpy-finite-A : is-htpy-finite (suc n) A)
                                   (is-htpy-finite-B : is-htpy-finite (suc n) B) (x : A)
                                       :  (v : Coprod A B)
                                         -> is-htpy-finite n (Path (Coprod A B) (inl x) v) = split
    inl a ->
      is-htpy-finite/closed-Equiv
        ( Path (Coprod A B) (inl x) (inl a))
        ( Path A x a)
        ( Coprod/Eq/Equiv A B (inl x) (inl a)) n
        ( is-htpy-finite-A.2 x a)
    inr y ->
      is-htpy-finite/closed-Equiv
        ( Path (Coprod A B) (inl x) (inr y))
        ( Empty)
        ( Coprod/Eq/Equiv A B (inl x) (inr y)) n
        ( Empty/is-htpy-finite n)

  is-htpy-finite/closed-Coprod/inr (A B : U) (n : Nat) (is-htpy-finite-A : is-htpy-finite (suc n) A)
                                   (is-htpy-finite-B : is-htpy-finite (suc n) B) (y : B)
                                       :  (v : Coprod A B)
                                         -> is-htpy-finite n (Path (Coprod A B) (inr y) v) = split
    inl a ->
      is-htpy-finite/closed-Equiv
        ( Path (Coprod A B) (inr y) (inl a))
        ( Empty)
        ( Coprod/Eq/Equiv A B (inr y) (inl a)) n
        ( Empty/is-htpy-finite n)
    inr b ->
      is-htpy-finite/closed-Equiv
        ( Path (Coprod A B) (inr y) (inr b))
        ( Path B y b)
        ( Coprod/Eq/Equiv A B (inr y) (inr b)) n
        ( is-htpy-finite-B.2 y b)

  is-htpy-finite/closed-Coprod' (A B : U) (n : Nat) (is-htpy-finite-A : is-htpy-finite (suc n) A)
                                (is-htpy-finite-B : is-htpy-finite (suc n) B)
                                    : (u : Coprod A B) (v : Coprod A B)
                                     -> is-htpy-finite n (Path (Coprod A B) u v) = split
    inl x -> is-htpy-finite/closed-Coprod/inl A B n is-htpy-finite-A is-htpy-finite-B x
    inr y -> is-htpy-finite/closed-Coprod/inr A B n is-htpy-finite-A is-htpy-finite-B y

  is-htpy-finite/closed-Coprod : (n : Nat) -> (A B : U) (is-htpy-finite-A : is-htpy-finite n A)
                                 (is-htpy-finite-B : is-htpy-finite n B) -> is-htpy-finite n (Coprod A B) = split
    zero -> \ A B HA HB.
      is-finite/closed-Equiv
        ( Set-trunc (Coprod A B))
        ( Coprod (Set-trunc A) (Set-trunc B))
        ( Set-trunc/closed-Coprod' A B)
        ( is-finite/closed-Coprod
          ( Set-trunc A)
          ( Set-trunc B)
          ( HA)
          ( HB))
    suc n -> \ A B HA HB.
      ( is-htpy-finite/closed-Coprod zero A B
          ( is-htpy-finite/is-finite-Set-trunc A (suc n) HA)
          ( is-htpy-finite/is-finite-Set-trunc B (suc n) HB),
        is-htpy-finite/closed-Coprod' A B n HA HB)
#+end_src
On the other hand, if A + B is \pi_n finite, then A and B are also \pi_n finite.
#+begin_src ctt
  is-htpy-finite/Coprod/left (A B : U) : (n : Nat) (is-htpy-finite-copr : is-htpy-finite n (Coprod A B))
                                        -> is-htpy-finite n A = split
    zero -> \ H.
      is-finite/closed-Coprod-left
        ( Set-trunc A)
        ( Set-trunc B)
        ( is-finite/closed-Equiv
          ( Coprod (Set-trunc A) (Set-trunc B))
          ( Set-trunc (Coprod A B))
          ( Set-trunc/closed-Coprod A B)
          ( H))
    suc n -> \ H.
      ( is-htpy-finite/Coprod/left A B zero
        ( is-htpy-finite/is-finite-Set-trunc
          ( Coprod A B)
          ( suc n) H),
        \ x y.
          is-htpy-finite/closed-Equiv
            ( Path A x y)
            ( Path (Coprod A B) (inl x) (inl y))
            ( Coprod/Eq/Equiv' A B (inl x) (inl y)) n
            ( H.2 (inl x) (inl y)))

  is-htpy-finite/Coprod/right (A B : U) : (n : Nat) (is-htpy-finite-copr : is-htpy-finite n (Coprod A B))
                                         -> is-htpy-finite n B = split
    zero -> \ H.
      is-finite/closed-Coprod-right
        ( Set-trunc A)
        ( Set-trunc B)
        ( is-finite/closed-Equiv
          ( Coprod (Set-trunc A) (Set-trunc B))
          ( Set-trunc (Coprod A B))
          ( Set-trunc/closed-Coprod A B)
          ( H))
    suc n -> \ H.
      ( is-htpy-finite/Coprod/right A B zero
        ( is-htpy-finite/is-finite-Set-trunc
          ( Coprod A B)
          ( suc n) H),
        \ x y.
          is-htpy-finite/closed-Equiv
            ( Path B x y)
            ( Path (Coprod A B) (inr x) (inr y))
            ( Coprod/Eq/Equiv' A B (inr x) (inr y)) n
            ( H.2 (inr x) (inr y)))
#+end_src

** Finite type is \pi_n finite
First, we show that =Fin k= is \pi_n finite for all k, n.
#+begin_src ctt
  Fin/is-htpy-finite (n : Nat) : (k : Nat) -> is-htpy-finite n (Fin k) = split
    zero -> Empty/is-htpy-finite n
    suc k ->
      is-htpy-finite/closed-Coprod n
        ( Fin k) Unit
        ( Fin/is-htpy-finite n k)
        ( Unit/is-htpy-finite n)
#+end_src
That is, everything that has a count is \pi_n finite for all n.
#+begin_src ctt
  count/is-htpy-finite (X : U) (H : count X) (n : Nat) : is-htpy-finite n X =
    let k : Nat = number-of-elements X H
        e : Equiv (Fin k) X = count/Equiv X H in
    is-htpy-finite/closed-Equiv'
      ( Fin k) X e n
      ( Fin/is-htpy-finite n k)
#+end_src
As being \pi_n finite is a proposition, it generalizes if X is finite.
#+begin_src ctt
  is-finite/is-htpy-finite (X : U) (H : is-finite X) (n : Nat) : is-htpy-finite n X =
    rec-Prop-trunc
      ( count X)
      ( is-htpy-finite/Prop n X)
      ( \ c. count/is-htpy-finite X c n) H
#+end_src

** Equivalence of set-truncated function type
We show that if =A= is finite, then there is an equivalence between \Pi_{x: A}||B x||_0 and ||\Pi_{x: A} B x||_0. First, we show this result for =A = Fin k= by induction on /k/.
   * if /k = 0/, then both types are contractible. By the 3-for-2 property of contractibility, they are equivalent.
   * if /k > 0/, there is the following chain of equivalences:
     \Pi_{x: Fin (k + 1)}||B x||_0 \simeq \Pi_{x: Fin k}||B (inl x)||_0 \times ||B (inr star)||_0
                        \simeq ||\Pi_{x: Fin k} B (inl x)||_0 \times ||B (inr star)||_0
                        \simeq ||\Pi_{x: Fin (k + 1)}B x||_0
#+begin_src ctt
  Fin/Equiv-Pi-Set-trunc : (k : Nat) -> (B : Fin k -> U) -> Equiv ((x : Fin k) -> Set-trunc (B x)) (Set-trunc ((x : Fin k) -> B x)) = split
    zero -> \ B.
      is-contr/Equiv
        ( (x : Fin zero) -> Set-trunc (B x))
        ( Set-trunc ((x : Fin zero) -> B x))
        ( Empty/universal-dependent-property
          ( Fin zero)
          ( \ x. Set-trunc (B x))
          ( Equiv/refl (Fin zero)))
        ( Set-trunc/closed-contr
          ( (x : Fin zero) -> B x)
          ( Empty/universal-dependent-property
            ( Fin zero) B
            ( Equiv/refl (Fin zero))))
    suc k -> \ B.
      Equiv/comp five-Nat
        ( (x : Fin (suc k)) -> Set-trunc (B x))
        ( ((x : Fin k) -> Set-trunc (B (inl x))) * ((x : Unit) -> Set-trunc (B (inr x))))
        ( Coprod/dependent-universal-property
          ( Fin k) Unit (\ x. Set-trunc (B x)))
        ( ((x : Fin k) -> Set-trunc (B (inl x))) * (Set-trunc (B (inr star))))
        ( Equiv/prod'
          ( (x : Fin k) -> Set-trunc (B (inl x)))
          ( (x : Unit) -> Set-trunc (B (inr x)))
          ( Set-trunc (B (inr star)))
          ( Equiv/pi-Unit
            ( \ x. Set-trunc (B (inr x)))))
        ( (Set-trunc ((x : Fin k) -> B (inl x))) * (Set-trunc (B (inr star))))
        ( Equiv/prod
          ( (x : Fin k) -> Set-trunc (B (inl x)))
          ( Set-trunc ((x : Fin k) -> B (inl x)))
          ( Set-trunc (B (inr star)))
          ( Fin/Equiv-Pi-Set-trunc k
            ( \ x. B (inl x))))
        ( Set-trunc (((x : Fin k) -> B (inl x)) * (B (inr star))))
        ( Set-trunc/closed-Prod
          ( (x : Fin k) -> B (inl x))
          ( B (inr star)))
        ( Set-trunc (((x : Fin k) -> B (inl x)) * ((x : Unit) -> B (inr x))))
        ( Set-trunc/Equiv
          ( ((x : Fin k) -> B (inl x)) * (B (inr star)))
          ( ((x : Fin k) -> B (inl x)) * ((x : Unit) -> B (inr x)))
          ( Equiv/prod'
            ( (x : Fin k) -> B (inl x))
            ( B (inr star))
            ( (x : Unit) -> B (inr x))
            ( Equiv/sym
              ( (x : Unit) -> B (inr x))
              ( B (inr star))
              ( Equiv/pi-Unit (\ x. B (inr x))))))
        ( Set-trunc ((x : Fin (suc k)) -> B x))
        ( Set-trunc/Equiv
          ( ((x : Fin k) -> B (inl x)) * ((x : Unit) -> B (inr x)))
          ( (x : Fin (suc k)) -> B x)
          ( Equiv/sym
            ( (x : Fin (suc k)) -> B x)
            ( ((x : Fin k) -> B (inl x)) * ((x : Unit) -> B (inr x)))
            ( Coprod/dependent-universal-property
              ( Fin k) Unit B)))
#+end_src
This result cannot be directly generalized for a finite type (as =Equiv= is not a proposition). It can be, however, generalized for any type that has a counting.
#+begin_src ctt
  Path/Pi (A : U) (B : A -> U) (f : A -> A) (H : (x : A) -> Path A (f x) x) : Path U ((x : A) -> B (f x)) ((x : A) -> B x) =
    \ i. (x : A) -> B (H x i)

  count/Equiv-Pi-Set-trunc (A : U) (B : A -> U) (c : count A) : Equiv ((x : A) -> Set-trunc (B x)) (Set-trunc ((x : A) -> B x)) =
    let k : Nat = number-of-elements A c
        e : Equiv (Fin k) A = count/Equiv A c
        f : (Fin k) -> A = Equiv/map (Fin k) A e
        g : A -> (Fin k) = Equiv/inv-map (Fin k) A e
    in
    Equiv/comp three-Nat
      ( (x : A) -> Set-trunc (B x))
      ( (x : Fin k) -> Set-trunc (B (f x)))
      ( Equiv/dependent
        ( Fin k) A
        ( \ x. Set-trunc (B x)) e)
      ( Set-trunc ((x : Fin k) -> B (f x)))
      ( Fin/Equiv-Pi-Set-trunc k
        ( \ x. B (f x)))
      ( Set-trunc ((x : A) -> B (f (g x))))
      ( Set-trunc/Equiv
        ( (x : Fin k) -> B (f x))
        ( (x : A) -> B (f (g x)))
        ( Equiv/dependent A
          ( Fin k)
          ( \ x. B (f x))
          ( Equiv/sym
            ( Fin k) A e)))
      ( Set-trunc ((x : A) -> B x))
      ( Set-trunc/Equiv
        ( (x : A) -> B (f (g x)))
        ( (x : A) -> B x)
        ( path-to-equiv
          ( (x : A) -> B (f (g x)))
          ( (x : A) -> B x)
          ( Path/Pi A B (\ x. f (g x)) (Equiv/inv-right-htpy (Fin k) A e))))
#+end_src

** Closure under \Pi-types
In this section, we show that if =B= is a family of \pi_n finite types over a finite type =A=, then the product \Pi_{x: A}B(x) is also \pi_{n}-finite.
We proceed by induction over =n=. 
   * If =n= is zero, then by is-finite/\Pi, is-finite (\Pi_{x: A}||B x||_0). Moreover, \Pi_{x: A}||B x||_0 is equivalent to ||\Pi_{x: A}B(x)||_0 and as is-finite is closed by equivalences, the result follows.
   * If =n > 0=, then it suffices to show that f \sim g is \pi_n finite by function extensionality and \pi_n-finiteness closure under equivalence. It then suffices to use the induction hypothesis.
#+begin_src ctt
  is-htpy-finite/closed-Pi : (n : Nat) -> (A : U) -> (B : A -> U) -> is-finite A -> ((x : A) -> is-htpy-finite n (B x)) -> is-htpy-finite n ((x : A) -> B x) = split
   zero -> \ A B HA HB.
      (rec-Prop-trunc
        ( count A)
        ( is-finite/Prop (Set-trunc ((x : A) -> B x)))
        ( \ c.
            is-finite/closed-Equiv'
              ( (x : A) -> Set-trunc (B x))
              ( Set-trunc ((x : A) -> B x))
              ( count/Equiv-Pi-Set-trunc A B c)
              ( is-finite/Pi A
                ( \ x. Set-trunc (B x)) HA HB)) HA)

   suc n -> \ A B HA HB.
        let IH : is-htpy-finite n ((x : A) -> B x) = is-htpy-finite/closed-Pi n A B HA (\ x. is-htpy-finite/pred n (B x) (HB x)) in
        ( is-htpy-finite/is-finite-Set-trunc ((x : A) -> B x) n IH,
          \ f g.
            is-htpy-finite/closed-Equiv
              ( Path ((x : A) -> B x) f g)
              ( Htpy A B f g)
              ( htpy-eq/Equiv A B f g) n
              ( is-htpy-finite/closed-Pi n A
                ( \ x. Path (B x) (f x) (g x)) HA
                ( \ x. (HB x).2 (f x) (g x))))
#+end_src

** Closure under \Sigma-types, base case
In this section, we show that if =B= is a family of \pi_0-finite types over a connected, \pi_1-finite type A, then \Sigma_{x: A}B(x) is also \pi_0-finite, i.e., that || \Sigma_{x: A}B(x) ||_0 is finite. 

*** Preliminaries
As A is connected, and we show a property, we assume that a : A. Then, the fiber inclusion function (recall that it is defined as \ b. (a, b) for b : B(a)) is surjective. As set truncation preserves surjectivity, || \Sigma_{x: A} B(x) ||_0 is finite whenever it has decidable equality.
#+begin_src ctt
  is-htpy-finite/closed-Sg/base' (A : U) (B : A -> U) (H : is-conn A) (is-htpy-finite-A : is-htpy-finite one-Nat A)
                                 (is-htpy-finite-B : (x : A) -> is-htpy-finite zero (B x))
                                 (has-dec-eq-Sg : has-decidable-equality (Set-trunc (Sg A B))) : is-htpy-finite zero (Sg A B) =
    rec-Prop-trunc A
      ( is-htpy-finite/Prop zero (Sg A B))
      ( \ a. has-decidable-equality/is-finite
              ( Set-trunc (B a))
              ( Set-trunc (Sg A B))
              ( is-htpy-finite-B a)
              ( has-dec-eq-Sg)
              ( Set-trunc-map
                ( B a)
                ( Sg A B)
                ( fiber-inclusion A B a))
              ( Set-trunc-map/is-surj
                ( B a)
                ( Sg A B)
                ( fiber-inclusion A B a)
                ( is-connected/fiber-inclusion-is-surj A B H a)))
      ( is-conn/is-inhabited A H)
#+end_src

We thus focus on showing, under the same hypotheses, that || \Sigma_{x: A}B(x) ||_0 has decidable equality. In fact, recall that decidability is closed under equivalence. Thus, let |(x, y)|_0 and |(x', y')|_0 of type || \Sigma_{x: A}B(x) ||_0. We have the following equivalences: 
   - |(x, y)|_0 = |(x', y')|_0 \simeq || (x, y) = (x', y') ||
as A is connected, let a : A. Moreover, still by connectivity, |a|_0 = |x|_0 and |a|_0 = |x'|_0, that is, we have two mere equalities || a = x || and || a = x' ||. Hence, || (x, y) = (x', y') || \simeq || (a, y) = (a, y') ||.
#+begin_src ctt
  is-htpy-finite/closed-Sg/dec-mere-eq' (A : U) (B : A -> U) (is-conn-A : is-conn A) (a : A)
                                        (h : (y y' : B a) -> is-decidable (mere-eq (Sg A B) (a, y) (a, y')))
                                        (y : B a) (x' : A) (y' : B x')
                                           : is-decidable (mere-eq (Sg A B) (a, y) (x', y')) =
    rec-Prop-trunc
      ( Path A a x')
      ( is-decidable/Prop
          ( mere-eq (Sg A B) (a, y) (x', y'))
          ( Prop-trunc/is-prop (Path (Sg A B) (a, y) (x', y'))))
      ( \ p. J A a
            ( \ z _. (b : B z) -> is-decidable (mere-eq (Sg A B) (a, y) (z, b)))
            ( h y) x' p y')
      ( Set-trunc/is-effective/map A a x'
        ( is-contr/all-elements-equal
          ( Set-trunc A)
          ( is-conn-A)
          ( Set-trunc/unit a)
          ( Set-trunc/unit x')))

  is-htpy-finite/closed-Sg/dec-mere-eq (A : U) (B : A -> U) (is-conn-A : is-conn A) (a : A)
                                       (h : (y y' : B a) -> is-decidable (mere-eq (Sg A B) (a, y) (a, y')))
                                       (x : A) (y : B x) (x' : A) (y' : B x')
                                          : is-decidable (mere-eq (Sg A B) (x, y) (x', y')) =
    rec-Prop-trunc
      ( Path A a x)
      ( is-decidable/Prop
          ( mere-eq (Sg A B) (x, y) (x', y'))
          ( Prop-trunc/is-prop (Path (Sg A B) (x, y) (x', y'))))
      ( \ p. J A a
            ( \ z _. (b : B z) -> is-decidable (mere-eq (Sg A B) (z, b) (x', y')))
            ( \ b. is-htpy-finite/closed-Sg/dec-mere-eq' A B is-conn-A a h b x' y') x p y)
      ( Set-trunc/is-effective/map A a x
        ( is-contr/all-elements-equal
          ( Set-trunc A)
          ( is-conn-A)
          ( Set-trunc/unit a)
          ( Set-trunc/unit x)))

  is-htpy-finite/closed-Sg/dec-mere-eq-dec-eq' (A : U) (B : A -> U) (is-conn-A : is-conn A) (a : A)
                                               (h : (y y' : B a) -> is-decidable (mere-eq (Sg A B) (a, y) (a, y')))
                                               (x : A) (y : B x) (x' : A) (y' : B x')
                                                  : is-decidable (Path (Set-trunc (Sg A B)) (Set-trunc/unit (x, y)) (Set-trunc/unit (x', y'))) =
    is-decidable/closed-Equiv
      ( Path (Set-trunc (Sg A B)) (Set-trunc/unit (x, y)) (Set-trunc/unit (x', y')))
      ( mere-eq (Sg A B) (x, y) (x', y'))
      ( Set-trunc/is-effective (Sg A B) (x, y) (x', y'))
      ( is-htpy-finite/closed-Sg/dec-mere-eq A B is-conn-A a h x y x' y')

  is-htpy-finite/closed-Sg/dec-mere-eq-dec-eq (A : U) (B : A -> U) (is-conn-A : is-conn A) (a : A)
                                              (h : (y y' : B a) -> is-decidable (mere-eq (Sg A B) (a, y) (a, y')))
                                              (t u : Set-trunc (Sg A B))
                                                   : is-decidable (Path (Set-trunc (Sg A B)) t u) =
    ind-Set-trunc/Prop
      ( Sg A B)
      ( \ t'. is-decidable/Prop
              ( Path (Set-trunc (Sg A B)) t' u)
              ( Set-trunc/is-set (Sg A B) t' u))
      ( \ t'. ind-Set-trunc/Prop
              ( Sg A B)
              ( \ u'. is-decidable/Prop
                      ( Path (Set-trunc (Sg A B)) (Set-trunc/unit t') u')
                      ( Set-trunc/is-set (Sg A B) (Set-trunc/unit t') u'))
              ( \ u'. is-htpy-finite/closed-Sg/dec-mere-eq-dec-eq' A B is-conn-A a h t'.1 t'.2 u'.1 u'.2) u) t
#+end_src
Thus, it suffices to show that || (a, y) = (a, y') || is decidable. But again, we have that || (a, y) = (a, y') || \simeq || \Sigma_{p: a = a} ||tr_B(p, y) = y'|| ||. The right-hand side of the underlying type is decidable by assumption (by \pi_0 finiteness of (B a)), but not the left-hand side. But as || tr_B(p, y) = y' || is a proposition, by the induction principle of the set truncation, we get a corresponding type taking || a = a ||_0 as parameter. We can then show that both things are finite, and thus that || \Sigma_{p: a = a} ||tr_B(p, y) = y'|| || is finite; that is, it is decidable.

*** Definition of the type
We start by defining the goal type by the induction principle of set truncation.
#+begin_src ctt
  is-htpy-finite/closed-Sg/type (A : U) (B : A -> U) (a : A) (y y' : B a) : Set-trunc (Path A a a) -> UU-Prop =
    rec-Set-trunc
      ( Path A a a)
      ( UU-Prop/Set)
      ( \ p. mere-eq/Prop (B a) (tr A a a p B y) y')
#+end_src

*** Equivalence
We continue by showing the equivalence between || (a, y) = (a, y') || and || \Sigma_{p: || a = a ||_0} P(p) ||. As these two types are propositions, we only need a back-and-forth map between them. The forward map is immediate by the computation rule of the induction principle of set truncation.
#+begin_src ctt
  lock Prop-trunc/is-prop UU-Prop/is-set
  is-htpy-finite/closed-Sg/Equiv/map (A : U) (B : A -> U) (a : A) (y y' : B a) : (p : Prop-trunc (Path (Sg A B) (a, y) (a, y')))
                                         -> (Prop-trunc (Sg (Set-trunc (Path A a a)) (\ q. Prop/type (is-htpy-finite/closed-Sg/type A B a y y' q)))) =
    rec-Prop-trunc
      ( Path (Sg A B) (a, y) (a, y'))
      ( Prop-trunc/Prop (Sg (Set-trunc (Path A a a)) (\ q. Prop/type (is-htpy-finite/closed-Sg/type A B a y y' q))))
      ( \ p. let t : SgPathO A B (a, y) (a, y') = PathSg->SgPathO A B (a, y) (a, y') p in
            Prop-trunc/unit
            ( Set-trunc/unit t.1,
              Prop-trunc/unit t.2)) 
#+end_src
The backward map is also straightforward as we prove a property; that is, we can get a path in A.
#+begin_src ctt
  is-htpy-finite/closed-Sg/Equiv/inv-map (A : U) (B : A -> U) (a : A) (y y' : B a)
                                            : (Prop-trunc (Sg (Set-trunc (Path A a a)) (\ q. Prop/type (is-htpy-finite/closed-Sg/type A B a y y' q))))
                                             -> Prop-trunc (Path (Sg A B) (a, y) (a, y')) =
    rec-Prop-trunc
      ( Sg (Set-trunc (Path A a a)) (\ q. Prop/type (is-htpy-finite/closed-Sg/type A B a y y' q)))
      ( Prop-trunc/Prop (Path (Sg A B) (a, y) (a, y')))
      ( \ t. ind-Set-trunc/Prop
              ( Path A a a)
              ( \ p. Prop/Pi
                      ( Prop/type (is-htpy-finite/closed-Sg/type A B a y y' p))
                      ( \ _. Prop-trunc/Prop (Path (Sg A B) (a, y) (a, y'))))
              ( \ p. rec-Prop-trunc
                      ( Path (B a) (tr A a a p B y) y')
                      ( Prop-trunc/Prop (Path (Sg A B) (a, y) (a, y')))
                      ( \ q'. Prop-trunc/unit ( SgPathO->PathSg A B
                                               ( a, y)
                                               ( a, y')
                                               ( p, q')))) t.1 t.2)
#+end_src
And we have the equivalence:
#+begin_src ctt
  is-htpy-finite/closed-Sg/Equiv (A : U) (B : A -> U) (a : A) (y y' : B a)
                                    : Equiv (Prop-trunc (Path (Sg A B) (a, y) (a, y')))
                                            (Prop-trunc (Sg (Set-trunc (Path A a a)) (\ q. Prop/type (is-htpy-finite/closed-Sg/type A B a y y' q)))) =
    Prop/Equiv 
      ( Prop-trunc/Prop (Path (Sg A B) (a, y) (a, y')))
      ( Prop-trunc/Prop (Sg (Set-trunc (Path A a a)) (\ q. Prop/type (is-htpy-finite/closed-Sg/type A B a y y' q))))
      ( is-htpy-finite/closed-Sg/Equiv/map A B a y y')
      ( is-htpy-finite/closed-Sg/Equiv/inv-map A B a y y')
#+end_src

*** Decidable equality of || \Sigma_{x : A}B(x) ||_0
We start by showing that || \Sigma_{w : || a = a ||_0}P(w) || is decidable. To show this, it suffices to show that the type underlying the propositional truncation is finite. It is the case as, by hypothesis, A is \pi_1 finite and || tr_B(p, y) = y' || \simeq |tr_B(p, y)|_0 = |y'|_0 which is decidable as || B(a) ||_0 is finite.
#+begin_src ctt
  is-htpy-finite/closed-Sg/subtype-decidable (A : U) (B : A -> U) (is-finite-A : is-htpy-finite one-Nat A)
                                             (is-finite-B : (x : A) -> is-htpy-finite zero (B x)) (a : A) (y y' : B a)
                                                          : is-decidable (Prop-trunc (Sg (Set-trunc (Path A a a)) (\ q. Prop/type (is-htpy-finite/closed-Sg/type A B a y y' q)))) =
    is-finite/is-decidable-Prop-trunc
      ( Sg (Set-trunc (Path A a a)) (\ q. Prop/type (is-htpy-finite/closed-Sg/type A B a y y' q)))
      ( is-finite/closed-Sg
          ( Set-trunc (Path A a a))
          ( \ q. Prop/type (is-htpy-finite/closed-Sg/type A B a y y' q))
          ( is-finite-A.2 a a)
          ( ind-Set-trunc/Prop
            ( Path A a a)
            ( \ q. is-finite/Prop (Prop/type (is-htpy-finite/closed-Sg/type A B a y y' q)))
            ( \ w. is-finite/closed-Equiv
                    ( Prop-trunc (Path (B a) (tr A a a w B y) y'))
                    ( Path (Set-trunc (B a)) (Set-trunc/unit (tr A a a w B y)) (Set-trunc/unit y'))
                    ( Set-trunc/is-effective' (B a) (tr A a a w B y) y')
                    ( is-decidable/is-finite
                      ( Path (Set-trunc (B a)) (Set-trunc/unit (tr A a a w B y)) (Set-trunc/unit y'))
                      ( Set-trunc/is-set (B a) (Set-trunc/unit (tr A a a w B y)) (Set-trunc/unit y'))
                      ( is-finite/has-decidable-equality
                        ( Set-trunc (B a))
                        ( is-finite-B a)
                        ( Set-trunc/unit (tr A a a w B y))
                        ( Set-trunc/unit y'))))))
#+end_src
Hence, under the same hypotheses, || (a, y) = (a, y') || is also decidable.
#+begin_src ctt
  is-htpy-finite/closed-Sg/mere-eq-decidable (A : U) (B : A -> U) (is-finite-A : is-htpy-finite one-Nat A)
                                             (is-finite-B : (x : A) -> is-htpy-finite zero (B x)) (a : A) (y y' : B a)
                                                          : is-decidable (mere-eq (Sg A B) (a, y) (a, y')) =
    is-decidable/closed-Equiv
      ( mere-eq (Sg A B) (a, y) (a, y'))
      ( Prop-trunc (Sg (Set-trunc (Path A a a)) (\ q. Prop/type (is-htpy-finite/closed-Sg/type A B a y y' q))))
      ( is-htpy-finite/closed-Sg/Equiv A B a y y')
      ( is-htpy-finite/closed-Sg/subtype-decidable A B is-finite-A is-finite-B a y y')
#+end_src
Adding the connectedness hypothesis, we show that || \Sigma_{x: A}B(x) ||_0 has a decidable equality.
#+begin_src ctt
  is-htpy-finite/closed-Sg/has-decidable-equality (A : U) (B : A -> U) (is-finite-A : is-htpy-finite one-Nat A) (is-conn-A : is-conn A)
                                                  (is-finite-B : (x : A) -> is-htpy-finite zero (B x)) (t u : Set-trunc (Sg A B))
                                                    : is-decidable (Path (Set-trunc (Sg A B)) t u) =
    rec-Prop-trunc A
      ( is-decidable/Prop
        ( Path (Set-trunc (Sg A B)) t u)
        ( Set/is-set (Set-trunc/Set (Sg A B)) t u))
      ( \ a. is-htpy-finite/closed-Sg/dec-mere-eq-dec-eq A B is-conn-A a
              ( is-htpy-finite/closed-Sg/mere-eq-decidable A B is-finite-A is-finite-B a) t u)
      ( is-conn/is-inhabited A is-conn-A)
#+end_src

*** Closed under \Sigma-types (base case)
Finally, we show the base case of the homotopy finite being closed under \Sigma-types.
#+begin_src ctt
  is-htpy-finite/closed-Sg/base (A : U) (B : A -> U) (H : is-conn A) (is-htpy-finite-A : is-htpy-finite one-Nat A)
				(is-htpy-finite-B : (x : A) -> is-htpy-finite zero (B x))
				   : is-htpy-finite zero (Sg A B) =
    is-htpy-finite/closed-Sg/base' A B H is-htpy-finite-A is-htpy-finite-B
      ( is-htpy-finite/closed-Sg/has-decidable-equality A B is-htpy-finite-A H is-htpy-finite-B)
#+end_src

** Closure under \Sigma-types
In this section, we generalize the previous result and forget the connectedness assumption. To do so, we do a double induction; on =n=, and then on the number of connected components. Let us start by showing a little lemma for finite types.
#+begin_src ctt
  is-htpy-finite/closed-Sg/Fin : (k : Nat) (B : Fin (suc k) -> U) (is-htpy-finite-Fin : is-htpy-finite one-Nat (Fin (suc k)))
                                 (is-htpy-finite-B : (x : Fin (suc k)) -> is-htpy-finite zero (B x))
                                  -> is-htpy-finite zero (Sg (Fin (suc k)) B) = split
    zero -> \ B is-htpy-finite-Fin is-htpy-finite-B.
      is-htpy-finite/closed-Sg/base
        ( Fin one-Nat) B
        ( Set-trunc/closed-contr
          ( Fin one-Nat)
          ( Fin/fin-one-is-contr))
        ( is-htpy-finite-Fin)
        ( is-htpy-finite-B)
    suc k -> \ B is-htpy-finite-Fin is-htpy-finite-B.
      is-htpy-finite/closed-Equiv
        ( Sg (Fin (suc (suc k))) B)
        ( Coprod (Sg (Fin (suc k)) (\ x. B (inl x))) (B (inr star)))
        ( Equiv/trans
          ( Sg (Fin (suc (suc k))) B)
          ( Coprod (Sg (Fin (suc k)) (\ x. B (inl x))) (Sg Unit (\ s. B (inr s))))
          ( Coprod (Sg (Fin (suc k)) (\ x. B (inl x))) (B (inr star)))
          ( Equiv/Sg-distr-over-coprod
            ( Fin (suc k))
            ( Unit) B)
          ( Coprod/closed-Equiv
            ( Sg (Fin (suc k)) (\ x. B (inl x)))
            ( Sg (Fin (suc k)) (\ x. B (inl x)))
            ( Sg Unit (\ s. B (inr s)))
            ( B (inr star))
            ( Equiv/refl (Sg (Fin (suc k)) (\ x. B (inl x))))
            ( Equiv/Sg-unit (\ x. B (inr x)))))
        ( zero)
        ( is-htpy-finite/closed-Coprod zero
          ( Sg (Fin (suc k)) (\ x. B (inl x)))
          ( B (inr star))
          ( is-htpy-finite/closed-Sg/Fin k
            ( \ x. B (inl x))
            ( is-htpy-finite/Coprod/left 
              ( Fin (suc k)) Unit one-Nat
              ( is-htpy-finite-Fin))
            ( \ x. is-htpy-finite-B (inl x)))
          ( is-htpy-finite-B (inr star)))
#+end_src
This lemma allows us to show the base case of the induction.
#+begin_src ctt
  -- is-htpy-finite/closed-Sg/z (A : U) (B : A -> U) (is-htpy-finite-A : is-htpy-finite one-Nat A)
  --                            (is-htpy-finite-B : (x : A) -> is-htpy-finite zero (B x))
  --                               : (k : Nat) -> (f : (Fin k) -> A) -> (e : Equiv (Fin k) (Set-trunc A)) -> is-htpy-finite zero (Sg A B) = split
  --   zero -> \ f e.
  --     is-htpy-finite/closed-Equiv
  --       ( Sg A B) Empty
  --       ( Equiv/trans
  --           ( Sg A B)
  --           ( Sg (Fin zero) (\ x. B (f x)))
  --           ( Empty)
  --           ( Equiv/sym
  --             ( Sg (Fin zero) (\ x. B (f x)))
  --             ( Sg A B)
  --             ( Sg/equiv-base
  --               ( Fin zero) A B
  --               ( Equiv/sym A Empty
  --                 ( Empty/equiv A
  --                   ( is-empty-Set-trunc/is-empty
  --                     ( Equiv/inv-map Empty (Set-trunc A) e))))))
  --           ( Equiv/Equiv-Sg-empty
  --             (\ x. B (f x))))
  --       ( zero)
  --       ( Empty/is-htpy-finite zero)
  --   suc k -> \ f e.
  --     is-htpy-finite/closed-Equiv'
  --       ( Sg (Fin (suc k)) ( \ x. B (f x)))
  --       ( Sg A B)
  --       ( Sg/equiv-base 
  --         ( Fin (suc k)) A B e)
  --       ( zero)
  --       ( is-htpy-finite/closed-Sg/Fin k
  --         ( \ x. B (f x))
  --         ( is-htpy-finite/closed-Equiv
  --           ( Fin (suc k)) A e one-Nat
  --           ( is-htpy-finite-A))
  --         ( \ x. is-htpy-finite-B (f x)))
#+end_src
And we can conclude the inductive case by remarking that for t, u : \Sigma A B, t = u is equivalent to \Sigma_{p: t.1 = u.1}(tr_B(p, t.2) = u.2).
#+begin_src ctt
  -- is-htpy-finite/closed-Sg' : (n : Nat) (A : U) (B : A -> U) (is-htpy-finite-A : is-htpy-finite (suc n) A)
  --                               (is-htpy-finite-B : (x : A) -> is-htpy-finite n (B x)) -> is-htpy-finite n (Sg A B) = split
  --   zero -> \ A B is-htpy-finite-A is-htpy-finite-B.
  --     rec-Prop-trunc
  --       ( count (Set-trunc A))
  --       ( is-htpy-finite/Prop zero (Sg A B))
  --       ( \ c. is-htpy-finite/closed-Sg/z A B is-htpy-finite-A is-htpy-finite-B c.1 c.2)
  --       ( is-htpy-finite-A.1)
  --   suc n -> \ A B is-htpy-finite-A is-htpy-finite-B.
  --     ( is-htpy-finite/closed-Sg' zero A B 
  --       ( is-htpy-finite/is-htpy-one-finite A (suc n) is-htpy-finite-A)
  --       ( \ x. is-htpy-finite/is-finite-Set-trunc
  --               ( B x)
  --               ( suc n)
  --               ( is-htpy-finite-B x)),
  --         \ t u. is-htpy-finite/closed-Equiv
  --                 ( Path (Sg A B) t u)
  --                 ( SgPathO A B t u)
  --                 ( PathSg/Equiv A B t u) n
  --                 ( is-htpy-finite/closed-Sg' n
  --                   ( Path A t.1 u.1)
  --                   ( \ p. Path (B u.1) (tr A t.1 u.1 p B t.2) u.2)
  --                   ( is-htpy-finite-A.2 t.1 u.1)
  --                   ( \ p. (is-htpy-finite-B u.1).2 (tr A t.1 u.1 p B t.2) u.2)))
#+end_src

#+RESULTS:
: Typecheck has succeeded.

** Unlock
    #+begin_src ctt
  unlock Prop-trunc/is-prop UU-Prop/is-set
    #+end_src
