#+NAME: Homotopy Finiteness
#+AUTHOR: Johann Rosain

* Homotopy Finiteness

  #+begin_src ctt
  module HomotopyFiniteness where
  #+end_src

This file is a formalization of the proof presented by Rijke in his [[https://www.cirm-math.fr/RepOrga/2689/Slides/s_rijke_3.pdf][CIRM talk]] about the finiteness of groups of finite order /k/.

** Packages imports

   #+begin_src ctt
  import Lib.IsFinite
  import Lib.SetTrunc
   #+end_src

** Homotopy finite
A type =A= is said n^th-/homotopy finite/ if it has finitely many connected components and all its homotopy groups \pi_i(A, x) are finite, for every i \le n and /x : A/.
#+begin_src ctt
  is-htpy-finite : Nat -> U -> U = split
    zero -> \ A. is-finite (Set-trunc A)
    suc k -> \ A. is-finite (Set-trunc A) *
                ( (x y : A) -> is-htpy-finite k (Path A x y))
#+end_src

** Closure under equivalence
If =A= and =B= are equivalent, then whenever one of them is \pi_n finite, the other one is also \pi_n finite.
#+begin_src ctt
  is-htpy-finite/closed-Equiv/aux : (n : Nat) -> (A B : U) -> Equiv A B -> is-htpy-finite n B -> is-htpy-finite n A = split
    zero -> \ A B e.
      is-finite/closed-Equiv
        ( Set-trunc A)
        ( Set-trunc B)
        ( Set-trunc/Equiv A B e)
    suc n -> \ A B e is-htpy-finite-B.
      ( is-finite/closed-Equiv
          ( Set-trunc A)
          ( Set-trunc B)
          ( Set-trunc/Equiv A B e)
          ( is-htpy-finite-B.1),
        \ x y.
          is-htpy-finite/closed-Equiv/aux n
          ( Path A x y)
          ( Path B (Equiv/map A B e x) (Equiv/map A B e y))
          ( Equiv/Equiv-id A B e x y)
          ( is-htpy-finite-B.2
            ( Equiv/map A B e x)
            ( Equiv/map A B e y)))

  is-htpy-finite/closed-Equiv (A B : U) (e : Equiv A B) (n : Nat) (is-htpy-finite-B : is-htpy-finite n B) : is-htpy-finite n A =
    is-htpy-finite/closed-Equiv/aux n A B e is-htpy-finite-B

  is-htpy-finite/closed-Equiv' (A B : U) (e : Equiv A B) (n : Nat) (is-htpy-finite-A : is-htpy-finite n A) : is-htpy-finite n B =
    is-htpy-finite/closed-Equiv B A (Equiv/sym A B e) n is-htpy-finite-A
#+end_src
** Equivalence of set-truncated function type
We show that if =A= is finite, then there is an equivalence between \Pi_{x: A}||B x||_0 and ||\Pi_{x: A} B x||_0. First, we show this result for =A = Fin k= by induction on /k/.
   * if /k = 0/, then both types are contractible. By the 3-for-2 property of contractibility, they are equivalent.
   * if /k > 0/, there is the following chain of equivalences:
     \Pi_{x: Fin (k + 1)}||B x||_0 \simeq \Pi_{x: Fin k}||B (inl x)||_0 \times ||B (inr star)||_0
                        \simeq ||\Pi_{x: Fin k} B (inl x)||_0 \times ||B (inr star)||_0
                        \simeq ||\Pi_{x: Fin (k + 1)}B x||_0
#+begin_src ctt
  Fin/Equiv-Pi-Set-trunc : (k : Nat) -> (B : Fin k -> U) -> Equiv ((x : Fin k) -> Set-trunc (B x)) (Set-trunc ((x : Fin k) -> B x)) = split
    zero -> \ B.
      is-contr/Equiv
        ( (x : Fin zero) -> Set-trunc (B x))
        ( Set-trunc ((x : Fin zero) -> B x))
        ( Empty/universal-dependent-property
          ( Fin zero)
          ( \ x. Set-trunc (B x))
          ( Equiv/refl (Fin zero)))
        ( Set-trunc/closed-contr
          ( (x : Fin zero) -> B x)
          ( Empty/universal-dependent-property
            ( Fin zero) B
            ( Equiv/refl (Fin zero))))
    suc k -> \ B.
      Equiv/comp five-Nat
        ( (x : Fin (suc k)) -> Set-trunc (B x))
        ( ((x : Fin k) -> Set-trunc (B (inl x))) * ((x : Unit) -> Set-trunc (B (inr x))))
        ( Coprod/dependent-universal-property
          ( Fin k) Unit (\ x. Set-trunc (B x)))
        ( ((x : Fin k) -> Set-trunc (B (inl x))) * (Set-trunc (B (inr star))))
        ( Equiv/prod'
          ( (x : Fin k) -> Set-trunc (B (inl x)))
          ( (x : Unit) -> Set-trunc (B (inr x)))
          ( Set-trunc (B (inr star)))
          ( Equiv/pi-Unit
            ( \ x. Set-trunc (B (inr x)))))
        ( (Set-trunc ((x : Fin k) -> B (inl x))) * (Set-trunc (B (inr star))))
        ( Equiv/prod
          ( (x : Fin k) -> Set-trunc (B (inl x)))
          ( Set-trunc ((x : Fin k) -> B (inl x)))
          ( Set-trunc (B (inr star)))
          ( Fin/Equiv-Pi-Set-trunc k
            ( \ x. B (inl x))))
        ( Set-trunc (((x : Fin k) -> B (inl x)) * (B (inr star))))
        ( Set-trunc/closed-Prod
          ( (x : Fin k) -> B (inl x))
          ( B (inr star)))
        ( Set-trunc (((x : Fin k) -> B (inl x)) * ((x : Unit) -> B (inr x))))
        ( Set-trunc/Equiv
          ( ((x : Fin k) -> B (inl x)) * (B (inr star)))
          ( ((x : Fin k) -> B (inl x)) * ((x : Unit) -> B (inr x)))
          ( Equiv/prod'
            ( (x : Fin k) -> B (inl x))
            ( B (inr star))
            ( (x : Unit) -> B (inr x))
            ( Equiv/sym
              ( (x : Unit) -> B (inr x))
              ( B (inr star))
              ( Equiv/pi-Unit (\ x. B (inr x))))))
        ( Set-trunc ((x : Fin (suc k)) -> B x))
        ( Set-trunc/Equiv
          ( ((x : Fin k) -> B (inl x)) * ((x : Unit) -> B (inr x)))
          ( (x : Fin (suc k)) -> B x)
          ( Equiv/sym
            ( (x : Fin (suc k)) -> B x)
            ( ((x : Fin k) -> B (inl x)) * ((x : Unit) -> B (inr x)))
            ( Coprod/dependent-universal-property
              ( Fin k) Unit B)))
#+end_src
This result cannot be directly generalized for a finite type (as =Equiv= is not a proposition). It can be, however, generalized for any type that has a counting.
#+begin_src ctt
  Path/Pi (A : U) (B : A -> U) (f : A -> A) (H : (x : A) -> Path A (f x) x) : Path U ((x : A) -> B (f x)) ((x : A) -> B x) =
    \ i. (x : A) -> B (H x i)

  count/Equiv-Pi-Set-trunc (A : U) (B : A -> U) (c : count A) : Equiv ((x : A) -> Set-trunc (B x)) (Set-trunc ((x : A) -> B x)) =
    let k : Nat = number-of-elements A c
        e : Equiv (Fin k) A = count/Equiv A c
        f : (Fin k) -> A = Equiv/map (Fin k) A e
        g : A -> (Fin k) = Equiv/inv-map (Fin k) A e
    in
    Equiv/comp three-Nat
      ( (x : A) -> Set-trunc (B x))
      ( (x : Fin k) -> Set-trunc (B (f x)))
      ( Equiv/dependent
        ( Fin k) A
        ( \ x. Set-trunc (B x)) e)
      ( Set-trunc ((x : Fin k) -> B (f x)))
      ( Fin/Equiv-Pi-Set-trunc k
        ( \ x. B (f x)))
      ( Set-trunc ((x : A) -> B (f (g x))))
      ( Set-trunc/Equiv
        ( (x : Fin k) -> B (f x))
        ( (x : A) -> B (f (g x)))
        ( Equiv/dependent A
          ( Fin k)
          ( \ x. B (f x))
          ( Equiv/sym
            ( Fin k) A e)))
      ( Set-trunc ((x : A) -> B x))
      ( Set-trunc/Equiv
        ( (x : A) -> B (f (g x)))
        ( (x : A) -> B x)
        ( path-to-equiv
          ( (x : A) -> B (f (g x)))
          ( (x : A) -> B x)
          ( Path/Pi A B (\ x. f (g x)) (Equiv/inv-right-htpy (Fin k) A e))))
#+end_src

** Homotopy Finiteness is closed downwards
If is-\pi_{n+1}-finite A, then is-\pi_n-finite A.
#+begin_src ctt
  is-htpy-finite/pred : (n : Nat) -> (A : U) -> is-htpy-finite (suc n) A -> is-htpy-finite n A = split
    zero -> \ A H. H.1
    suc n -> \ A H.
        ( H.1,
          \ x y.
            is-htpy-finite/pred n
              ( Path A x y) (H.2 x y))
#+end_src

** Homotopy finiteness implies finiteness of set-truncated type
If a type A is \pi_n-finite, then its set truncation is finite.
#+begin_src ctt
  is-htpy-finite/is-finite-Set-trunc (A : U) : (n : Nat) -> is-htpy-finite n A -> is-finite (Set-trunc A) = split
    zero -> id (is-finite (Set-trunc A))
    suc n -> \ H. H.1
#+end_src

** Closure under \Pi-types
In this section, we show that if =B= is a family of \pi_n finite types over a finite type =A=, then the product \Pi_{x: A}B(x) is also \pi_{n}-finite.
We proceed by induction over =n=. 
   * If =n= is zero, then by is-finite/\Pi, is-finite (\Pi_{x: A}||B x||_0). Moreover, \Pi_{x: A}||B x||_0 is equivalent to ||\Pi_{x: A}B(x)||_0 and as is-finite is closed by equivalences, the result follows.
   * If =n > 0=, then it suffices to show that f \sim g is \pi_n finite by function extensionality and \pi_n-finiteness closure under equivalence. It then suffices to use the induction hypothesis.
#+begin_src ctt
  is-htpy-finite/closed-Pi : (n : Nat) -> (A : U) -> (B : A -> U) -> is-finite A -> ((x : A) -> is-htpy-finite n (B x)) -> is-htpy-finite n ((x : A) -> B x) = split
   zero -> \ A B HA HB.
      (rec-Prop-trunc
        ( count A)
        ( is-finite/Prop (Set-trunc ((x : A) -> B x)))
        ( \ c.
            is-finite/closed-Equiv'
              ( (x : A) -> Set-trunc (B x))
              ( Set-trunc ((x : A) -> B x))
              ( count/Equiv-Pi-Set-trunc A B c)
              ( is-finite/Pi A
                ( \ x. Set-trunc (B x)) HA HB)) HA)

   suc n -> \ A B HA HB.
        let IH : is-htpy-finite n ((x : A) -> B x) = is-htpy-finite/closed-Pi n A B HA (\ x. is-htpy-finite/pred n (B x) (HB x)) in
        ( is-htpy-finite/is-finite-Set-trunc ((x : A) -> B x) n IH,
          \ f g.
            is-htpy-finite/closed-Equiv
              ( Path ((x : A) -> B x) f g)
              ( Htpy A B f g)
              ( htpy-eq/Equiv A B f g) n
              ( is-htpy-finite/closed-Pi n A
                ( \ x. Path (B x) (f x) (g x)) HA
                ( \ x. (HB x).2 (f x) (g x))))
#+end_src

** Closure under \Sigma-types, base case
In this section, we show that if =B= is a family of \pi_0-finite types over a connected, \pi_1-finite type A, then \Sigma_{x: A}B(x) is also \pi_0-finite, i.e., that || \Sigma_{x: A}B(x) ||_0 is finite. As A is connected, and we show a property, we assume that a : A. Then, the fiber inclusion function (recall that it is defined as \ b. (a, b) for b : B(a)) is surjective. As set truncation preserves surjectivity, it suffices to show that || \Sigma_{x: A}B(x) ||_0 has decidable equality.
#+begin_src ctt
  -- is-htpy-finite/closed-Sg/base' (A : U) (B : A -> U) (H : is-conn A) (is-htpy-finite-A : is-htpy-finite one-Nat A)
  --                                (is-htpy-finite-B : (x : A) -> is-htpy-finite zero (B x))
  --                                (has-dec-eq-Sg : has-decidable-equality (Set-trunc (Sg A B))) : is-htpy-finite zero (Sg A B) =
  
#+end_src

Thus, we start by showing that, under the hypotheses that A is \pi_1-finite and (B x) is \pi_0-finite forall x : A, || \Sigma_{x: A}B(x) ||_0 has decidable equality.

#+RESULTS:
: Typecheck has succeeded.

