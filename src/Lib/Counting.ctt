module Lib.Counting where

import Lib.Prop.Equiv
import Lib.Data.Fin  
import Lib.Prop.Proposition

count (A : U) : U =
  Sg Nat (\ k. Equiv (Fin k) A)

number-of-elements (A : U) (c : count A) : Nat = c.1
count/Equiv (A : U) (c : count A) : Equiv (Fin (number-of-elements A c)) A = c.2

count/fin-count (k : Nat) : count (Fin k) =
  (k, IdEquiv (Fin k))

count/zero-count : count (Fin zero) =
  count/fin-count zero

count/one-count : count (Fin one-Nat) =
  count/fin-count one-Nat

count/closed-equiv (A B : U) (e : Equiv A B) (c : count B) : count A =
  (number-of-elements B c,
   Equiv/trans (Fin (number-of-elements B c)) B A (count/Equiv B c) (Equiv/sym A B e))

count/closed-equiv' (A B : U) (e : Equiv A B) (c : count A) : count B =
  count/closed-equiv B A (Equiv/sym A B e) c

count/empty-has-zero-count (A : U) (c : count A) (f : is-empty A) : Path Nat zero (number-of-elements A c) =
  let e : Equiv (Fin (number-of-elements A c)) Empty =
        Equiv/trans (Fin (number-of-elements A c)) A Empty (count/Equiv A c) (Empty/equiv A f) in
  ind-Nat (\ k. (Equiv (Fin k) Empty) -> Path Nat zero k)
          (\ _. refl Nat zero)
          (\ n _ e'. ex-falso (Path Nat zero (suc n)) ((Equiv/map (Fin (suc n)) Empty e') (zero-Fin n)))
          (number-of-elements A c) e

count/zero-is-empty (A : U) (c : count A) (p : Path Nat zero (number-of-elements A c)) : is-empty A =
   ind-Sg Nat (\ k. Equiv (Fin k) A)
              (\ z. (Path Nat zero z.1) -> is-empty A)
              (\ k e p'. J Nat zero (\ k' _. Equiv (Fin k') A -> is-empty A) (\ e'. Equiv/inv-map Empty A e') k p' e)
              c p

-- count/contractible-has-one-element (A : U) (c : count A) (cA : is-contr A) : Path Nat one-Nat (number-of-elements A c) =
--   ind-Sg A (\ k. Equiv (Fin k) A)
--            (\ p. Path Nat one-Nat p.1)
--            (ind-Nat (\ k. Equiv (Fin k) A -> Path Nat one-Nat k)
--                     (\ e. ex-falso (Path Nat one-Nat zero) (Equiv/inv-map (Fin zero) A e (center A cA)))
--                     (\ k _ e. ind-Nat (\ k'. Equiv (Fin k') A -> Path Nat one-Nat k')
--                                      (\ _. refl Nat one-Nat)
--                                      (\ k' r e'. ex-falso (Path Nat one-Nat k') ?)) k e) c

count/one-element-is-contr (A : U) (c : count A) (p : Path Nat one-Nat (number-of-elements A c)) : is-contr A =
  J Nat one-Nat (\ k' _. Equiv (Fin k') A -> is-contr A)
                (\ e'. is-contr/is-contr-equiv' (Fin one-Nat) A e' Fin/fin-one-is-contr)
                (number-of-elements A c) p (count/Equiv A c)

-- count/contr-count (A : U) (c : is-contr A) : count A =
--   (one-Nat, count/closed-equiv A (Fin one-Nat) () count/one-count)

count/countable-is-decidable (X : U) (c : count X) : is-decidable X =
  ind-Sg Nat (\ k. Equiv (Fin k) X)
             (\ _. is-decidable X)
             (ind-Nat (\ k'. Equiv (Fin k') X -> is-decidable X)
                      (\ e'. is-decidable/Equiv' Empty X e' is-decidable/Empty)
                      (\ k' _ e'. inl ((Equiv/map (Fin (suc k')) X e') (inr star)))) c

count/is-decidable-is-countable (X : U) (p : is-prop X) : is-decidable X -> count X = split
  inl x -> (one-Nat, Equiv/trans (Fin one-Nat) Unit X (Equiv/Equiv-copr-empty-type Unit) (Equiv/sym X Unit (is-prop/is-subterminal X p x)))
  inr f -> (zero, Equiv/sym X Empty (Empty/equiv X f))

count/has-decidable-eq (A : U) (c : count A) : has-decidable-equality A =
  has-decidable-equality/Equiv' (Fin (number-of-elements A c)) A (count/Equiv A c) (Fin/decidable-eq (number-of-elements A c))
