module Lib.Counting where

import Lib.Prop.Equiv
import Lib.Data.Fin  
import Lib.Prop.Proposition
import Lib.Prop.Fin

count (A : U) : U =
  Sg Nat (\ k. Equiv (Fin k) A)

number-of-elements (A : U) (c : count A) : Nat = c.1
count/Equiv (A : U) (c : count A) : Equiv (Fin (number-of-elements A c)) A = c.2

count/fin-count (k : Nat) : count (Fin k) =
  (k, IdEquiv (Fin k))

count/zero-count : count (Fin zero) =
  count/fin-count zero

count/one-count : count (Fin one-Nat) =
  count/fin-count one-Nat

count/closed-equiv (A B : U) (e : Equiv A B) (c : count B) : count A =
  (number-of-elements B c,
   Equiv/trans (Fin (number-of-elements B c)) B A (count/Equiv B c) (Equiv/sym A B e))

count/closed-equiv' (A B : U) (e : Equiv A B) (c : count A) : count B =
  count/closed-equiv B A (Equiv/sym A B e) c

count/empty-has-zero-count (A : U) (c : count A) (f : is-empty A) : Path Nat zero (number-of-elements A c) =
  let e : Equiv (Fin (number-of-elements A c)) Empty =
        Equiv/trans (Fin (number-of-elements A c)) A Empty (count/Equiv A c) (Empty/equiv A f) in
  ind-Nat (\ k. (Equiv (Fin k) Empty) -> Path Nat zero k)
          (\ _. refl Nat zero)
          (\ n _ e'. ex-falso (Path Nat zero (suc n)) ((Equiv/map (Fin (suc n)) Empty e') (zero-Fin n)))
          (number-of-elements A c) e

count/zero-is-empty (A : U) (c : count A) (p : Path Nat zero (number-of-elements A c)) : is-empty A =
   ind-Sg Nat (\ k. Equiv (Fin k) A)
              (\ z. (Path Nat zero z.1) -> is-empty A)
              (\ k e p'. J Nat zero (\ k' _. Equiv (Fin k') A -> is-empty A) (\ e'. Equiv/inv-map Empty A e') k p' e)
              c p

-- count/contractible-has-one-element (A : U) (c : count A) (cA : is-contr A) : Path Nat one-Nat (number-of-elements A c) =
--   ind-Sg A (\ k. Equiv (Fin k) A)
--            (\ p. Path Nat one-Nat p.1)
--            (ind-Nat (\ k. Equiv (Fin k) A -> Path Nat one-Nat k)
--                     (\ e. ex-falso (Path Nat one-Nat zero) (Equiv/inv-map (Fin zero) A e (center A cA)))
--                     (\ k _ e. ind-Nat (\ k'. Equiv (Fin k') A -> Path Nat one-Nat k')
--                                      (\ _. refl Nat one-Nat)
--                                      (\ k' r e'. ex-falso (Path Nat one-Nat k') ?)) k e) c

count/one-element-is-contr (A : U) (c : count A) (p : Path Nat one-Nat (number-of-elements A c)) : is-contr A =
  J Nat one-Nat (\ k' _. Equiv (Fin k') A -> is-contr A)
                (\ e'. is-contr/is-contr-equiv' (Fin one-Nat) A e' Fin/fin-one-is-contr)
                (number-of-elements A c) p (count/Equiv A c)

-- count/contr-count (A : U) (c : is-contr A) : count A =
--   (one-Nat, count/closed-equiv A (Fin one-Nat) () count/one-count)

count/countable-is-decidable (X : U) (c : count X) : is-decidable X =
  ind-Sg Nat (\ k. Equiv (Fin k) X)
             (\ _. is-decidable X)
             (ind-Nat (\ k'. Equiv (Fin k') X -> is-decidable X)
                      (\ e'. is-decidable/Equiv' Empty X e' is-decidable/Empty)
                      (\ k' _ e'. inl ((Equiv/map (Fin (suc k')) X e') (inr star)))) c

count/is-decidable-is-countable (X : U) (p : is-prop X) : is-decidable X -> count X = split
  inl x -> (one-Nat, Equiv/trans (Fin one-Nat) Unit X (Equiv/Equiv-copr-empty-type Unit) (Equiv/sym X Unit (is-prop/is-subterminal X p x)))
  inr f -> (zero, Equiv/sym X Empty (Empty/equiv X f))

count/has-decidable-eq (A : U) (c : count A) : has-decidable-equality A =
  has-decidable-equality/Equiv' (Fin (number-of-elements A c)) A (count/Equiv A c) (Fin/decidable-eq (number-of-elements A c))

count/closed-Coprod (A B : U) (cA : count A) (cB : count B) : count (Coprod A B) =
  let k : Nat = number-of-elements A cA
      l : Nat = number-of-elements B cB
  in
  (plus-Nat k l, (Equiv/trans (Fin (plus-Nat k l)) (Coprod (Fin k) (Fin l)) (Coprod A B)
                 (Fin/Equiv-add-copr k l) (Coprod/closed-Equiv (Fin k) A (Fin l) B (count/Equiv A cA) (count/Equiv B cB))))

count/closed-Sg/sg (A : U) (B : A -> U) (H : (x : A) -> count (B x)) : (k : Nat) -> (e : Equiv (Fin k) A) -> count (Sg A B) = split
  zero -> \ _. count/closed-equiv (Sg A B) Empty (Equiv/Equiv-Sg-empty B) (count/zero-count)
  suc k -> \ e.
    let f : Fin (suc k) -> A = (Equiv/map (Fin (suc k)) A e) in
      count/closed-equiv (Sg A B) (Coprod (Sg (Fin k) (\ x. B (f (inl x)))) (B (f (inr star)))) ? -- Sg A B ~ Sg (Fin k + 1) B o e ~ (Sg (Fin k) B o e o inl) + B(e(inr(star)))
        (count/closed-Coprod (Sg (Fin k) (\ x. B (f (inl x))))
                             (B (f (inr star))) (count/closed-Sg/sg (Fin k) (\ x. B (f (inl x))) (\ x. H (f (inl x))) k (Equiv/refl (Fin k))))

-- count/closed-Sg (A : U) (B : A -> U) (cA : count A) (H : (x : A) -> count (B x)) : count (Sg A B) =
