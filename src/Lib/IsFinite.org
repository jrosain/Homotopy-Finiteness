#+NAME: IsFinite
#+AUTHOR: Johann Rosain

* Finite types

#+begin_src ctt
  module Lib.IsFinite where
#+end_src

Finite types are types that can be counted. However, when defining finite types, we do not especially care about the counting, we only care about the fact that /it can be counted/, which translates in the definition by using [[PropTrunc.org][propositional truncation]]. However, this definition is not practical as it does not give the number of elements. Hence, we also show that finite types are /logically equivalent/ to types with cardinalities.

** Packages imports

#+begin_src ctt
  import Lib.PropTrunc
  import Lib.Counting
  import Lib.Image
  import Lib.Prop.Nat
  import Lib.Prop.Coprod
  import Lib.Prop.Empty  
  import Lib.Prop.Decidability
#+end_src

** Definition
Definition using propositional truncation.
   #+begin_src ctt
  is-finite (X : U) : U =
    Prop-trunc
      ( count X)
   #+end_src
Some shortcuts.
#+begin_src ctt
  is-finite/is-prop (X : U) : is-prop (is-finite X) =
    Prop-trunc/is-prop
      ( count X)

  is-finite/Prop (X : U) : UU-Prop =
    ( is-finite X,
      is-finite/is-prop X)
#+end_src

** Properties

*** A type that has a count is finite
#+begin_src ctt
  count/is-finite (X : U) (c : count X) : is-finite X =
    Prop-trunc/unit c
#+end_src
*** Unit is finite
    #+begin_src ctt
  Unit/is-finite : is-finite Unit =
    count/is-finite Unit
      ( count/Unit)
    #+end_src
*** Fin is finite
#+begin_src ctt
  Fin/is-finite (k : Nat) : is-finite (Fin k) =
    count/is-finite
      ( Fin k)
      ( count/fin-count k)
#+end_src
*** Closure under equivalence
Of course, if =Equiv X Y= and one of them is finite, the other one is also finite.
#+begin_src ctt
  is-finite/closed-Equiv (A B : U) (e : Equiv A B) (is-finite-B : is-finite B) : is-finite A =
    Prop-trunc/map
      ( count B)
      ( count A)
      ( count/closed-equiv A B e) is-finite-B    

  is-finite/closed-Equiv' (A B : U) (e : Equiv A B) (is-finite-A : is-finite A) : is-finite B =
    is-finite/closed-Equiv B A (Equiv/sym A B e) is-finite-A
#+end_src

** Cardinality
We define the notion of having a cardinality and its equivalence to the notion of =is-finite=.
#+begin_src ctt
  has-cardinality (X : U) : U =
    Sg Nat
      ( \ k. mere-equiv (Fin k) X)
#+end_src
Of course, =has-cardinality= is a proposition.
#+begin_src ctt
  has-cardinality/is-prop/sg (X : U) (k : Nat) (h : mere-equiv (Fin k) X) (k' : Nat) (h' : mere-equiv (Fin k') X)
                                : Path (has-cardinality X) (k, h) (k', h') =
    SgPath-prop Nat
      ( \ n. mere-equiv (Fin n) X)
      ( \ n. mere-equiv/is-prop (Fin n) X)
      ( k, h)
      ( k', h')
      ( rec-Prop-trunc
        ( Equiv (Fin k) X)
        ( Nat/eq/Prop k k')
        ( \ e. rec-Prop-trunc
                ( Equiv (Fin k') X)
                ( Nat/eq/Prop k k')
                ( \ e'. Fin/is-inj k k'
                         ( Equiv/trans
                            ( Fin k) X
                            ( Fin k') e
                            ( Equiv/sym (Fin k') X e'))) h') h)

  has-cardinality/is-prop (X : U) : is-prop (has-cardinality X) =
    \ h h'. has-cardinality/is-prop/sg X h.1 h.2 h'.1 h'.2

  has-cardinality/Prop (X : U) : UU-Prop =
    ( has-cardinality X,
      has-cardinality/is-prop X)
#+end_src
Thus, there is an equivalence between having a cardinality and being finite.
#+begin_src ctt
  is-finite/has-cardinality (X : U) : is-finite X -> has-cardinality X =
    rec-Prop-trunc
      ( count X)
      ( has-cardinality/Prop X)
      ( \ c. ( number-of-elements X c,
              Prop-trunc/unit (count/Equiv X c)))

  has-cardinality/is-finite' (X : U) (k : Nat) (e : mere-equiv (Fin k) X) : is-finite X =
    rec-Prop-trunc
      ( Equiv (Fin k) X)
      ( is-finite/Prop X)
      ( \ e'. Prop-trunc/unit (k, e')) e    

  has-cardinality/is-finite (X : U) : has-cardinality X -> is-finite X =
    \ t. has-cardinality/is-finite' X t.1 t.2
#+end_src
Some shortcuts.
#+begin_src ctt
  has-cardinality/card (X : U) (h : has-cardinality X) : Nat = h.1

  has-cardinality/Equiv (X : U) (h : has-cardinality X) : mere-equiv (Fin (has-cardinality/card X h)) X = h.2

  card (X : U) (i : is-finite X) : Nat =
    has-cardinality/card X
      ( is-finite/has-cardinality X i)
#+end_src

** Some immediate consequences
=X= and =Y= are finite iff their coproduct is finite.
   #+begin_src ctt
  is-finite/closed-Coprod (A B : U) (is-finite-A : is-finite A) (is-finite-B : is-finite B) : is-finite (Coprod A B) =
    rec-Prop-trunc
      ( count A)
      ( is-finite/Prop (Coprod A B))
      ( \ c. rec-Prop-trunc
              ( count B)
              ( is-finite/Prop (Coprod A B))
              ( \ c'. Prop-trunc/unit (count/closed-Coprod A B c c'))
              is-finite-B)
      is-finite-A

  is-finite/closed-Coprod-left (A B : U) (is-finite-copr : is-finite (Coprod A B)) : is-finite A =
    rec-Prop-trunc
      ( count (Coprod A B))
      ( is-finite/Prop A)
      ( \ c. Prop-trunc/unit (count/closed-Coprod-left A B c))
      is-finite-copr

  is-finite/closed-Coprod-right (A B : U) (is-finite-copr : is-finite (Coprod A B)) : is-finite B =
    rec-Prop-trunc
      ( count (Coprod A B))
      ( is-finite/Prop B)
      ( \ c. Prop-trunc/unit (count/closed-Coprod-right A B c))
      is-finite-copr
   #+end_src
If =X= and =Y= are finite, then =X * Y= is also finite.
#+begin_src ctt
  is-finite/closed-Prod (A B : U) (is-finite-A : is-finite A) (is-finite-B : is-finite B) : is-finite (A * B) =
    rec-Prop-trunc
      ( count A)
      ( is-finite/Prop (A * B))
      ( \ c. rec-Prop-trunc
              ( count B)
              ( is-finite/Prop (A * B))
              ( \ c'. Prop-trunc/unit (count/closed-Prod A B c c'))
              is-finite-B)
      is-finite-A
#+end_src

** Cardinal of Bool * Bool
   #+begin_src ctt
  Bool : U = Coprod Unit Unit

  true : Bool = inl star
  false : Bool = inr star

  Bool/is-finite : is-finite Bool =
    is-finite/closed-Coprod
      Unit
      Unit
      Unit/is-finite
      Unit/is-finite

  BoolBool/card : Nat =
    card
      ( Bool * Bool)
      ( is-finite/closed-Prod Bool Bool Bool/is-finite Bool/is-finite)
   #+end_src

** Closure under \Pi-types
In this section, we show that if =B= is a family of finite types over a finite type =A=, then the product \Pi_{x: A}B(x) is also finite.
*** Finite family over =Fin k=
First, we start by showing that if =B= is a finite family over =Fin k=, then \Pi_{x: Fin k}B(x) is also finite. This proof is by induction on =k=. 
The case =k = 0= is trivial: a family over the empty type is contractible thus it has a count and it is finite. 
The case =k > 0= is done using the dependent universal property of coproduct. By induction hypothesis, \Pi_{x: Fin k}B(x) is finite and by hypothesis, B(inr star) is also finite. Finally, a product of finite things is finite.
#+begin_src ctt
  is-finite/pi' : (k : Nat) -> (B : Fin k -> U) -> ((x : Fin k) -> is-finite (B x)) -> is-finite ((x : Fin k) -> B x) = split
    zero ->
      \ B _.
        count/is-finite
          ( (x : Fin zero) -> B x)
          ( count/contr-count
            ( (x : Fin zero) -> B x)
            ( Empty/universal-dependent-property
              ( Fin zero) B
              ( Equiv/refl (Fin zero))))
    suc k ->
      \ B is-fin-B.
        is-finite/closed-Equiv
          ( (x : Fin (suc k)) -> B x)
          ( ((x : Fin k) -> B (inl x)) * (B (inr star)))
          ( Equiv/trans
            ( (x : Fin (suc k)) -> B x)
            ( ((x : Fin k) -> B (inl x)) * ((u : Unit) -> B (inr u)))
            ( ((x : Fin k) -> B (inl x)) * (B (inr star)))
            ( Coprod/dependent-universal-property
              ( Fin k) Unit B)
            ( Equiv/prod'
              ( (x : Fin k) -> B (inl x))
              ( (u : Unit) -> B (inr u))
              ( B (inr star))
              ( Equiv/pi-Unit
                ( \ u. B (inr u)))))
          ( is-finite/closed-Prod
            ( (x : Fin k) -> B (inl x))
            ( B (inr star))
            ( is-finite/pi' k
              ( \ x. B (inl x))
              ( \ x. is-fin-B (inl x)))
            ( is-fin-B (inr star)))
#+end_src

*** Finite family over finite type
Let =A= be a finite type. As =is-finite= is a proposition, by the induction principle of the propositional truncation, we assume that we have a count of =A=; that is, an equivalence from Fin k to A for some k. Then, as =is-finite= is closed under equivalence, for any finite family =B= over a finite type =A=, \Pi_{x: A}B(x) is also finite.
#+begin_src ctt
  is-finite/Pi (A : U) (B : A -> U) (is-finite-A : is-finite A) (is-finite-B : (x : A) -> is-finite (B x))
                  : is-finite ((x : A) -> B x) =
    rec-Prop-trunc
      ( count A)
      ( is-finite/Prop ((x : A) -> B x))
      ( \ c.
        is-finite/closed-Equiv
          ( (x : A) -> B x)
          ( (x : Fin (number-of-elements A c)) -> B (Equiv/map (Fin (number-of-elements A c)) A (count/Equiv A c) x))
          ( Equiv/dependent
            ( Fin (number-of-elements A c)) A B
            ( count/Equiv A c))
          ( is-finite/pi'
            ( number-of-elements A c)
            ( \ x. B (Equiv/map (Fin (number-of-elements A c)) A (count/Equiv A c) x))
            ( \ x. is-finite-B (Equiv/map (Fin (number-of-elements A c)) A (count/Equiv A c) x)))) is-finite-A
#+end_src

** A finite type is a set
   #+begin_src ctt
  is-finite/is-set (A : U) : is-finite A -> is-set A =
    rec-Prop-trunc
      ( count A)
      ( is-set/Prop A)
      ( \ c. count/is-set A c)
   #+end_src
** A finite type has decidable equality
If a type is finite, then it is a set. In particular, =has-decidable-equality= is a proposition on this type, so it follows by the recursion principle of propositional truncation that a finite type has decidable equality.
   #+begin_src ctt
  is-finite/has-decidable-equality (A : U) (is-finite-A : is-finite A) : has-decidable-equality A =
    rec-Prop-trunc
      ( count A)
      ( has-decidable-equality/Prop A
        ( is-finite/is-set A is-finite-A))
      ( count/has-decidable-eq A) is-finite-A
   #+end_src

** Finite choice
There is a finite choice map (\Pi_{x: A}||B x||) \to ||\Pi_{x: A}B(x)|| for any finite type A and family over this finite type B.
#+begin_src ctt
  Fin/choice : (k : Nat) (B : Fin k -> U) (H : (x : Fin k) -> Prop-trunc (B x)) -> Prop-trunc ((x : Fin k) -> B x) = split
    zero -> \ B _.
      Prop-trunc/unit
        ( center ((x : Fin zero) -> B x)
          ( Empty/universal-dependent-property
            ( Fin zero) B
            ( Equiv/refl (Fin zero))))
    suc k -> \ B.
      Equiv/map
        ( (x : Fin (suc k)) -> Prop-trunc (B x))
        ( Prop-trunc ((x : Fin (suc k)) -> B x))
        ( Equiv/comp five-Nat
          ( (x : Fin (suc k)) -> Prop-trunc (B x))
          ( ((x : Fin k) -> Prop-trunc (B (inl x))) * ((x : Unit) -> Prop-trunc (B (inr x))))
          ( Coprod/dependent-universal-property
            ( Fin k) Unit (\ x. Prop-trunc (B x)))
          ( ((x : Fin k) -> Prop-trunc (B (inl x))) * (Prop-trunc (B (inr star))))
          ( Equiv/prod'
            ( (x : Fin k) -> Prop-trunc (B (inl x)))
            ( (x : Unit) -> Prop-trunc (B (inr x)))
            ( Prop-trunc (B (inr star)))
            ( Equiv/pi-Unit
              ( \ x. Prop-trunc (B (inr x)))))
          ( (Prop-trunc ((x : Fin k) -> B (inl x))) * (Prop-trunc (B (inr star))))
          ( Equiv/prod
            ( (x : Fin k) -> Prop-trunc (B (inl x)))
            ( Prop-trunc ((x : Fin k) -> B (inl x)))
            ( Prop-trunc (B (inr star)))
            ( Prop/Equiv
              ( Prop/Pi (Fin k) (\ x. Prop-trunc/Prop (B (inl x))))
              ( Prop-trunc/Prop ((x : Fin k) -> B (inl x)))
              ( Fin/choice k (\ x. B (inl x)))
              ( Prop-trunc/Pi/map-out
                ( Fin k)
                ( \ x. B (inl x)))))
          ( Prop-trunc (((x : Fin k) -> B (inl x)) * (B (inr star))))
          ( Prop-trunc/closed-Prod
            ( (x : Fin k) -> B (inl x))
            ( B (inr star)))
          ( Prop-trunc (((x : Fin k) -> B (inl x)) * ((x : Unit) -> B (inr x))))
          ( Equiv/Prop-trunc
            (((x : Fin k) -> B (inl x)) * (B (inr star)))
            (((x : Fin k) -> B (inl x)) * ((x : Unit) -> B (inr x)))
            ( Equiv/prod'
              ( (x : Fin k) -> B (inl x))
              ( B (inr star))
              ( (x : Unit) -> B (inr x))
              ( Equiv/sym
                ( (x : Unit) -> B (inr x))
                ( B (inr star))
                ( Equiv/pi-Unit (\ x. B (inr x))))))
          ( Prop-trunc ((x : Fin (suc k)) -> B x))
          ( Equiv/Prop-trunc
            ( ((x : Fin k) -> B (inl x)) * ((x : Unit) -> B (inr x)))
            ( (x : Fin (suc k)) -> B x)
            ( Equiv/sym
              ( (x : Fin (suc k)) -> B x)
              ( ((x : Fin k) -> B (inl x)) * ((x : Unit) -> B (inr x)))
              ( Coprod/dependent-universal-property
                ( Fin k) Unit B))))

  is-finite/choice (A : U) (B : A -> U) (is-finite-A : is-finite A) (H : (x : A) -> Prop-trunc (B x)) : Prop-trunc ((x : A) -> B x) =
    rec-Prop-trunc
      ( count A)
      ( Prop-trunc/Prop
        ( (x : A) -> B x))
      ( \ c. 
          let k : Nat = number-of-elements A c
              f : Fin k -> A = Equiv/map (Fin k) A (count/Equiv A c)
              g : A -> Fin k = Equiv/inv-map (Fin k) A (count/Equiv A c)
           in
          rec-Prop-trunc
            ( (x : (Fin k)) -> B (f x))
            ( Prop-trunc/Prop ((x : A) -> B x))
            ( \ h. Prop-trunc/unit
                  ( \ x. tr A (f (g x)) x (Equiv/inv-right-htpy (Fin k) A (count/Equiv A c) x) B (h (g x))))
            ( Fin/choice k
              ( \ x. B (f x))
              ( \ x. H (f x)))) is-finite-A
#+end_src

** Closure under \Sigma-types
Given a finite type =A= and a family of finite types =B= over =A=, \Sigma A B is also finite.
#+begin_src ctt
  is-finite/closed-Sg (A : U) (B : A -> U) (is-finite-A : is-finite A) (H : (x : A) -> is-finite (B x)) : is-finite (Sg A B) =
    rec-Prop-trunc
      ( count A)
      ( is-finite/Prop
          ( Sg A B))
      ( \ c. rec-Prop-trunc
              ( (x : A) -> count (B x))
              ( is-finite/Prop
                ( Sg A B))
              ( \ H'. Prop-trunc/unit (count/closed-Sg A B c H'))
              ( is-finite/choice A (\ x. count (B x)) is-finite-A H)) is-finite-A
#+end_src

** Surjective map codomain is finite iff it has decidable equality
We show that if f : A \to B is a surjective map and A is finite, then B is finite iff it has decidable equality. In fact, the forward direction is immediate from =is-finite/has-decidable-equality=. We show the converse by induction on the number of elements. First, we set =A= to be =Fin k= and we show that =B= has a count. The base case is trivial, \emptyset \simeq B.
#+begin_src ctt
  has-decidable-equality/is-finite/base/map (B : U) (f : Empty -> B) (H : is-surj Empty B f) : B -> Empty =
    \ b. rec-Prop-trunc
        ( Fib Empty B f b)
        ( Empty/Prop)
        ( \ t. t.1)
        ( H b)

  has-decidable-equality/is-finite/base/right-htpy (B : U) (f : Empty -> B) (H : is-surj Empty B f) (x : Empty)
                                                      : Path Empty (has-decidable-equality/is-finite/base/map B f H (f x)) x =
    ex-falso
      ( Path Empty (has-decidable-equality/is-finite/base/map B f H (f x)) x) x    

  has-decidable-equality/is-finite/base/left-htpy (B : U) (f : Empty -> B) (H : is-surj Empty B f) (b : B)
                                                     : Path B (f (has-decidable-equality/is-finite/base/map B f H b)) b =
    ex-falso
      ( Path B (f (has-decidable-equality/is-finite/base/map B f H b)) b)
      ( rec-Prop-trunc
          ( Fib Empty B f b)
          ( Empty/Prop)
          ( \ t. t.1)
          ( H b))

  has-decidable-equality/is-finite/base (B : U) (f : Empty -> B) (H : is-surj Empty B f) : count B =
    ( zero,
      has-inverse/Equiv Empty B f
        ( has-decidable-equality/is-finite/base/map B f H,
          ( has-decidable-equality/is-finite/base/left-htpy B f H,
            has-decidable-equality/is-finite/base/right-htpy B f H)))
#+end_src
The inductive case is more involved. First, we make it decidable to know whether there is an =x : Fin k= such that f(x) = y.
#+begin_src ctt
  has-decidable-equality/is-finite/decide/eq (B : U) (y : B) (k : Nat) (f : Fin (suc k) -> B) (X : Maybe (Fin (suc k)))
                                                : Coprod (Path B (f (inr star)) y) (neg (Path B (f (inr star)) y)) -> Maybe (Fin (suc k)) = split
    inl _ -> inl (inr star)
    inr _ -> X

  has-decidable-equality/is-finite/iterate-maybe (k : Nat) : (X : Maybe (Fin k)) -> Maybe (Fin (suc k)) = split
    inl x -> inl (inl x)
    inr y -> inr y

  has-decidable-equality/is-finite/decide (B : U) (y : B) (Heq : has-decidable-equality B) : (k : Nat) -> (f : Fin k -> B) -> Maybe (Fin k) = split
    zero -> \ _. inr star
    suc k -> \ f. has-decidable-equality/is-finite/decide/eq B y k f
                ( has-decidable-equality/is-finite/iterate-maybe k (has-decidable-equality/is-finite/decide B y Heq k (\ x. f (inl x))))
                ( Heq (f (inr star)) y)
#+end_src
Thus, we can decide whether inr(\star) is the only preimage of f(inr(\star)) or not. If it is not, it is easy, a count of B is yielded by the induction hypothesis and the surjection is built using the decided value. If it is, there is a surjection between Fin k and B without f(inr(\star)). Then, it suffices to add one to the count yielded to get the right count.

TODO: the definition is fine, but do it with f : Fin (suc k) -> B, so that there are two cases, either f(inr(\star)) appears in Fin k and then show that in this case B is equivalent to the defined type, either it doesn't and then show that B is equivalent to the defined type + 1.
#+begin_src ctt
  has-decidable-equality/is-finite/subtype (k : Nat) (B : U) (f : Fin k -> B) (H : (y : B) -> Fib (Fin k) B f y) : U =
    Sg (Fin k) (\ x. Path (Fin k) (H (f x)).1 x)

  has-decidable-equality/is-finite/map (k : Nat) (B : U) (f : Fin k -> B) (H : (y : B) -> Fib (Fin k) B f y) (t : has-decidable-equality/is-finite/subtype k B f H) : B =
    f (t.1)

  has-decidable-equality/is-finite/inv-map (k : Nat) (B : U) (f : Fin k -> B) (H : (y : B) -> Fib (Fin k) B f y) (y : B) : has-decidable-equality/is-finite/subtype k B f H =
    let x : Fin k = (H y).1
        p : Path B y (f x) = (H y).2
    in
    ( x,
      ap B (Fin k) (\ b. (H b).1) (f x) y (inv B y (f x) p))

  has-decidable-equality/is-finite/right-htpy (k : Nat) (B : U) (f : Fin k -> B) (H : (y : B) -> Fib (Fin k) B f y) (y : B)
                                                 : Path B (has-decidable-equality/is-finite/map k B f H (has-decidable-equality/is-finite/inv-map k B f H y)) y =
    (inv B y (f (H y).1) (H y).2)

  has-decidable-equality/is-finite/left-htpy (k : Nat) (B : U) (f : Fin k -> B) (H : (y : B) -> Fib (Fin k) B f y) (t : has-decidable-equality/is-finite/subtype k B f H)
                                                : Path (has-decidable-equality/is-finite/subtype k B f H)
                                                       (has-decidable-equality/is-finite/inv-map k B f H (has-decidable-equality/is-finite/map k B f H t)) t =
    SgPath-prop
      ( Fin k)
      ( \ x. Path (Fin k) (H (f x)).1 x)
      ( \ x. count/is-set
            ( Fin k)
            ( count/fin-count k)
            ( H (f x)).1 x)
      ( has-decidable-equality/is-finite/inv-map k B f H (has-decidable-equality/is-finite/map k B f H t)) t
      t.2

  has-decidable-equality/is-finite/Equiv (k : Nat) (B : U) (f : Fin k -> B) (H : (y : B) -> Fib (Fin k) B f y)
                                            : Equiv (has-decidable-equality/is-finite/subtype k B f H) B =
    has-inverse/Equiv
      ( has-decidable-equality/is-finite/subtype k B f H) B
      ( has-decidable-equality/is-finite/map k B f H)
      ( has-decidable-equality/is-finite/inv-map k B f H,
        ( has-decidable-equality/is-finite/right-htpy k B f H,
          has-decidable-equality/is-finite/left-htpy k B f H))
#+end_src


#+RESULTS:
: Typecheck has succeeded.
