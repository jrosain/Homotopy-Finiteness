#+NAME: IsFinite
#+AUTHOR: Johann Rosain

* Finite types

#+begin_src ctt
  module Lib.IsFinite where
#+end_src

Finite types are types that can be counted. However, when defining finite types, we do not especially care about the counting, we only care about the fact that /it can be counted/, which translates in the definition by using [[PropTrunc.org][propositional truncation]]. However, this definition is not practical as it does not give the number of elements. Hence, we also show that finite types are /logically equivalent/ to types with cardinalities.

** Packages imports

#+begin_src ctt
  import Lib.PropTrunc
  import Lib.Counting
  import Lib.Image
  import Lib.Prop.Nat
  import Lib.Prop.Coprod
  import Lib.Prop.Empty  
  import Lib.Prop.Decidability
#+end_src

** Definition
Definition using propositional truncation.
   #+begin_src ctt
  is-finite (X : U) : U =
    Prop-trunc
      ( count X)
   #+end_src
Some shortcuts.
#+begin_src ctt
  is-finite/is-prop (X : U) : is-prop (is-finite X) =
    Prop-trunc/is-prop
      ( count X)

  is-finite/Prop (X : U) : UU-Prop =
    ( is-finite X,
      is-finite/is-prop X)
#+end_src

** Properties

*** A type that has a count is finite
#+begin_src ctt
  count/is-finite (X : U) (c : count X) : is-finite X =
    Prop-trunc/unit c
#+end_src
*** Unit is finite
    #+begin_src ctt
  Unit/is-finite : is-finite Unit =
    count/is-finite Unit
      ( count/Unit)
    #+end_src
*** Fin is finite
#+begin_src ctt
  Fin/is-finite (k : Nat) : is-finite (Fin k) =
    count/is-finite
      ( Fin k)
      ( count/fin-count k)
#+end_src
*** Closure under equivalence
Of course, if =Equiv X Y= and one of them is finite, the other one is also finite.
#+begin_src ctt
  is-finite/closed-Equiv (A B : U) (e : Equiv A B) (is-finite-B : is-finite B) : is-finite A =
    Prop-trunc/map
      ( count B)
      ( count A)
      ( count/closed-equiv A B e) is-finite-B    

  is-finite/closed-Equiv' (A B : U) (e : Equiv A B) (is-finite-A : is-finite A) : is-finite B =
    is-finite/closed-Equiv B A (Equiv/sym A B e) is-finite-A
#+end_src

** Cardinality
We define the notion of having a cardinality and its equivalence to the notion of =is-finite=.
#+begin_src ctt
  has-cardinality (X : U) : U =
    Sg Nat
      ( \ k. mere-equiv (Fin k) X)
#+end_src
Of course, =has-cardinality= is a proposition.
#+begin_src ctt
  has-cardinality/is-prop/sg (X : U) (k : Nat) (h : mere-equiv (Fin k) X) (k' : Nat) (h' : mere-equiv (Fin k') X)
                                : Path (has-cardinality X) (k, h) (k', h') =
    SgPath-prop Nat
      ( \ n. mere-equiv (Fin n) X)
      ( \ n. mere-equiv/is-prop (Fin n) X)
      ( k, h)
      ( k', h')
      ( rec-Prop-trunc
        ( Equiv (Fin k) X)
        ( Nat/eq/Prop k k')
        ( \ e. rec-Prop-trunc
                ( Equiv (Fin k') X)
                ( Nat/eq/Prop k k')
                ( \ e'. Fin/is-inj k k'
                         ( Equiv/trans
                            ( Fin k) X
                            ( Fin k') e
                            ( Equiv/sym (Fin k') X e'))) h') h)

  has-cardinality/is-prop (X : U) : is-prop (has-cardinality X) =
    \ h h'. has-cardinality/is-prop/sg X h.1 h.2 h'.1 h'.2

  has-cardinality/Prop (X : U) : UU-Prop =
    ( has-cardinality X,
      has-cardinality/is-prop X)
#+end_src
Thus, there is an equivalence between having a cardinality and being finite.
#+begin_src ctt
  is-finite/has-cardinality (X : U) : is-finite X -> has-cardinality X =
    rec-Prop-trunc
      ( count X)
      ( has-cardinality/Prop X)
      ( \ c. ( number-of-elements X c,
              Prop-trunc/unit (count/Equiv X c)))

  has-cardinality/is-finite' (X : U) (k : Nat) (e : mere-equiv (Fin k) X) : is-finite X =
    rec-Prop-trunc
      ( Equiv (Fin k) X)
      ( is-finite/Prop X)
      ( \ e'. Prop-trunc/unit (k, e')) e    

  has-cardinality/is-finite (X : U) : has-cardinality X -> is-finite X =
    \ t. has-cardinality/is-finite' X t.1 t.2
#+end_src
Some shortcuts.
#+begin_src ctt
  has-cardinality/card (X : U) (h : has-cardinality X) : Nat = h.1

  has-cardinality/Equiv (X : U) (h : has-cardinality X) : mere-equiv (Fin (has-cardinality/card X h)) X = h.2

  card (X : U) (i : is-finite X) : Nat =
    has-cardinality/card X
      ( is-finite/has-cardinality X i)
#+end_src

** Some immediate consequences
=X= and =Y= are finite iff their coproduct is finite.
   #+begin_src ctt
  is-finite/closed-Coprod (A B : U) (is-finite-A : is-finite A) (is-finite-B : is-finite B) : is-finite (Coprod A B) =
    rec-Prop-trunc
      ( count A)
      ( is-finite/Prop (Coprod A B))
      ( \ c. rec-Prop-trunc
              ( count B)
              ( is-finite/Prop (Coprod A B))
              ( \ c'. Prop-trunc/unit (count/closed-Coprod A B c c'))
              is-finite-B)
      is-finite-A

  is-finite/closed-Coprod-left (A B : U) (is-finite-copr : is-finite (Coprod A B)) : is-finite A =
    rec-Prop-trunc
      ( count (Coprod A B))
      ( is-finite/Prop A)
      ( \ c. Prop-trunc/unit (count/closed-Coprod-left A B c))
      is-finite-copr

  is-finite/closed-Coprod-right (A B : U) (is-finite-copr : is-finite (Coprod A B)) : is-finite B =
    rec-Prop-trunc
      ( count (Coprod A B))
      ( is-finite/Prop B)
      ( \ c. Prop-trunc/unit (count/closed-Coprod-right A B c))
      is-finite-copr
   #+end_src
If =X= and =Y= are finite, then =X * Y= is also finite.
#+begin_src ctt
  is-finite/closed-Prod (A B : U) (is-finite-A : is-finite A) (is-finite-B : is-finite B) : is-finite (A * B) =
    rec-Prop-trunc
      ( count A)
      ( is-finite/Prop (A * B))
      ( \ c. rec-Prop-trunc
              ( count B)
              ( is-finite/Prop (A * B))
              ( \ c'. Prop-trunc/unit (count/closed-Prod A B c c'))
              is-finite-B)
      is-finite-A
#+end_src

** Cardinal of Bool * Bool
   #+begin_src ctt
  Bool : U = Coprod Unit Unit

  true : Bool = inl star
  false : Bool = inr star

  Bool/is-finite : is-finite Bool =
    is-finite/closed-Coprod
      Unit
      Unit
      Unit/is-finite
      Unit/is-finite

  BoolBool/card : Nat =
    card
      ( Bool * Bool)
      ( is-finite/closed-Prod Bool Bool Bool/is-finite Bool/is-finite)
   #+end_src

** Closure under \Pi-types
In this section, we show that if =B= is a family of finite types over a finite type =A=, then the product \Pi_{x: A}B(x) is also finite.
*** Finite family over =Fin k=
First, we start by showing that if =B= is a finite family over =Fin k=, then \Pi_{x: Fin k}B(x) is also finite. This proof is by induction on =k=. 
The case =k = 0= is trivial: a family over the empty type is contractible thus it has a count and it is finite. 
The case =k > 0= is done using the dependent universal property of coproduct. By induction hypothesis, \Pi_{x: Fin k}B(x) is finite and by hypothesis, B(inr star) is also finite. Finally, a product of finite things is finite.
#+begin_src ctt
  is-finite/pi' : (k : Nat) -> (B : Fin k -> U) -> ((x : Fin k) -> is-finite (B x)) -> is-finite ((x : Fin k) -> B x) = split
    zero ->
      \ B _.
        count/is-finite
          ( (x : Fin zero) -> B x)
          ( count/contr-count
            ( (x : Fin zero) -> B x)
            ( Empty/universal-dependent-property
              ( Fin zero) B
              ( Equiv/refl (Fin zero))))
    suc k ->
      \ B is-fin-B.
        is-finite/closed-Equiv
          ( (x : Fin (suc k)) -> B x)
          ( ((x : Fin k) -> B (inl x)) * (B (inr star)))
          ( Equiv/trans
            ( (x : Fin (suc k)) -> B x)
            ( ((x : Fin k) -> B (inl x)) * ((u : Unit) -> B (inr u)))
            ( ((x : Fin k) -> B (inl x)) * (B (inr star)))
            ( Coprod/dependent-universal-property
              ( Fin k) Unit B)
            ( Equiv/prod'
              ( (x : Fin k) -> B (inl x))
              ( (u : Unit) -> B (inr u))
              ( B (inr star))
              ( Equiv/pi-Unit
                ( \ u. B (inr u)))))
          ( is-finite/closed-Prod
            ( (x : Fin k) -> B (inl x))
            ( B (inr star))
            ( is-finite/pi' k
              ( \ x. B (inl x))
              ( \ x. is-fin-B (inl x)))
            ( is-fin-B (inr star)))
#+end_src

*** Finite family over finite type
Let =A= be a finite type. As =is-finite= is a proposition, by the induction principle of the propositional truncation, we assume that we have a count of =A=; that is, an equivalence from Fin k to A for some k. Then, as =is-finite= is closed under equivalence, for any finite family =B= over a finite type =A=, \Pi_{x: A}B(x) is also finite.
#+begin_src ctt
  is-finite/Pi (A : U) (B : A -> U) (is-finite-A : is-finite A) (is-finite-B : (x : A) -> is-finite (B x))
                  : is-finite ((x : A) -> B x) =
    rec-Prop-trunc
      ( count A)
      ( is-finite/Prop ((x : A) -> B x))
      ( \ c.
        is-finite/closed-Equiv
          ( (x : A) -> B x)
          ( (x : Fin (number-of-elements A c)) -> B (Equiv/map (Fin (number-of-elements A c)) A (count/Equiv A c) x))
          ( Equiv/dependent
            ( Fin (number-of-elements A c)) A B
            ( count/Equiv A c))
          ( is-finite/pi'
            ( number-of-elements A c)
            ( \ x. B (Equiv/map (Fin (number-of-elements A c)) A (count/Equiv A c) x))
            ( \ x. is-finite-B (Equiv/map (Fin (number-of-elements A c)) A (count/Equiv A c) x)))) is-finite-A
#+end_src

** A finite type is a set
   #+begin_src ctt
  is-finite/is-set (A : U) : is-finite A -> is-set A =
    rec-Prop-trunc
      ( count A)
      ( is-set/Prop A)
      ( \ c. count/is-set A c)
   #+end_src
** A finite type has decidable equality
If a type is finite, then it is a set. In particular, =has-decidable-equality= is a proposition on this type, so it follows by the recursion principle of propositional truncation that a finite type has decidable equality.
   #+begin_src ctt
  is-finite/has-decidable-equality (A : U) (is-finite-A : is-finite A) : has-decidable-equality A =
    rec-Prop-trunc
      ( count A)
      ( has-decidable-equality/Prop A
        ( is-finite/is-set A is-finite-A))
      ( count/has-decidable-eq A) is-finite-A
   #+end_src

** Finite choice
There is a finite choice map (\Pi_{x: A}||B x||) \to ||\Pi_{x: A}B(x)|| for any finite type A and family over this finite type B.
#+begin_src ctt
  Fin/choice : (k : Nat) (B : Fin k -> U) (H : (x : Fin k) -> Prop-trunc (B x)) -> Prop-trunc ((x : Fin k) -> B x) = split
    zero -> \ B _.
      Prop-trunc/unit
        ( center ((x : Fin zero) -> B x)
          ( Empty/universal-dependent-property
            ( Fin zero) B
            ( Equiv/refl (Fin zero))))
    suc k -> \ B.
      Equiv/map
        ( (x : Fin (suc k)) -> Prop-trunc (B x))
        ( Prop-trunc ((x : Fin (suc k)) -> B x))
        ( Equiv/comp five-Nat
          ( (x : Fin (suc k)) -> Prop-trunc (B x))
          ( ((x : Fin k) -> Prop-trunc (B (inl x))) * ((x : Unit) -> Prop-trunc (B (inr x))))
          ( Coprod/dependent-universal-property
            ( Fin k) Unit (\ x. Prop-trunc (B x)))
          ( ((x : Fin k) -> Prop-trunc (B (inl x))) * (Prop-trunc (B (inr star))))
          ( Equiv/prod'
            ( (x : Fin k) -> Prop-trunc (B (inl x)))
            ( (x : Unit) -> Prop-trunc (B (inr x)))
            ( Prop-trunc (B (inr star)))
            ( Equiv/pi-Unit
              ( \ x. Prop-trunc (B (inr x)))))
          ( (Prop-trunc ((x : Fin k) -> B (inl x))) * (Prop-trunc (B (inr star))))
          ( Equiv/prod
            ( (x : Fin k) -> Prop-trunc (B (inl x)))
            ( Prop-trunc ((x : Fin k) -> B (inl x)))
            ( Prop-trunc (B (inr star)))
            ( Prop/Equiv
              ( Prop/Pi (Fin k) (\ x. Prop-trunc/Prop (B (inl x))))
              ( Prop-trunc/Prop ((x : Fin k) -> B (inl x)))
              ( Fin/choice k (\ x. B (inl x)))
              ( Prop-trunc/Pi/map-out
                ( Fin k)
                ( \ x. B (inl x)))))
          ( Prop-trunc (((x : Fin k) -> B (inl x)) * (B (inr star))))
          ( Prop-trunc/closed-Prod
            ( (x : Fin k) -> B (inl x))
            ( B (inr star)))
          ( Prop-trunc (((x : Fin k) -> B (inl x)) * ((x : Unit) -> B (inr x))))
          ( Equiv/Prop-trunc
            (((x : Fin k) -> B (inl x)) * (B (inr star)))
            (((x : Fin k) -> B (inl x)) * ((x : Unit) -> B (inr x)))
            ( Equiv/prod'
              ( (x : Fin k) -> B (inl x))
              ( B (inr star))
              ( (x : Unit) -> B (inr x))
              ( Equiv/sym
                ( (x : Unit) -> B (inr x))
                ( B (inr star))
                ( Equiv/pi-Unit (\ x. B (inr x))))))
          ( Prop-trunc ((x : Fin (suc k)) -> B x))
          ( Equiv/Prop-trunc
            ( ((x : Fin k) -> B (inl x)) * ((x : Unit) -> B (inr x)))
            ( (x : Fin (suc k)) -> B x)
            ( Equiv/sym
              ( (x : Fin (suc k)) -> B x)
              ( ((x : Fin k) -> B (inl x)) * ((x : Unit) -> B (inr x)))
              ( Coprod/dependent-universal-property
                ( Fin k) Unit B))))

  is-finite/choice (A : U) (B : A -> U) (is-finite-A : is-finite A) (H : (x : A) -> Prop-trunc (B x)) : Prop-trunc ((x : A) -> B x) =
    rec-Prop-trunc
      ( count A)
      ( Prop-trunc/Prop
        ( (x : A) -> B x))
      ( \ c. 
          let k : Nat = number-of-elements A c
              f : Fin k -> A = Equiv/map (Fin k) A (count/Equiv A c)
              g : A -> Fin k = Equiv/inv-map (Fin k) A (count/Equiv A c)
           in
          rec-Prop-trunc
            ( (x : (Fin k)) -> B (f x))
            ( Prop-trunc/Prop ((x : A) -> B x))
            ( \ h. Prop-trunc/unit
                  ( \ x. tr A (f (g x)) x (Equiv/inv-right-htpy (Fin k) A (count/Equiv A c) x) B (h (g x))))
            ( Fin/choice k
              ( \ x. B (f x))
              ( \ x. H (f x)))) is-finite-A
#+end_src

** Closure under \Sigma-types
Given a finite type =A= and a family of finite types =B= over =A=, \Sigma A B is also finite.
#+begin_src ctt
  is-finite/closed-Sg (A : U) (B : A -> U) (is-finite-A : is-finite A) (H : (x : A) -> is-finite (B x)) : is-finite (Sg A B) =
    rec-Prop-trunc
      ( count A)
      ( is-finite/Prop
          ( Sg A B))
      ( \ c. rec-Prop-trunc
              ( (x : A) -> count (B x))
              ( is-finite/Prop
                ( Sg A B))
              ( \ H'. Prop-trunc/unit (count/closed-Sg A B c H'))
              ( is-finite/choice A (\ x. count (B x)) is-finite-A H)) is-finite-A
#+end_src

** Surjective map codomain is finite iff it has decidable equality
We show that if f : A \to B is a surjective map and A is finite, then B is finite iff it has decidable equality. In fact, the forward direction is immediate from =is-finite/has-decidable-equality=. We show the converse by induction on the number of elements. First, we set =A= to be =Fin k= and we show that =B= has a count. The base case is trivial, \emptyset \simeq B.
#+begin_src ctt
  has-decidable-equality/is-finite/base/map (B : U) (f : Empty -> B) (H : is-surj Empty B f) : B -> Empty =
    \ b. rec-Prop-trunc
        ( Fib Empty B f b)
        ( Empty/Prop)
        ( \ t. t.1)
        ( H b)

  has-decidable-equality/is-finite/base/right-htpy (B : U) (f : Empty -> B) (H : is-surj Empty B f) (x : Empty)
                                                      : Path Empty (has-decidable-equality/is-finite/base/map B f H (f x)) x =
    ex-falso
      ( Path Empty (has-decidable-equality/is-finite/base/map B f H (f x)) x) x    

  has-decidable-equality/is-finite/base/left-htpy (B : U) (f : Empty -> B) (H : is-surj Empty B f) (b : B)
                                                     : Path B (f (has-decidable-equality/is-finite/base/map B f H b)) b =
    ex-falso
      ( Path B (f (has-decidable-equality/is-finite/base/map B f H b)) b)
      ( rec-Prop-trunc
          ( Fib Empty B f b)
          ( Empty/Prop)
          ( \ t. t.1)
          ( H b))

  has-decidable-equality/is-finite/base (B : U) (f : Empty -> B) (H : is-surj Empty B f) : count B =
    ( zero,
      has-inverse/Equiv Empty B f
        ( has-decidable-equality/is-finite/base/map B f H,
          ( has-decidable-equality/is-finite/base/left-htpy B f H,
            has-decidable-equality/is-finite/base/right-htpy B f H)))
#+end_src
The inductive case is more involved. First, as B's equality is decidable, we can decide for any y : B whether there exists an x : Fin k such that y = f(x) or if no x : Fin k are such that y = f(x).
#+begin_src ctt
  has-decidable-equality/is-finite/decide/s'' (B : U) (y : B) (k : Nat) (f : Fin (suc k) -> B) (p : neg (Path B y (f (inr star))))
                                              (h : (x : Fin k) -> neg (Path B y (f (inl x))))
                                                 : (x : Fin (suc k)) -> neg (Path B y (f x)) = split
    inl x -> h x
    inr s -> ind-Unit
              ( \ x. neg (Path B y (f (inr x)))) p s

  has-decidable-equality/is-finite/decide/s' (B : U) (y : B) (k : Nat) (f : Fin (suc k) -> B) (p : neg (Path B y (f (inr star))))
                                                : Coprod (Sg (Fin k) (\ x. Path B y (f (inl x)))) ((x : Fin k) -> neg (Path B y (f (inl x))))
                                                 -> Coprod (Sg (Fin (suc k)) (\ x. Path B y (f x))) ((x : Fin (suc k)) -> neg (Path B y (f x))) = split
    inl t -> inl (inl t.1, t.2)
    inr h -> inr (has-decidable-equality/is-finite/decide/s'' B y k f p h)

  has-decidable-equality/is-finite/decide/s (B : U) (y : B) (k : Nat) (f : Fin (suc k) -> B)
                                            (u : Coprod (Sg (Fin k) (\ x. Path B y (f (inl x)))) ((x : Fin k) -> neg (Path B y (f (inl x)))))
                                               : Coprod (Path B y (f (inr star))) (neg (Path B y (f (inr star))))
                                                -> Coprod (Sg (Fin (suc k)) (\ x. Path B y (f x))) ((x : Fin (suc k)) -> neg (Path B y (f x))) = split
    inl p -> inl (inr star, p)
    inr p -> has-decidable-equality/is-finite/decide/s' B y k f p u

  has-decidable-equality/is-finite/decide (B : U) (y : B) (Heq : has-decidable-equality B) : (k : Nat) -> (f : Fin k -> B)
                                              -> Coprod (Sg (Fin k) (\ x. Path B y (f x))) ((x : Fin k) -> neg (Path B y (f x))) = split
    zero -> \ _. inr (\ x _. x)
    suc k -> \ f. has-decidable-equality/is-finite/decide/s B y k f
                  ( has-decidable-equality/is-finite/decide B y Heq k
                    ( \ x. f (inl x)))
                  ( Heq y (f (inr star)))
#+end_src
Now, there are two cases for the inductive case. If we can find an x : Fin k such that (f (inr star)) = (f (inl x)), then we can directly conclude by induction hypothesis: the function is still surjective while removing the last element.
Otherwise, we need to build a subtype X such that B \simeq X + 1 such that, morally, we put in X all the elements of B that are not f (inr star). Such an X can be built as follows: let H : is-surj (Fin (suc k)) B f, and consider the subtype P(x) defined as: (fst (H (f x))) = x, for x in Fin k. Of course, (fst (H (f (inr star)))) is (inr star), as it is the only preimage of f(inr star). As such, it does not appear in this subtype. Thus, let X :\equiv \Sigma_{x: Fin k} P(x).
#+begin_src ctt
  has-decidable-equality/is-finite/subtype (k : Nat) (B : U) (f : Fin (suc k) -> B) (H : (y : B) -> Fib (Fin (suc k)) B f y) : U =
    Sg (Fin k) (\ x. Path (Fin (suc k)) (H (f (inl x))).1 (inl x))
#+end_src
We need to show that B \simeq X + 1. The forward map is easy: let y : B. If y is f(inr star), it suffices to send to inr(star). Otherwise, it suffices to get the x given by the family of fibrations.
#+begin_src ctt
  has-decidable-equality/is-finite/map'' (k : Nat) (B : U) (f : Fin (suc k) -> B) (y : B) (p : neg (Path B y (f (inr star)))) (H : (b : B) -> Fib (Fin (suc k)) B f b)
                                            : (x : Fin (suc k)) -> Path (Fin (suc k)) (H (f x)).1 x -> Path B y (f x) -> has-decidable-equality/is-finite/subtype k B f H = split
    inl x -> \ q _. (x, q)
    inr s -> \ q. ind-Unit
                  ( \ x. (Path B y (f (inr x))) -> has-decidable-equality/is-finite/subtype k B f H)
                  ( \ r. ex-falso (has-decidable-equality/is-finite/subtype k B f H) (p r)) s

  has-decidable-equality/is-finite/map' (k : Nat) (B : U) (f : Fin (suc k) -> B) (H : (y : B) -> Fib (Fin (suc k)) B f y) (y : B)
                                           : Coprod (Path B y (f (inr star))) (neg (Path B y (f (inr star))))
                                            -> Coprod (has-decidable-equality/is-finite/subtype k B f H) Unit = split
    inl _ -> inr star
    inr p ->
      let x : Fin (suc k) = (H y).1
          q : Path B y (f x) = (H y).2
      in inl ( has-decidable-equality/is-finite/map'' k B f y p H x
               ( ap B (Fin (suc k)) (\ b. (H b).1) (f x) y (inv B y (f x) q)) q)

  has-decidable-equality/is-finite/map (k : Nat) (B : U) (Heq : has-decidable-equality B) (f : Fin (suc k) -> B) (H : (y : B) -> Fib (Fin (suc k)) B f y) (y : B)
                                          : Coprod (has-decidable-equality/is-finite/subtype k B f H) Unit =
    has-decidable-equality/is-finite/map' k B f H y
      ( Heq y (f (inr star)))
#+end_src
The backward map is easier even, it suffices to give f(inl x) or f(inr star) depending on the situation.
#+begin_src ctt
  has-decidable-equality/is-finite/inv-map (k : Nat) (B : U) (f : Fin (suc k) -> B) (H : (y : B) -> Fib (Fin (suc k)) B f y)
                                              : Coprod (has-decidable-equality/is-finite/subtype k B f H) Unit -> B = split
    inl t -> f (inl t.1)
    inr _ -> f (inr star)
#+end_src

*** Useful lemma
A useful intermediate lemma is that applying the map yields =inr star= only if there is a path between y and f(inr star).
#+begin_src ctt
  has-decidable-equality/is-finite/Path' (k : Nat) (B : U) (f : Fin (suc k) -> B) (H : (y : B) -> Fib (Fin (suc k)) B f y) (Heq : has-decidable-equality B)
                                         (y : B) (p : Path (Coprod (has-decidable-equality/is-finite/subtype k B f H) Unit)
                                                           (has-decidable-equality/is-finite/map k B Heq f H y) (inr star))
                                           : (u : Coprod (Path B y (f (inr star))) (neg (Path B y (f (inr star)))))
                                             -> Path (Coprod (Path B y (f (inr star))) (neg (Path B y (f (inr star)))))
                                                    u (Heq y (f (inr star)))
                                             -> Path B y (f (inr star)) = split
    inl q -> \ _. q
    inr h -> \ q.
      let x : Fin (suc k) = (H y).1
          q' : Path B y (f x) = (H y).2
          r : Path (Fin (suc k)) (H (f x)).1 (H y).1 = ap B (Fin (suc k)) (\ b. (H b).1) (f x) y (inv B y (f x) q')
      in
      ex-falso
        ( Path B y (f (inr star)))
        ( Coprod/Eq/eq-map
          ( has-decidable-equality/is-finite/subtype k B f H) Unit
          ( inl (has-decidable-equality/is-finite/map'' k B f y h H x r q'))
          ( inr star)
          ( comp
            ( Coprod (has-decidable-equality/is-finite/subtype k B f H) Unit) 
            ( inl (has-decidable-equality/is-finite/map'' k B f y h H x r q'))
            ( has-decidable-equality/is-finite/map' k B f H y (Heq y (f (inr star))))
            ( ap ( Coprod (Path B y (f (inr star))) (neg (Path B y (f (inr star)))))
                 ( Coprod (has-decidable-equality/is-finite/subtype k B f H) Unit)
                 ( has-decidable-equality/is-finite/map' k B f H y)
                 ( inr h)
                 ( Heq y (f (inr star))) q)
            ( inr star) p))

  has-decidable-equality/is-finite/Path (k : Nat) (B : U) (f : Fin (suc k) -> B) (H : (y : B) -> Fib (Fin (suc k)) B f y) (Heq : has-decidable-equality B)
                                        (y : B) (p : Path (Coprod (has-decidable-equality/is-finite/subtype k B f H) Unit)
                                                          (has-decidable-equality/is-finite/map k B Heq f H y) (inr star))
                                           : Path B y (f (inr star)) =
    has-decidable-equality/is-finite/Path' k B f H Heq y p
      ( Heq y (f (inr star)))
      ( refl
        ( Coprod (Path B y (f (inr star))) (neg (Path B y (f (inr star)))))
        ( Heq y (f (inr star))))
#+end_src
Now, we show that B \simeq X + 1 under the hypothesis that for any x : Fin k, we have that f(x) \neq f(inr star).

*** Right homotopy
First, consider the case where the result of the function is =inl ...=. 
#+begin_src ctt
  has-decidable-equality/is-finite/right-htpy/inl' (k : Nat) (B : U) (f : Fin (suc k) -> B) (H : (y : B) -> Fib (Fin (suc k)) B f y) (HB : has-decidable-equality B)
                                                   (t : has-decidable-equality/is-finite/subtype k B f H) (p : neg (Path B (f (inl t.1)) (f (inr star))))
                                                      : (x : Fin (suc k)) -> (r : Path (Fin (suc k)) (H (f x)).1 x) -> (q : Path B (f (inl t.1)) (f x))
                                                       -> Path (has-decidable-equality/is-finite/subtype k B f H)
                                                              (has-decidable-equality/is-finite/map'' k B f (f (inl t.1)) p H x r q) t = split
    inl x -> \ r q.
      SgPath-prop
        ( Fin k)
        ( \ x'. Path (Fin (suc k)) (H (f (inl x'))).1 (inl x'))
        ( \ x'. count/is-set
                ( Fin (suc k))
                ( count/fin-count (suc k))
                ( H (f (inl x'))).1
                ( inl x'))
        ( x, r) t
        ( Coprod/inl-inj
            ( Fin k) Unit x t.1
            ( comp-n
                ( Fin (suc k)) three-Nat
                ( inl x)
                ( H (f (inl x))).1
                ( inv (Fin (suc k)) (H (f (inl x))).1 (inl x) r)
                ( H (f (inl t.1))).1
                ( ap B (Fin (suc k)) (\ b. (H b).1) (f (inl x)) (f (inl t.1))
                  ( inv B (f (inl t.1)) (f (inl x)) q))
                (inl t.1) t.2))
    inr s -> \ r q.
      ex-falso
        ( Path
          ( has-decidable-equality/is-finite/subtype k B f H)
          ( has-decidable-equality/is-finite/map'' k B f (f (inl t.1)) p H (inr s) r q) t)
        ( ind-Unit (\ x. Path B (f (inl t.1)) (f (inr x)) -> Empty)
                   (\ p'. p p') s q)
#+end_src
Then:
#+begin_src ctt
  has-decidable-equality/is-finite/right-htpy/inl/dec (k : Nat) (B : U) (f : Fin (suc k) -> B) (H : (y : B) -> Fib (Fin (suc k)) B f y) (HB : has-decidable-equality B)
                                                      (t : has-decidable-equality/is-finite/subtype k B f H) (u : (has-decidable-equality/is-finite/subtype k B f H))
                                                      (p : Path (Coprod (has-decidable-equality/is-finite/subtype k B f H) Unit) (has-decidable-equality/is-finite/map k B HB f H (f (inl t.1))) (inl u))
                                                         : (v : Coprod (Path B (f (inl t.1)) (f (inr star))) (neg (Path B (f (inl t.1)) (f (inr star)))))
                                                          -> Path (Coprod (Path B (f (inl t.1)) (f (inr star))) (neg (Path B (f (inl t.1)) (f (inr star))))) 
                                                                 (HB (f (inl t.1)) (f (inr star))) v
                                                          -> Path (Coprod (has-decidable-equality/is-finite/subtype k B f H) Unit) (inl u) (inl t) = split
    inl p' -> \ q.
      ex-falso
      ( Path (Coprod (has-decidable-equality/is-finite/subtype k B f H) Unit) (inl u) (inl t))
      ( Coprod/Eq/eq-map
        ( has-decidable-equality/is-finite/subtype k B f H) Unit
        ( inl u)
        ( inr star)
        ( comp
          ( Coprod (has-decidable-equality/is-finite/subtype k B f H) Unit) 
          ( inl u)
          ( has-decidable-equality/is-finite/map k B HB f H (f (inl t.1)))
          ( inv
            ( Coprod (has-decidable-equality/is-finite/subtype k B f H) Unit)
            ( has-decidable-equality/is-finite/map k B HB f H (f (inl t.1)))
            ( inl u) p)
          ( has-decidable-equality/is-finite/map' k B f H (f (inl t.1)) (inl p'))
          ( ap ( Coprod (Path B (f (inl t.1)) (f (inr star))) (neg (Path B (f (inl t.1)) (f (inr star)))))
               ( Coprod (has-decidable-equality/is-finite/subtype k B f H) Unit)
               ( has-decidable-equality/is-finite/map' k B f H (f (inl t.1)))
               ( HB (f (inl t.1)) (f (inr star)))
               ( inl p') q)))
    inr p' -> \ q'.
      let x : Fin (suc k) = (H (f (inl t.1))).1
          q : Path B (f (inl t.1)) (f x) = (H (f (inl t.1))).2
          r : Path (Fin (suc k)) (H (f x)).1 x = ap B (Fin (suc k)) (\ b. (H b).1) (f x) (f (inl t.1)) (inv B (f (inl t.1)) (f x) q)
      in
      Coprod/Eq/map
        ( has-decidable-equality/is-finite/subtype k B f H) Unit
        ( inl u)
        ( inl t) 
        ( comp
          ( has-decidable-equality/is-finite/subtype k B f H) u
          ( has-decidable-equality/is-finite/map'' k B f (f (inl t.1)) p' H x r q)
          ( Coprod/inl-inj (has-decidable-equality/is-finite/subtype k B f H) Unit u
            ( has-decidable-equality/is-finite/map'' k B f (f (inl t.1)) p' H x r q)
            ( comp (Coprod (has-decidable-equality/is-finite/subtype k B f H) Unit) (inl u)
              ( has-decidable-equality/is-finite/map k B HB f H (f (inl t.1)))
              ( inv (Coprod (has-decidable-equality/is-finite/subtype k B f H) Unit) (has-decidable-equality/is-finite/map k B HB f H (f (inl t.1))) (inl u) p)
              ( inl ( has-decidable-equality/is-finite/map'' k B f (f (inl t.1)) p' H x r q))
              ( ap ( Coprod (Path B (f (inl t.1)) (f (inr star))) (neg (Path B (f (inl t.1)) (f (inr star)))))
                   ( Coprod (has-decidable-equality/is-finite/subtype k B f H) Unit)
                   ( has-decidable-equality/is-finite/map' k B f H (f (inl t.1)))
                   ( HB (f (inl t.1)) (f (inr star))) (inr p') q'))) t
          ( has-decidable-equality/is-finite/right-htpy/inl' k B f H HB t p' x r q))

  has-decidable-equality/is-finite/right-htpy/inl (k : Nat) (B : U) (f : Fin (suc k) -> B) (H : (y : B) -> Fib (Fin (suc k)) B f y) (HB : has-decidable-equality B)
                                                  (t : has-decidable-equality/is-finite/subtype k B f H) (Heq : (x : Fin k) -> neg (Path B (f (inr star)) (f (inl x))))
                                                     : (u : Coprod (has-decidable-equality/is-finite/subtype k B f H) Unit)
                                                      -> Path (Coprod (has-decidable-equality/is-finite/subtype k B f H) Unit)
                                                             (has-decidable-equality/is-finite/map k B HB f H (f (inl t.1))) u
                                                      -> Path (Coprod (has-decidable-equality/is-finite/subtype k B f H) Unit) u (inl t) = split
    inr s -> \ p'.
      ind-Unit
        ( \ x. Path (Coprod (has-decidable-equality/is-finite/subtype k B f H) Unit) (has-decidable-equality/is-finite/map k B HB f H (f (inl t.1))) (inr x)
                     -> Path (Coprod (has-decidable-equality/is-finite/subtype k B f H) Unit) (inr x) (inl t))
        ( \ p. ex-falso
              ( Path
                ( Coprod (has-decidable-equality/is-finite/subtype k B f H) Unit)
                ( inr star)
                ( inl t))
              ( Heq
                ( t.1)
                ( inv B
                  ( f (inl t.1))
                  ( f (inr star))
                  ( has-decidable-equality/is-finite/Path k B f H HB (f (inl t.1)) p)))) s p'
    inl u -> \ p. has-decidable-equality/is-finite/right-htpy/inl/dec k B f H HB t u p
                ( HB (f (inl t.1)) (f (inr star)))
                ( refl (Coprod (Path B (f (inl t.1)) (f (inr star))) (neg (Path B (f (inl t.1)) (f (inr star))))) ( HB (f (inl t.1)) (f (inr star))))
#+end_src
Now, consider the case where the result is =inr ...=.
#+begin_src ctt
  has-decidable-equality/is-finite/right-htpy/inr' (k : Nat) (B : U) (f : Fin (suc k) -> B) (H : (y : B) -> Fib (Fin (suc k)) B f y) (Heq : has-decidable-equality B)
                                                      : (u : Coprod (Path B (f (inr star)) (f (inr star))) (neg (Path B (f (inr star)) (f (inr star)))))
                                                        -> Path (Coprod (Path B (f (inr star)) (f (inr star))) (neg (Path B (f (inr star)) (f (inr star)))))
                                                               (Heq (f (inr star)) (f (inr star))) u
                                                        -> Path (Coprod (has-decidable-equality/is-finite/subtype k B f H) Unit)
                                                               (has-decidable-equality/is-finite/map k B Heq f H (f (inr star)))
                                                               (inr star) = split
    inl p -> \ q.
      ( ap ( Coprod (Path B (f (inr star)) (f (inr star))) (neg (Path B (f (inr star)) (f (inr star)))))
           ( Coprod (has-decidable-equality/is-finite/subtype k B f H) Unit)
           ( has-decidable-equality/is-finite/map' k B f H (f (inr star)))
           ( Heq (f (inr star)) (f (inr star)))
           ( inl p) q)
    inr np -> \ _.
      ex-falso
        ( Path
          ( Coprod (has-decidable-equality/is-finite/subtype k B f H) Unit)
          ( has-decidable-equality/is-finite/map k B Heq f H (f (inr star)))
          ( inr star))
        ( np (refl B (f (inr star))))

  has-decidable-equality/is-finite/right-htpy/inr (k : Nat) (B : U) (f : Fin (suc k) -> B) (H : (y : B) -> Fib (Fin (suc k)) B f y) (Heq : has-decidable-equality B)
                                                     : (s : Unit) -> Path (Coprod (has-decidable-equality/is-finite/subtype k B f H) Unit)
                                                                         (has-decidable-equality/is-finite/map k B Heq f H (f (inr star)))
                                                                         (inr s) = split
    star -> 
      has-decidable-equality/is-finite/right-htpy/inr' k B f H Heq
        ( Heq (f (inr star)) (f (inr star)))
        ( refl (Coprod (Path B (f (inr star)) (f (inr star))) (neg (Path B (f (inr star)) (f (inr star))))) (Heq (f (inr star)) (f (inr star))))

#+end_src
These two results show that we have a right homotopy.
#+begin_src ctt
  has-decidable-equality/is-finite/right-htpy (k : Nat) (B : U) (f : Fin (suc k) -> B) (H : (y : B) -> Fib (Fin (suc k)) B f y) (HB : has-decidable-equality B)
                                              (Heq : (x : Fin k) -> neg (Path B (f (inr star)) (f (inl x))))
                                                 : (u : Coprod (has-decidable-equality/is-finite/subtype k B f H) Unit)
                                                  -> Path (Coprod (has-decidable-equality/is-finite/subtype k B f H) Unit)
                                                         (has-decidable-equality/is-finite/map k B HB f H (has-decidable-equality/is-finite/inv-map k B f H u)) u = split
    inl t -> has-decidable-equality/is-finite/right-htpy/inl k B f H HB t Heq
              ( has-decidable-equality/is-finite/map k B HB f H (f (inl t.1)))
              ( refl (Coprod (has-decidable-equality/is-finite/subtype k B f H) Unit) (has-decidable-equality/is-finite/map k B HB f H (f (inl t.1))))
    inr s -> has-decidable-equality/is-finite/right-htpy/inr k B f H HB s
#+end_src

*** Left homotopy
Consider now a =y : B=. This side is more natural, as we can straightforwardly follow the definition of the map. First, we show two little lemmas:
    - if ...
    #+begin_src ctt
  has-decidable-equality/is-finite/left-htpy-map (k : Nat) (B : U) (HB : has-decidable-equality B) (f : Fin (suc k) -> B) (H : (y : B) -> Fib (Fin (suc k)) B f y) (y : B)
                                                 (np : neg (Path B y (f (inr star)))) (p : Path (Coprod (Path B y (f (inr star))) (neg (Path B y (f (inr star))))) (HB y (f (inr star))) (inr np))
                                                     : (x : Fin (suc k)) -> (q : Path B y (f x)) -> Path (Fib (Fin (suc k)) B f y) (H y) (x, q)
                                                      -> Path B (has-decidable-equality/is-finite/inv-map k B f H
                                                                 (inl (has-decidable-equality/is-finite/map'' k B f y np H (H y).1
                                                                  (ap B (Fin (suc k)) (\ b. (H b).1) (f (H y).1) y (inv B y (f (H y).1) (H y).2)) (H y).2))) y = split
    inl x -> \ q r.
      comp B
        ( has-decidable-equality/is-finite/inv-map k B f H
          ( inl (has-decidable-equality/is-finite/map'' k B f y np H (H y).1
            ? (H y).2))) -- todo: provide this path and the one below, and the path between the paths
        ( has-decidable-equality/is-finite/inv-map k B f H
          ( inl (has-decidable-equality/is-finite/map'' k B f y np H (inl x)
            ? q)))
        ( ap (Fib (Fin (suc k)) B f y) B
          ( \ t. ( has-decidable-equality/is-finite/inv-map k B f H
                  ( inl (has-decidable-equality/is-finite/map'' k B f y np H t.1
                    ( ap B (Fin (suc k)) (\ b. (H b).1) (f t.1) y (inv B y (f t.1) t.2)) t.2))))
          ( H y)
          ( inl x, q) r)
        y ( inv B y (f x) q)

    inr s -> \ _ _. ?
  --      ( inl ( has-decidable-equality/is-finite/map'' k B f y p H x
  --               ( ap B (Fin (suc k)) (\ b. (H b).1) (f x) y (inv B y (f x) q)) q)
#+end_src
    - 
#+begin_src ctt
  -- has-decidable-equality/is-finite/left-htpy' (k : Nat) (B : U) (HB : has-decidable-equality B) (f : Fin (suc k) -> B) (H : (y : B) -> Fib (Fin (suc k)) B f y) (y : B)
  --                                                : (u : Coprod (Path B y (f (inr star))) (neg (Path B y (f (inr star)))))
  --                                                 -> Path (Coprod (Path B y (f (inr star))) (neg (Path B y (f (inr star)))))
  --                                                        (HB y (f (inr star))) u
  --                                                 -> Path B (has-decidable-equality/is-finite/inv-map k B f H (has-decidable-equality/is-finite/map k B HB f H y)) y = split
  --   inl p -> \ p'.
  --     comp B
  --       ( has-decidable-equality/is-finite/inv-map k B f H (has-decidable-equality/is-finite/map k B HB f H y))
  --       ( has-decidable-equality/is-finite/inv-map k B f H (inr star))
  --       ( ap
  --         ( Coprod (Path B y (f (inr star))) (neg (Path B y (f (inr star))))) B
  --         ( \ q. has-decidable-equality/is-finite/inv-map k B f H (has-decidable-equality/is-finite/map' k B f H y q))
  --         ( HB y (f (inr star)))
  --         ( inl p) p')
  --       y ( inv B y (f (inr star)) p)
  --   inr np -> \ p.
  --     let x : Fin (suc k) = (H y).1
  --         q : Path B y (f x) = (H y).2
  --     in 
  --     comp B
  --       ( has-decidable-equality/is-finite/inv-map k B f H (has-decidable-equality/is-finite/map k B HB f H y))
  --       ( has-decidable-equality/is-finite/inv-map k B f H (x, q)) ? -- it is easy to show that it is inv-map (inl ( map'' ...)) but inside we have to show that it's only inl x.
  --       y ? -- easy: it depends on the result of inv-map but it must be f (inl t.1) by np (otherwise, we have a path between y and f (inr star)) thus inv q suffices

  -- Probably useful for the thing above.
      -- comp
      --   ( Coprod (has-decidable-equality/is-finite/subtype k B f H) Unit)
      --   ( has-decidable-equality/is-finite/map k B HB f H y)
      --   ( has-decidable-equality/is-finite/map' k B f H y (inr np))
      --   ( ap (Coprod (Path B y (f (inr star))) (neg (Path B y (f (inr star))))) (Coprod (has-decidable-equality/is-finite/subtype k B f H) Unit)
      --        (has-decidable-equality/is-finite/map' k B f H y) (HB y (f (inr star))) (inr np) p)
      --   ( x, q)
      --   ( ap (Fib (Fin (suc k)) B f y) (Coprod (has-decidable-equality/is-finite/subtype k B f H) Unit)
      --        (\ t. let x' : Fin (suc k) = t.1 in let q' : Path B y (f x') = t.2
      --             in inl ( has-decidable-equality/is-finite/map'' k B f y p H x'
      --                      ( ap B (Fin (suc k)) (\ b. (H b).1) (f x') y (inv B y (f x') q')) q'))
      --        (H y) (x, q) r)
#+end_src

*** Equivalence
#+RESULTS:
: Typecheck has succeeded.

Draft:
#+begin_src ctt
  -- has-decidable-equality/is-finite/left-htpy (k : Nat) (B : U) (f : Fin k -> B) (H : (y : B) -> Fib (Fin k) B f y) (y : B)
  --                                                : Path B (has-decidable-equality/is-finite/map k B f H (has-decidable-equality/is-finite/inv-map k B f H y)) y =
  --   (inv B y (f (H y).1) (H y).2)


  -- has-decidable-equality/is-finite/Equiv (k : Nat) (B : U) (f : Fin k -> B) (H : (y : B) -> Fib (Fin k) B f y)
  --                                           : Equiv (has-decidable-equality/is-finite/subtype k B f H) B =
  --   has-inverse/Equiv
  --     ( has-decidable-equality/is-finite/subtype k B f H) B
  --     ( has-decidable-equality/is-finite/map k B f H)
  --     ( has-decidable-equality/is-finite/inv-map k B f H,
  --       ( has-decidable-equality/is-finite/right-htpy k B f H,
  --         has-decidable-equality/is-finite/left-htpy k B f H))
#+end_src


#+RESULTS:
: Typecheck has succeeded.
