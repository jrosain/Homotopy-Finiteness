#+NAME: IsFinite
#+AUTHOR: Johann Rosain

* Finite types

#+begin_src ctt
  module Lib.IsFinite where
#+end_src

Finite types are types that can be counted. However, when defining finite types, we do not especially care about the counting, we only care about the fact that /it can be counted/, which translates in the definition by using [[PropTrunc.org][propositional truncation]]. However, this definition is not practical as it does not give the number of elements. Hence, we also show that finite types are /logically equivalent/ to types with cardinalities.

** Packages imports

#+begin_src ctt
  import Lib.PropTrunc
  import Lib.Counting
  import Lib.Prop.Nat
  import Lib.Prop.Coprod
  import Lib.Prop.Empty  
  import Lib.Prop.Decidability
#+end_src

** Definition
Definition using propositional truncation.
   #+begin_src ctt
  is-finite (X : U) : U =
    Prop-trunc
      ( count X)
   #+end_src
Some shortcuts.
#+begin_src ctt
  is-finite/is-prop (X : U) : is-prop (is-finite X) =
    Prop-trunc/is-prop
      ( count X)

  is-finite/Prop (X : U) : UU-Prop =
    ( is-finite X,
      is-finite/is-prop X)
#+end_src

** Properties

*** A type that has a count is finite
#+begin_src ctt
  count/is-finite (X : U) (c : count X) : is-finite X =
    Prop-trunc/unit c
#+end_src
*** Unit is finite
    #+begin_src ctt
  Unit/is-finite : is-finite Unit =
    count/is-finite Unit
      ( count/Unit)
    #+end_src
*** Fin is finite
#+begin_src ctt
  Fin/is-finite (k : Nat) : is-finite (Fin k) =
    count/is-finite
      ( Fin k)
      ( count/fin-count k)
#+end_src
*** Closure under equivalence
Of course, if =Equiv X Y= and one of them is finite, the other one is also finite.
#+begin_src ctt
  is-finite/closed-Equiv (A B : U) (e : Equiv A B) (is-finite-B : is-finite B) : is-finite A =
    Prop-trunc/map
      ( count B)
      ( count A)
      ( count/closed-equiv A B e) is-finite-B    

  is-finite/closed-Equiv' (A B : U) (e : Equiv A B) (is-finite-A : is-finite A) : is-finite B =
    is-finite/closed-Equiv B A (Equiv/sym A B e) is-finite-A
#+end_src

** Cardinality
We define the notion of having a cardinality and its equivalence to the notion of =is-finite=.
#+begin_src ctt
  has-cardinality (X : U) : U =
    Sg Nat
      ( \ k. mere-equiv (Fin k) X)
#+end_src
Of course, =has-cardinality= is a proposition.
#+begin_src ctt
  has-cardinality/is-prop/sg (X : U) (k : Nat) (h : mere-equiv (Fin k) X) (k' : Nat) (h' : mere-equiv (Fin k') X)
                                : Path (has-cardinality X) (k, h) (k', h') =
    SgPath-prop Nat
      ( \ n. mere-equiv (Fin n) X)
      ( \ n. mere-equiv/is-prop (Fin n) X)
      ( k, h)
      ( k', h')
      ( rec-Prop-trunc
        ( Equiv (Fin k) X)
        ( Nat/eq/Prop k k')
        ( \ e. rec-Prop-trunc
                ( Equiv (Fin k') X)
                ( Nat/eq/Prop k k')
                ( \ e'. Fin/is-inj k k'
                         ( Equiv/trans
                            ( Fin k) X
                            ( Fin k') e
                            ( Equiv/sym (Fin k') X e'))) h') h)

  has-cardinality/is-prop (X : U) : is-prop (has-cardinality X) =
    \ h h'. has-cardinality/is-prop/sg X h.1 h.2 h'.1 h'.2

  has-cardinality/Prop (X : U) : UU-Prop =
    ( has-cardinality X,
      has-cardinality/is-prop X)
#+end_src
Thus, there is an equivalence between having a cardinality and being finite.
#+begin_src ctt
  is-finite/has-cardinality (X : U) : is-finite X -> has-cardinality X =
    rec-Prop-trunc
      ( count X)
      ( has-cardinality/Prop X)
      ( \ c. ( number-of-elements X c,
              Prop-trunc/unit (count/Equiv X c)))

  has-cardinality/is-finite' (X : U) (k : Nat) (e : mere-equiv (Fin k) X) : is-finite X =
    rec-Prop-trunc
      ( Equiv (Fin k) X)
      ( is-finite/Prop X)
      ( \ e'. Prop-trunc/unit (k, e')) e    

  has-cardinality/is-finite (X : U) : has-cardinality X -> is-finite X =
    \ t. has-cardinality/is-finite' X t.1 t.2
#+end_src
Some shortcuts.
#+begin_src ctt
  has-cardinality/card (X : U) (h : has-cardinality X) : Nat = h.1

  has-cardinality/Equiv (X : U) (h : has-cardinality X) : mere-equiv (Fin (has-cardinality/card X h)) X = h.2

  card (X : U) (i : is-finite X) : Nat =
    has-cardinality/card X
      ( is-finite/has-cardinality X i)
#+end_src

** Some immediate consequences
=X= and =Y= are finite iff their coproduct is finite.
   #+begin_src ctt
  is-finite/closed-Coprod (A B : U) (is-finite-A : is-finite A) (is-finite-B : is-finite B) : is-finite (Coprod A B) =
    rec-Prop-trunc
      ( count A)
      ( is-finite/Prop (Coprod A B))
      ( \ c. rec-Prop-trunc
              ( count B)
              ( is-finite/Prop (Coprod A B))
              ( \ c'. Prop-trunc/unit (count/closed-Coprod A B c c'))
              is-finite-B)
      is-finite-A

  is-finite/closed-Coprod-left (A B : U) (is-finite-copr : is-finite (Coprod A B)) : is-finite A =
    rec-Prop-trunc
      ( count (Coprod A B))
      ( is-finite/Prop A)
      ( \ c. Prop-trunc/unit (count/closed-Coprod-left A B c))
      is-finite-copr

  is-finite/closed-Coprod-right (A B : U) (is-finite-copr : is-finite (Coprod A B)) : is-finite B =
    rec-Prop-trunc
      ( count (Coprod A B))
      ( is-finite/Prop B)
      ( \ c. Prop-trunc/unit (count/closed-Coprod-right A B c))
      is-finite-copr
   #+end_src
If =X= and =Y= are finite, then =X * Y= is also finite.
#+begin_src ctt
  is-finite/closed-Prod (A B : U) (is-finite-A : is-finite A) (is-finite-B : is-finite B) : is-finite (A * B) =
    rec-Prop-trunc
      ( count A)
      ( is-finite/Prop (A * B))
      ( \ c. rec-Prop-trunc
              ( count B)
              ( is-finite/Prop (A * B))
              ( \ c'. Prop-trunc/unit (count/closed-Prod A B c c'))
              is-finite-B)
      is-finite-A
#+end_src

** Cardinal of Bool * Bool
   #+begin_src ctt
  Bool : U = Coprod Unit Unit

  true : Bool = inl star
  false : Bool = inr star

  Bool/is-finite : is-finite Bool =
    is-finite/closed-Coprod
      Unit
      Unit
      Unit/is-finite
      Unit/is-finite

  BoolBool/card : Nat =
    card
      ( Bool * Bool)
      ( is-finite/closed-Prod Bool Bool Bool/is-finite Bool/is-finite)
   #+end_src

** Closure under \Pi-types
In this section, we show that if =B= is a family of finite types over a finite type =A=, then the product \Pi_{x: A}B(x) is also finite.
*** Finite family over =Fin k=
First, we start by showing that if =B= is a finite family over =Fin k=, then \Pi_{x: Fin k}B(x) is also finite. This proof is by induction on =k=. 
The case =k = 0= is trivial: a family over the empty type is contractible thus it has a count and it is finite. 
The case =k > 0= is done using the dependent universal property of coproduct. By induction hypothesis, \Pi_{x: Fin k}B(x) is finite and by hypothesis, B(inr star) is also finite. Finally, a product of finite things is finite.
#+begin_src ctt
  is-finite/pi' : (k : Nat) -> (B : Fin k -> U) -> ((x : Fin k) -> is-finite (B x)) -> is-finite ((x : Fin k) -> B x) = split
    zero ->
      \ B _.
        count/is-finite
          ( (x : Fin zero) -> B x)
          ( count/contr-count
            ( (x : Fin zero) -> B x)
            ( Empty/universal-dependent-property
              ( Fin zero) B
              ( Equiv/refl (Fin zero))))
    suc k ->
      \ B is-fin-B.
        is-finite/closed-Equiv
          ( (x : Fin (suc k)) -> B x)
          ( ((x : Fin k) -> B (inl x)) * (B (inr star)))
          ( Equiv/trans
            ( (x : Fin (suc k)) -> B x)
            ( ((x : Fin k) -> B (inl x)) * ((u : Unit) -> B (inr u)))
            ( ((x : Fin k) -> B (inl x)) * (B (inr star)))
            ( Coprod/dependent-universal-property
              ( Fin k) Unit B)
            ( Equiv/prod'
              ( (x : Fin k) -> B (inl x))
              ( (u : Unit) -> B (inr u))
              ( B (inr star))
              ( Equiv/pi-Unit
                ( \ u. B (inr u)))))
          ( is-finite/closed-Prod
            ( (x : Fin k) -> B (inl x))
            ( B (inr star))
            ( is-finite/pi' k
              ( \ x. B (inl x))
              ( \ x. is-fin-B (inl x)))
            ( is-fin-B (inr star)))
#+end_src

*** Finite family over finite type
Let =A= be a finite type. As =is-finite= is a proposition, by the induction principle of the propositional truncation, we assume that we have a count of =A=; that is, an equivalence from Fin k to A for some k. Then, as =is-finite= is closed under equivalence, for any finite family =B= over a finite type =A=, \Pi_{x: A}B(x) is also finite.
#+begin_src ctt
  is-finite/Pi (A : U) (B : A -> U) (is-finite-A : is-finite A) (is-finite-B : (x : A) -> is-finite (B x))
                  : is-finite ((x : A) -> B x) =
    rec-Prop-trunc
      ( count A)
      ( is-finite/Prop ((x : A) -> B x))
      ( \ c.
        is-finite/closed-Equiv
          ( (x : A) -> B x)
          ( (x : Fin (number-of-elements A c)) -> B (Equiv/map (Fin (number-of-elements A c)) A (count/Equiv A c) x))
          ( Equiv/dependent
            ( Fin (number-of-elements A c)) A B
            ( count/Equiv A c))
          ( is-finite/pi'
            ( number-of-elements A c)
            ( \ x. B (Equiv/map (Fin (number-of-elements A c)) A (count/Equiv A c) x))
            ( \ x. is-finite-B (Equiv/map (Fin (number-of-elements A c)) A (count/Equiv A c) x)))) is-finite-A
#+end_src

** A finite type is a set
   #+begin_src ctt
  is-finite/is-set (A : U) : is-finite A -> is-set A =
    rec-Prop-trunc
      ( count A)
      ( is-set/Prop A)
      ( \ c. count/is-set A c)
   #+end_src
** A finite type has decidable equality
If a type is finite, then it is a set. In particular, =has-decidable-equality= is a proposition on this type, so it follows by the recursion principle of propositional truncation that a finite type has decidable equality.
   #+begin_src ctt
  is-finite/has-decidable-equality (A : U) (is-finite-A : is-finite A) : has-decidable-equality A =
    rec-Prop-trunc
      ( count A)
      ( has-decidable-equality/Prop A
        ( is-finite/is-set A is-finite-A))
      ( count/has-decidable-eq A) is-finite-A
   #+end_src
** Finite choice
There is a finite choice map (\Pi_{x: A}||B x||) \to ||\Pi_{x: A}B(x)|| for any finite type A and family over this finite type B.
#+begin_src ctt
  Fin/choice : (k : Nat) (B : Fin k -> U) (H : (x : Fin k) -> Prop-trunc (B x)) -> Prop-trunc ((x : Fin k) -> B x) = split
    zero -> \ B _.
      Prop-trunc/unit
        ( center ((x : Fin zero) -> B x)
          ( Empty/universal-dependent-property
            ( Fin zero) B
            ( Equiv/refl (Fin zero))))
    suc k -> \ B.
      Equiv/map
        ( (x : Fin (suc k)) -> Prop-trunc (B x))
        ( Prop-trunc ((x : Fin (suc k)) -> B x))
        ( Equiv/comp five-Nat
          ( (x : Fin (suc k)) -> Prop-trunc (B x))
          ( ((x : Fin k) -> Prop-trunc (B (inl x))) * ((x : Unit) -> Prop-trunc (B (inr x))))
          ( Coprod/dependent-universal-property
            ( Fin k) Unit (\ x. Prop-trunc (B x)))
          ( ((x : Fin k) -> Prop-trunc (B (inl x))) * (Prop-trunc (B (inr star))))
          ( Equiv/prod'
            ( (x : Fin k) -> Prop-trunc (B (inl x)))
            ( (x : Unit) -> Prop-trunc (B (inr x)))
            ( Prop-trunc (B (inr star)))
            ( Equiv/pi-Unit
              ( \ x. Prop-trunc (B (inr x)))))
          ( (Prop-trunc ((x : Fin k) -> B (inl x))) * (Prop-trunc (B (inr star))))
          ( Equiv/prod
            ( (x : Fin k) -> Prop-trunc (B (inl x)))
            ( Prop-trunc ((x : Fin k) -> B (inl x)))
            ( Prop-trunc (B (inr star)))
            ( Prop/Equiv
              ( Prop/Pi (Fin k) (\ x. Prop-trunc/Prop (B (inl x))))
              ( Prop-trunc/Prop ((x : Fin k) -> B (inl x)))
              ( Fin/choice k (\ x. B (inl x)))
              ( Prop-trunc/Pi/map-out
                ( Fin k)
                ( \ x. B (inl x)))))
          ( Prop-trunc (((x : Fin k) -> B (inl x)) * (B (inr star))))
          ( Prop-trunc/closed-Prod
            ( (x : Fin k) -> B (inl x))
            ( B (inr star)))
          ( Prop-trunc (((x : Fin k) -> B (inl x)) * ((x : Unit) -> B (inr x))))
          ( Equiv/Prop-trunc
            (((x : Fin k) -> B (inl x)) * (B (inr star)))
            (((x : Fin k) -> B (inl x)) * ((x : Unit) -> B (inr x)))
            ( Equiv/prod'
              ( (x : Fin k) -> B (inl x))
              ( B (inr star))
              ( (x : Unit) -> B (inr x))
              ( Equiv/sym
                ( (x : Unit) -> B (inr x))
                ( B (inr star))
                ( Equiv/pi-Unit (\ x. B (inr x))))))
          ( Prop-trunc ((x : Fin (suc k)) -> B x))
          ( Equiv/Prop-trunc
            ( ((x : Fin k) -> B (inl x)) * ((x : Unit) -> B (inr x)))
            ( (x : Fin (suc k)) -> B x)
            ( Equiv/sym
              ( (x : Fin (suc k)) -> B x)
              ( ((x : Fin k) -> B (inl x)) * ((x : Unit) -> B (inr x)))
              ( Coprod/dependent-universal-property
                ( Fin k) Unit B))))

  is-finite/choice (A : U) (B : A -> U) (is-finite-A : is-finite A) (H : (x : A) -> Prop-trunc (B x)) : Prop-trunc ((x : A) -> B x) =
    rec-Prop-trunc
      ( count A)
      ( Prop-trunc/Prop
        ( (x : A) -> B x))
      ( \ c. 
          let k : Nat = number-of-elements A c
              f : Fin k -> A = Equiv/map (Fin k) A (count/Equiv A c)
              g : A -> Fin k = Equiv/inv-map (Fin k) A (count/Equiv A c)
           in
          rec-Prop-trunc
            ( (x : (Fin k)) -> B (f x))
            ( Prop-trunc/Prop ((x : A) -> B x))
            ( \ h. Prop-trunc/unit
                  ( \ x. tr A (f (g x)) x (Equiv/inv-right-htpy (Fin k) A (count/Equiv A c) x) B (h (g x))))
            ( Fin/choice k
              ( \ x. B (f x))
              ( \ x. H (f x)))) is-finite-A
#+end_src

** Closure under \Sigma-types
Given a finite type =A= and a family of finite types =B= over =A=, \Sigma A B is also finite.
#+begin_src ctt
  is-finite/closed-Sg (A : U) (B : A -> U) (is-finite-A : is-finite A) (H : (x : A) -> is-finite (B x)) : is-finite (Sg A B) =
    rec-Prop-trunc
      ( count A)
      ( is-finite/Prop
          ( Sg A B))
      ( \ c. rec-Prop-trunc
              ( (x : A) -> count (B x))
              ( is-finite/Prop
                ( Sg A B))
              ( \ H'. Prop-trunc/unit (count/closed-Sg A B c H'))
              ( is-finite/choice A (\ x. count (B x)) is-finite-A H)) is-finite-A
#+end_src

#+RESULTS:
: Typecheck has succeeded.
