#+NAME: IsFinite
#+AUTHOR: Johann Rosain

* Finite types

#+begin_src ctt
  module Lib.IsFinite where
#+end_src

Finite types are types that can be counted. However, when defining finite types, we do not especially care about the counting, we only care about the fact that /it can be counted/, which translates in the definition by using [[PropTrunc.org][propositional truncation]]. However, this definition is not practical as it does not give the number of elements. Hence, we also show that finite types are /logically equivalent/ to types with cardinalities.

** Packages imports

#+begin_src ctt
  import Lib.PropTrunc
  import Lib.Counting
  import Lib.Image
  import Lib.Prop.Nat
  import Lib.Prop.Coprod
  import Lib.Prop.Empty  
  import Lib.Prop.Decidability
#+end_src

** Definition
Definition using propositional truncation.
   #+begin_src ctt
  is-finite (X : U) : U =
    Prop-trunc
      ( count X)
   #+end_src
Some shortcuts.
#+begin_src ctt
  is-finite/is-prop (X : U) : is-prop (is-finite X) =
    Prop-trunc/is-prop
      ( count X)

  is-finite/Prop (X : U) : UU-Prop =
    ( is-finite X,
      is-finite/is-prop X)
#+end_src

** Properties

*** A type that has a count is finite
#+begin_src ctt
  count/is-finite (X : U) (c : count X) : is-finite X =
    Prop-trunc/unit c
#+end_src
*** Unit is finite
    #+begin_src ctt
  Unit/is-finite : is-finite Unit =
    count/is-finite Unit
      ( count/Unit)
    #+end_src
*** Fin is finite
#+begin_src ctt
  Fin/is-finite (k : Nat) : is-finite (Fin k) =
    count/is-finite
      ( Fin k)
      ( count/fin-count k)
#+end_src
*** Closure under equivalence
Of course, if =Equiv X Y= and one of them is finite, the other one is also finite.
#+begin_src ctt
  is-finite/closed-Equiv (A B : U) (e : Equiv A B) (is-finite-B : is-finite B) : is-finite A =
    Prop-trunc/map
      ( count B)
      ( count A)
      ( count/closed-equiv A B e) is-finite-B    

  is-finite/closed-Equiv' (A B : U) (e : Equiv A B) (is-finite-A : is-finite A) : is-finite B =
    is-finite/closed-Equiv B A (Equiv/sym A B e) is-finite-A
#+end_src

** Cardinality
We define the notion of having a cardinality and its equivalence to the notion of =is-finite=.
#+begin_src ctt
  has-cardinality (X : U) : U =
    Sg Nat
      ( \ k. mere-equiv (Fin k) X)
#+end_src
Of course, =has-cardinality= is a proposition.
#+begin_src ctt
  has-cardinality/is-prop/sg (X : U) (k : Nat) (h : mere-equiv (Fin k) X) (k' : Nat) (h' : mere-equiv (Fin k') X)
                                : Path (has-cardinality X) (k, h) (k', h') =
    SgPath-prop Nat
      ( \ n. mere-equiv (Fin n) X)
      ( \ n. mere-equiv/is-prop (Fin n) X)
      ( k, h)
      ( k', h')
      ( rec-Prop-trunc
        ( Equiv (Fin k) X)
        ( Nat/eq/Prop k k')
        ( \ e. rec-Prop-trunc
                ( Equiv (Fin k') X)
                ( Nat/eq/Prop k k')
                ( \ e'. Fin/is-inj k k'
                         ( Equiv/trans
                            ( Fin k) X
                            ( Fin k') e
                            ( Equiv/sym (Fin k') X e'))) h') h)

  has-cardinality/is-prop (X : U) : is-prop (has-cardinality X) =
    \ h h'. has-cardinality/is-prop/sg X h.1 h.2 h'.1 h'.2

  has-cardinality/Prop (X : U) : UU-Prop =
    ( has-cardinality X,
      has-cardinality/is-prop X)
#+end_src
Thus, there is an equivalence between having a cardinality and being finite.
#+begin_src ctt
  is-finite/has-cardinality (X : U) : is-finite X -> has-cardinality X =
    rec-Prop-trunc
      ( count X)
      ( has-cardinality/Prop X)
      ( \ c. ( number-of-elements X c,
              Prop-trunc/unit (count/Equiv X c)))

  has-cardinality/is-finite' (X : U) (k : Nat) (e : mere-equiv (Fin k) X) : is-finite X =
    rec-Prop-trunc
      ( Equiv (Fin k) X)
      ( is-finite/Prop X)
      ( \ e'. Prop-trunc/unit (k, e')) e    

  has-cardinality/is-finite (X : U) : has-cardinality X -> is-finite X =
    \ t. has-cardinality/is-finite' X t.1 t.2
#+end_src
Some shortcuts.
#+begin_src ctt
  has-cardinality/card (X : U) (h : has-cardinality X) : Nat = h.1

  has-cardinality/Equiv (X : U) (h : has-cardinality X) : mere-equiv (Fin (has-cardinality/card X h)) X = h.2

  card (X : U) (i : is-finite X) : Nat =
    has-cardinality/card X
      ( is-finite/has-cardinality X i)
#+end_src

** Some immediate consequences
=X= and =Y= are finite iff their coproduct is finite.
   #+begin_src ctt
  is-finite/closed-Coprod (A B : U) (is-finite-A : is-finite A) (is-finite-B : is-finite B) : is-finite (Coprod A B) =
    rec-Prop-trunc
      ( count A)
      ( is-finite/Prop (Coprod A B))
      ( \ c. rec-Prop-trunc
              ( count B)
              ( is-finite/Prop (Coprod A B))
              ( \ c'. Prop-trunc/unit (count/closed-Coprod A B c c'))
              is-finite-B)
      is-finite-A

  is-finite/closed-Coprod-left (A B : U) (is-finite-copr : is-finite (Coprod A B)) : is-finite A =
    rec-Prop-trunc
      ( count (Coprod A B))
      ( is-finite/Prop A)
      ( \ c. Prop-trunc/unit (count/closed-Coprod-left A B c))
      is-finite-copr

  is-finite/closed-Coprod-right (A B : U) (is-finite-copr : is-finite (Coprod A B)) : is-finite B =
    rec-Prop-trunc
      ( count (Coprod A B))
      ( is-finite/Prop B)
      ( \ c. Prop-trunc/unit (count/closed-Coprod-right A B c))
      is-finite-copr
   #+end_src
If =X= and =Y= are finite, then =X * Y= is also finite.
#+begin_src ctt
  is-finite/closed-Prod (A B : U) (is-finite-A : is-finite A) (is-finite-B : is-finite B) : is-finite (A * B) =
    rec-Prop-trunc
      ( count A)
      ( is-finite/Prop (A * B))
      ( \ c. rec-Prop-trunc
              ( count B)
              ( is-finite/Prop (A * B))
              ( \ c'. Prop-trunc/unit (count/closed-Prod A B c c'))
              is-finite-B)
      is-finite-A
#+end_src

** Cardinal of Bool * Bool
   #+begin_src ctt
  Bool : U = Coprod Unit Unit

  true : Bool = inl star
  false : Bool = inr star

  Bool/is-finite : is-finite Bool =
    is-finite/closed-Coprod
      Unit
      Unit
      Unit/is-finite
      Unit/is-finite

  BoolBool/card : Nat =
    card
      ( Bool * Bool)
      ( is-finite/closed-Prod Bool Bool Bool/is-finite Bool/is-finite)
   #+end_src

** Closure under \Pi-types
In this section, we show that if =B= is a family of finite types over a finite type =A=, then the product \Pi_{x: A}B(x) is also finite.
*** Finite family over =Fin k=
First, we start by showing that if =B= is a finite family over =Fin k=, then \Pi_{x: Fin k}B(x) is also finite. This proof is by induction on =k=. 
The case =k = 0= is trivial: a family over the empty type is contractible thus it has a count and it is finite. 
The case =k > 0= is done using the dependent universal property of coproduct. By induction hypothesis, \Pi_{x: Fin k}B(x) is finite and by hypothesis, B(inr star) is also finite. Finally, a product of finite things is finite.
#+begin_src ctt
  is-finite/pi' : (k : Nat) -> (B : Fin k -> U) -> ((x : Fin k) -> is-finite (B x)) -> is-finite ((x : Fin k) -> B x) = split
    zero ->
      \ B _.
        count/is-finite
          ( (x : Fin zero) -> B x)
          ( count/contr-count
            ( (x : Fin zero) -> B x)
            ( Empty/universal-dependent-property
              ( Fin zero) B
              ( Equiv/refl (Fin zero))))
    suc k ->
      \ B is-fin-B.
        is-finite/closed-Equiv
          ( (x : Fin (suc k)) -> B x)
          ( ((x : Fin k) -> B (inl x)) * (B (inr star)))
          ( Equiv/trans
            ( (x : Fin (suc k)) -> B x)
            ( ((x : Fin k) -> B (inl x)) * ((u : Unit) -> B (inr u)))
            ( ((x : Fin k) -> B (inl x)) * (B (inr star)))
            ( Coprod/dependent-universal-property
              ( Fin k) Unit B)
            ( Equiv/prod'
              ( (x : Fin k) -> B (inl x))
              ( (u : Unit) -> B (inr u))
              ( B (inr star))
              ( Equiv/pi-Unit
                ( \ u. B (inr u)))))
          ( is-finite/closed-Prod
            ( (x : Fin k) -> B (inl x))
            ( B (inr star))
            ( is-finite/pi' k
              ( \ x. B (inl x))
              ( \ x. is-fin-B (inl x)))
            ( is-fin-B (inr star)))
#+end_src

*** Finite family over finite type
Let =A= be a finite type. As =is-finite= is a proposition, by the induction principle of the propositional truncation, we assume that we have a count of =A=; that is, an equivalence from Fin k to A for some k. Then, as =is-finite= is closed under equivalence, for any finite family =B= over a finite type =A=, \Pi_{x: A}B(x) is also finite.
#+begin_src ctt
  is-finite/Pi (A : U) (B : A -> U) (is-finite-A : is-finite A) (is-finite-B : (x : A) -> is-finite (B x))
                  : is-finite ((x : A) -> B x) =
    rec-Prop-trunc
      ( count A)
      ( is-finite/Prop ((x : A) -> B x))
      ( \ c.
        is-finite/closed-Equiv
          ( (x : A) -> B x)
          ( (x : Fin (number-of-elements A c)) -> B (Equiv/map (Fin (number-of-elements A c)) A (count/Equiv A c) x))
          ( Equiv/dependent
            ( Fin (number-of-elements A c)) A B
            ( count/Equiv A c))
          ( is-finite/pi'
            ( number-of-elements A c)
            ( \ x. B (Equiv/map (Fin (number-of-elements A c)) A (count/Equiv A c) x))
            ( \ x. is-finite-B (Equiv/map (Fin (number-of-elements A c)) A (count/Equiv A c) x)))) is-finite-A
#+end_src

** A finite type is a set
   #+begin_src ctt
  is-finite/is-set (A : U) : is-finite A -> is-set A =
    rec-Prop-trunc
      ( count A)
      ( is-set/Prop A)
      ( \ c. count/is-set A c)
   #+end_src
** A finite type has decidable equality
If a type is finite, then it is a set. In particular, =has-decidable-equality= is a proposition on this type, so it follows by the recursion principle of propositional truncation that a finite type has decidable equality.
   #+begin_src ctt
  is-finite/has-decidable-equality (A : U) (is-finite-A : is-finite A) : has-decidable-equality A =
    rec-Prop-trunc
      ( count A)
      ( has-decidable-equality/Prop A
        ( is-finite/is-set A is-finite-A))
      ( count/has-decidable-eq A) is-finite-A
   #+end_src

** Finite choice
There is a finite choice map (\Pi_{x: A}||B x||) \to ||\Pi_{x: A}B(x)|| for any finite type A and family over this finite type B.
#+begin_src ctt
  Fin/choice : (k : Nat) (B : Fin k -> U) (H : (x : Fin k) -> Prop-trunc (B x)) -> Prop-trunc ((x : Fin k) -> B x) = split
    zero -> \ B _.
      Prop-trunc/unit
        ( center ((x : Fin zero) -> B x)
          ( Empty/universal-dependent-property
            ( Fin zero) B
            ( Equiv/refl (Fin zero))))
    suc k -> \ B.
      Equiv/map
        ( (x : Fin (suc k)) -> Prop-trunc (B x))
        ( Prop-trunc ((x : Fin (suc k)) -> B x))
        ( Equiv/comp five-Nat
          ( (x : Fin (suc k)) -> Prop-trunc (B x))
          ( ((x : Fin k) -> Prop-trunc (B (inl x))) * ((x : Unit) -> Prop-trunc (B (inr x))))
          ( Coprod/dependent-universal-property
            ( Fin k) Unit (\ x. Prop-trunc (B x)))
          ( ((x : Fin k) -> Prop-trunc (B (inl x))) * (Prop-trunc (B (inr star))))
          ( Equiv/prod'
            ( (x : Fin k) -> Prop-trunc (B (inl x)))
            ( (x : Unit) -> Prop-trunc (B (inr x)))
            ( Prop-trunc (B (inr star)))
            ( Equiv/pi-Unit
              ( \ x. Prop-trunc (B (inr x)))))
          ( (Prop-trunc ((x : Fin k) -> B (inl x))) * (Prop-trunc (B (inr star))))
          ( Equiv/prod
            ( (x : Fin k) -> Prop-trunc (B (inl x)))
            ( Prop-trunc ((x : Fin k) -> B (inl x)))
            ( Prop-trunc (B (inr star)))
            ( Prop/Equiv
              ( Prop/Pi (Fin k) (\ x. Prop-trunc/Prop (B (inl x))))
              ( Prop-trunc/Prop ((x : Fin k) -> B (inl x)))
              ( Fin/choice k (\ x. B (inl x)))
              ( Prop-trunc/Pi/map-out
                ( Fin k)
                ( \ x. B (inl x)))))
          ( Prop-trunc (((x : Fin k) -> B (inl x)) * (B (inr star))))
          ( Prop-trunc/closed-Prod
            ( (x : Fin k) -> B (inl x))
            ( B (inr star)))
          ( Prop-trunc (((x : Fin k) -> B (inl x)) * ((x : Unit) -> B (inr x))))
          ( Equiv/Prop-trunc
            (((x : Fin k) -> B (inl x)) * (B (inr star)))
            (((x : Fin k) -> B (inl x)) * ((x : Unit) -> B (inr x)))
            ( Equiv/prod'
              ( (x : Fin k) -> B (inl x))
              ( B (inr star))
              ( (x : Unit) -> B (inr x))
              ( Equiv/sym
                ( (x : Unit) -> B (inr x))
                ( B (inr star))
                ( Equiv/pi-Unit (\ x. B (inr x))))))
          ( Prop-trunc ((x : Fin (suc k)) -> B x))
          ( Equiv/Prop-trunc
            ( ((x : Fin k) -> B (inl x)) * ((x : Unit) -> B (inr x)))
            ( (x : Fin (suc k)) -> B x)
            ( Equiv/sym
              ( (x : Fin (suc k)) -> B x)
              ( ((x : Fin k) -> B (inl x)) * ((x : Unit) -> B (inr x)))
              ( Coprod/dependent-universal-property
                ( Fin k) Unit B))))

  is-finite/choice (A : U) (B : A -> U) (is-finite-A : is-finite A) (H : (x : A) -> Prop-trunc (B x)) : Prop-trunc ((x : A) -> B x) =
    rec-Prop-trunc
      ( count A)
      ( Prop-trunc/Prop
        ( (x : A) -> B x))
      ( \ c. 
          let k : Nat = number-of-elements A c
              f : Fin k -> A = Equiv/map (Fin k) A (count/Equiv A c)
              g : A -> Fin k = Equiv/inv-map (Fin k) A (count/Equiv A c)
           in
          rec-Prop-trunc
            ( (x : (Fin k)) -> B (f x))
            ( Prop-trunc/Prop ((x : A) -> B x))
            ( \ h. Prop-trunc/unit
                  ( \ x. tr A (f (g x)) x (Equiv/inv-right-htpy (Fin k) A (count/Equiv A c) x) B (h (g x))))
            ( Fin/choice k
              ( \ x. B (f x))
              ( \ x. H (f x)))) is-finite-A
#+end_src

** Closure under \Sigma-types
Given a finite type =A= and a family of finite types =B= over =A=, \Sigma A B is also finite.
#+begin_src ctt
  is-finite/closed-Sg (A : U) (B : A -> U) (is-finite-A : is-finite A) (H : (x : A) -> is-finite (B x)) : is-finite (Sg A B) =
    rec-Prop-trunc
      ( count A)
      ( is-finite/Prop
          ( Sg A B))
      ( \ c. rec-Prop-trunc
              ( (x : A) -> count (B x))
              ( is-finite/Prop
                ( Sg A B))
              ( \ H'. Prop-trunc/unit (count/closed-Sg A B c H'))
              ( is-finite/choice A (\ x. count (B x)) is-finite-A H)) is-finite-A
#+end_src

** Surjective map codomain is finite iff it has decidable equality
We show that if f : A \to B is a surjective map and A is finite, then B is finite iff it has decidable equality. In fact, the forward direction is immediate from =is-finite/has-decidable-equality=. We show the converse by induction on the number of elements. First, we set =A= to be =Fin k= and we show that =B= has a count. The base case is trivial, \emptyset \simeq B.
#+begin_src ctt
  has-decidable-equality/is-finite/base/map (B : U) (f : Empty -> B) (H : is-surj Empty B f) : B -> Empty =
    \ b. rec-Prop-trunc
        ( Fib Empty B f b)
        ( Empty/Prop)
        ( \ t. t.1)
        ( H b)

  has-decidable-equality/is-finite/base/right-htpy (B : U) (f : Empty -> B) (H : is-surj Empty B f) (x : Empty)
                                                      : Path Empty (has-decidable-equality/is-finite/base/map B f H (f x)) x =
    ex-falso
      ( Path Empty (has-decidable-equality/is-finite/base/map B f H (f x)) x) x    

  has-decidable-equality/is-finite/base/left-htpy (B : U) (f : Empty -> B) (H : is-surj Empty B f) (b : B)
                                                     : Path B (f (has-decidable-equality/is-finite/base/map B f H b)) b =
    ex-falso
      ( Path B (f (has-decidable-equality/is-finite/base/map B f H b)) b)
      ( rec-Prop-trunc
          ( Fib Empty B f b)
          ( Empty/Prop)
          ( \ t. t.1)
          ( H b))

  has-decidable-equality/is-finite/base (B : U) (f : Empty -> B) (H : is-surj Empty B f) : count B =
    ( zero,
      has-inverse/Equiv Empty B f
        ( has-decidable-equality/is-finite/base/map B f H,
          ( has-decidable-equality/is-finite/base/left-htpy B f H,
            has-decidable-equality/is-finite/base/right-htpy B f H)))
#+end_src
The inductive case is more involved. First, as B's equality is decidable, we can decide for any y : B whether there exists an x : Fin k such that y = f(x) or if no x : Fin k are such that y = f(x).

*** Decidability
#+begin_src ctt
  has-decidable-equality/is-finite/decide/s'' (B : U) (y : B) (k : Nat) (f : Fin (suc k) -> B) (p : neg (Path B y (f (inr star))))
                                              (h : (x : Fin k) -> neg (Path B y (f (inl x))))
                                                 : (x : Fin (suc k)) -> neg (Path B y (f x)) = split
    inl x -> h x
    inr s -> ind-Unit
              ( \ x. neg (Path B y (f (inr x)))) p s

  has-decidable-equality/is-finite/decide/s' (B : U) (y : B) (k : Nat) (f : Fin (suc k) -> B) (p : neg (Path B y (f (inr star))))
                                                : Coprod (Sg (Fin k) (\ x. Path B y (f (inl x)))) ((x : Fin k) -> neg (Path B y (f (inl x))))
                                                 -> Coprod (Sg (Fin (suc k)) (\ x. Path B y (f x))) ((x : Fin (suc k)) -> neg (Path B y (f x))) = split
    inl t -> inl (inl t.1, t.2)
    inr h -> inr (has-decidable-equality/is-finite/decide/s'' B y k f p h)

  has-decidable-equality/is-finite/decide/s (B : U) (y : B) (k : Nat) (f : Fin (suc k) -> B)
                                            (u : Coprod (Sg (Fin k) (\ x. Path B y (f (inl x)))) ((x : Fin k) -> neg (Path B y (f (inl x)))))
                                               : Coprod (Path B y (f (inr star))) (neg (Path B y (f (inr star))))
                                                -> Coprod (Sg (Fin (suc k)) (\ x. Path B y (f x))) ((x : Fin (suc k)) -> neg (Path B y (f x))) = split
    inl p -> inl (inr star, p)
    inr p -> has-decidable-equality/is-finite/decide/s' B y k f p u

  has-decidable-equality/is-finite/decide'/z' (B : U) (y : B) (f : Fin (suc (suc zero)) -> B) (np : neg (Path B y (f (inl (inr star)))))
                                                 : (x : Fin (suc zero)) -> neg (Path B y (f (inl x))) = split
    inl x -> \ _. x
    inr s -> ind-Unit
              ( \ x. neg (Path B y (f (inl (inr x))))) np s            

  has-decidable-equality/is-finite/decide'/z (B : U) (y : B) (f : Fin (suc (suc zero)) -> B) 
                                                : Coprod (Path B y (f (inl (inr star)))) (neg (Path B y (f (inl (inr star)))))
                                                 -> Coprod (Sg (Fin (suc zero)) (\ x. Path B y (f (inl x)))) ((x : Fin (suc zero)) -> neg (Path B y (f (inl x)))) = split
    inl p -> inl (inr star, p)
    inr np -> inr (has-decidable-equality/is-finite/decide'/z' B y f np)

  has-decidable-equality/is-finite/decide' (B : U) (y : B) (Heq : has-decidable-equality B) : (k : Nat) -> (f : Fin (suc (suc k)) -> B)
                                              -> Coprod (Sg (Fin (suc k)) (\ x. Path B y (f (inl x)))) ((x : Fin (suc k)) -> neg (Path B y (f (inl x)))) = split
    zero -> \ f. has-decidable-equality/is-finite/decide'/z B y f (Heq y (f (inl (inr star))))
    suc k -> \ f.
      has-decidable-equality/is-finite/decide/s B y (suc k) (\ x. f (inl x))
        ( has-decidable-equality/is-finite/decide' B y Heq k (\ x. f (inl x)))
        ( Heq y (f (inl (inr star))))

  has-decidable-equality/is-finite/decide (B : U) (y : B) (Heq : has-decidable-equality B) : (k : Nat) -> (f : Fin (suc k) -> B)
                                              -> Coprod (Sg (Fin k) (\ x. Path B y (f (inl x)))) ((x : Fin k) -> neg (Path B y (f (inl x)))) = split
    zero -> \ _. inr (\ x _. x)
    suc k -> has-decidable-equality/is-finite/decide' B y Heq k
#+end_src

*** Inductive case
Now, there are two cases for the inductive case. If we can find an x : Fin k such that (f (inr star)) = (f (inl x)), then we can directly conclude by induction hypothesis: the function is still surjective while removing the last element.
Otherwise, we need to build a subtype X such that B \simeq X + 1 such that, morally, we put in X all the elements of B that are not f (inr star). Such an X can be built as follows: consider P the subtype of B defined as: P(y) :\equiv y \neq f(inr \star). Thus, let X :\equiv \Sigma_{y: B} P(y).
#+begin_src ctt
  has-decidable-equality/is-finite/subtype (k : Nat) (B : U) (f : Fin (suc k) -> B) : U =
    Sg B (\ y. neg (Path B y (f (inr star))))
#+end_src
Let us build a back-and-forth map between B and X + 1.

*** Maps
    #+begin_src ctt
  has-decidable-equality/is-finite/map' (k : Nat) (B : U) (f : Fin (suc k) -> B) (y : B)
                                           : Coprod (Path B y (f (inr star))) (neg (Path B y (f (inr star))))
                                            -> Maybe (has-decidable-equality/is-finite/subtype k B f) = split
    inl _ -> inr star
    inr np -> inl (y, np)

  has-decidable-equality/is-finite/map (k : Nat) (B : U) (f : Fin (suc k) -> B) (H : has-decidable-equality B) (y : B) : Maybe (has-decidable-equality/is-finite/subtype k B f) =
    has-decidable-equality/is-finite/map' k B f y
      ( H y (f (inr star)))

  has-decidable-equality/is-finite/inv-map (k : Nat) (B : U) (f : Fin (suc k) -> B) (H : has-decidable-equality B) : Maybe (has-decidable-equality/is-finite/subtype k B f) -> B = split
    inl t -> t.1
    inr _ -> f (inr star)
    #+end_src

*** Right homotopy
We show that the inverse map is a right inverse of the map.
#+begin_src ctt
  lock Coprod/Eq/map
  has-decidable-equality/is-finite/right-htpy/inl (k : Nat) (B : U) (f : Fin (suc k) -> B) (H : has-decidable-equality B) (t : has-decidable-equality/is-finite/subtype k B f)
                                                     : (u : Coprod (Path B t.1 (f (inr star))) (neg (Path B t.1 (f (inr star)))))
                                                      -> Path (Coprod (Path B t.1 (f (inr star))) (neg (Path B t.1 (f (inr star)))))
                                                             (H t.1 (f (inr star))) u
                                                      -> Path (Maybe (has-decidable-equality/is-finite/subtype k B f))
                                                             (has-decidable-equality/is-finite/map k B f H t.1) (inl t) = split
    inl p -> \ _.
      ex-falso
        ( Path
          ( Maybe (has-decidable-equality/is-finite/subtype k B f))
          ( has-decidable-equality/is-finite/map k B f H t.1)
          ( inl t))
        ( t.2 p)
    inr np -> \ p.
      comp
        ( Maybe (has-decidable-equality/is-finite/subtype k B f))
        ( has-decidable-equality/is-finite/map k B f H t.1)
        ( has-decidable-equality/is-finite/map' k B f t.1 (inr np))
        ( ap
          ( Coprod (Path B t.1 (f (inr star))) (neg (Path B t.1 (f (inr star)))))
          ( Maybe (has-decidable-equality/is-finite/subtype k B f))
          ( has-decidable-equality/is-finite/map' k B f t.1)
          ( H t.1 (f (inr star))) (inr np) p)
        ( inl t)
        ( Coprod/Eq/map
          ( has-decidable-equality/is-finite/subtype k B f) Unit    
          ( inl (t.1, np))
          ( inl t)
          ( SgPath-prop B
            ( \ y. neg (Path B y (f (inr star))))
            ( \ y. Pi/is-prop
                  ( Path B y (f (inr star)))
                  ( \ _. Empty/Prop))
            ( t.1, np) t
            ( refl B t.1)))

  has-decidable-equality/is-finite/right-htpy/inr (k : Nat) (B : U) (f : Fin (suc k) -> B) (H : has-decidable-equality B)
                                                     : (u : Coprod (Path B (f (inr star)) (f (inr star))) (neg (Path B (f (inr star)) (f (inr star)))))
                                                      -> Path (Coprod (Path B (f (inr star)) (f (inr star))) (neg (Path B (f (inr star)) (f (inr star)))))
                                                             (H (f (inr star)) (f (inr star))) u
                                                      -> Path (Maybe (has-decidable-equality/is-finite/subtype k B f))
                                                             (has-decidable-equality/is-finite/map k B f H (f (inr star))) (inr star) = split
    inl p -> \ q.
      ap
        ( Coprod (Path B (f (inr star)) (f (inr star))) (neg (Path B (f (inr star)) (f (inr star)))))
        ( Maybe (has-decidable-equality/is-finite/subtype k B f))
        ( has-decidable-equality/is-finite/map' k B f (f (inr star)))
        ( H (f (inr star)) (f (inr star)))
        ( inl p) q
    inr np -> \ _.
      ex-falso
        ( Path
          ( Maybe (has-decidable-equality/is-finite/subtype k B f))
          ( has-decidable-equality/is-finite/map k B f H (f (inr star)))
          ( inr star))
        ( np (refl B (f (inr star))))

  has-decidable-equality/is-finite/right-htpy (k : Nat) (B : U) (f : Fin (suc k) -> B) (H : has-decidable-equality B)
                                                 : (u : Maybe (has-decidable-equality/is-finite/subtype k B f))
                                                  -> Path (Maybe (has-decidable-equality/is-finite/subtype k B f))
                                                         (has-decidable-equality/is-finite/map k B f H (has-decidable-equality/is-finite/inv-map k B f H u)) u = split
    inl t -> has-decidable-equality/is-finite/right-htpy/inl k B f H t
              ( H t.1 (f (inr star)))
              ( refl (Coprod (Path B t.1 (f (inr star))) (neg (Path B t.1 (f (inr star))))) (H t.1 (f (inr star))))
    inr s -> ind-Unit
              ( \ x. Path (Maybe (has-decidable-equality/is-finite/subtype k B f)) (has-decidable-equality/is-finite/map k B f H (f (inr star))) (inr x))
              ( has-decidable-equality/is-finite/right-htpy/inr k B f H 
                ( H (f (inr star)) (f (inr star)))
                ( refl (Coprod (Path B (f (inr star)) (f (inr star))) (neg (Path B (f (inr star)) (f (inr star))))) (H (f (inr star)) (f (inr star))))) s
#+end_src

*** Left homotopy
We show that the inverse map is a left inverse to the map.
#+begin_src ctt
  has-decidable-equality/is-finite/left-htpy' (k : Nat) (B : U) (f : Fin (suc k) -> B) (H : has-decidable-equality B)
                                              (y : B) : (u : Coprod (Path B y (f (inr star))) (neg (Path B y (f (inr star)))))
                                                        -> Path (Coprod (Path B y (f (inr star))) (neg (Path B y (f (inr star))))) (H y (f (inr star))) u
                                                        -> Path B (has-decidable-equality/is-finite/inv-map k B f H (has-decidable-equality/is-finite/map k B f H y)) y = split
    inl p -> \ q.
      comp B
        ( has-decidable-equality/is-finite/inv-map k B f H (has-decidable-equality/is-finite/map k B f H y))
        ( has-decidable-equality/is-finite/inv-map k B f H (has-decidable-equality/is-finite/map' k B f y (inl p)))
        ( ap
          ( Coprod (Path B y (f (inr star))) (neg (Path B y (f (inr star))))) B
          ( \ u. has-decidable-equality/is-finite/inv-map k B f H (has-decidable-equality/is-finite/map' k B f y u))
          ( H y (f (inr star)))
          ( inl p) q)
        y (inv B y (f (inr star)) p)
    inr np -> \ q.
      ap
      ( Coprod (Path B y (f (inr star))) (neg (Path B y (f (inr star))))) B
      ( \ u. has-decidable-equality/is-finite/inv-map k B f H (has-decidable-equality/is-finite/map' k B f y u))
      ( H y (f (inr star)))
      ( inr np) q

  has-decidable-equality/is-finite/left-htpy (k : Nat) (B : U) (f : Fin (suc k) -> B) (H : has-decidable-equality B)
                                             (y : B) : Path B (has-decidable-equality/is-finite/inv-map k B f H (has-decidable-equality/is-finite/map k B f H y)) y =
    has-decidable-equality/is-finite/left-htpy' k B f H y
      ( H y (f (inr star)))
      ( refl (Coprod (Path B y (f (inr star))) (neg (Path B y (f (inr star))))) (H y (f (inr star))))
#+end_src

*** Equivalence
Thus, there is an equivalence between B and X + 1.
    #+begin_src ctt
  has-decidable-equality/is-finite/Equiv (k : Nat) (B : U) (f : Fin (suc k) -> B) (H : has-decidable-equality B)
                                            : Equiv B (Maybe (has-decidable-equality/is-finite/subtype k B f)) =
    has-inverse/Equiv B
      ( Maybe (has-decidable-equality/is-finite/subtype k B f))
      ( has-decidable-equality/is-finite/map k B f H)
      ( has-decidable-equality/is-finite/inv-map k B f H,
        ( has-decidable-equality/is-finite/right-htpy k B f H,
          has-decidable-equality/is-finite/left-htpy k B f H))
    #+end_src

*** Decidable equality
Of course, if B has a decidable equality, X also has a decidable equality as the equality between two elements of X is equivalent to the equality between two elements of B.
#+begin_src ctt
  has-decidable-equality/is-finite/subtype-has-dec-eq' (k : Nat) (B : U) (f : Fin (suc k) -> B) (H : has-decidable-equality B) (t u : has-decidable-equality/is-finite/subtype k B f)
                                                          : Coprod (Path B t.1 u.1) (neg (Path B t.1 u.1))
                                                            -> Coprod (Path (has-decidable-equality/is-finite/subtype k B f) t u)
                                                                     (neg (Path (has-decidable-equality/is-finite/subtype k B f) t u)) = split
    inl p ->
      inl
        ( SgPath-prop B
          ( \ y. neg (Path B y (f (inr star))))
          ( \ y. Pi/is-prop
                ( Path B y (f (inr star)))
                ( \ _. Empty/Prop))
          t u p)
    inr np ->
      inr (\ p. np (Sg-path/left B (\ y. neg (Path B y (f (inr star)))) t u p))

  has-decidable-equality/is-finite/subtype-has-dec-eq (k : Nat) (B : U) (f : Fin (suc k) -> B) (H : has-decidable-equality B)
                                                         : has-decidable-equality (has-decidable-equality/is-finite/subtype k B f) =
    \ t u.
      has-decidable-equality/is-finite/subtype-has-dec-eq' k B f H t u
        ( H t.1 u.1)
#+end_src

*** Result
It is now time to prove the result. First, we write the formalization of the inductive case.
#+begin_src ctt
  has-decidable-equality/is-finite/is-surj'' (k : Nat) (B : U) (f : Fin (suc k) -> B) (y : B) (np : neg (Path B y (f (inr star))))
                                                : (x : Fin (suc k)) -> Path B y (f x) -> Fib (Fin k) B (\ x'. f (inl x')) y = split
    inr s ->
      ind-Unit
        ( \ x. Path B y (f (inr x)) -> ( Fib (Fin k) B (\ x'. f (inl x')) y))
        ( \ q. ex-falso
              ( Fib (Fin k) B (\ x. f (inl x)) y)
              ( np q)) s
    inl x -> \ p. (x, p)

  has-decidable-equality/is-finite/is-surj' (k : Nat) (B : U) (f : Fin (suc k) -> B) (is-surj-f : is-surj (Fin (suc k)) B f) (y : B)
                                            (x : Fin k) (p : Path B (f (inr star)) (f (inl x)))
                                               : Coprod (Path B y (f (inr star))) (neg (Path B y (f (inr star))))
                                                -> Prop-trunc (Fib (Fin k) B (\ x'. f (inl x')) y) = split
    inl q -> Prop-trunc/unit (x, comp B y (f (inr star)) q (f (inl x)) p)
    inr np ->
      rec-Prop-trunc
        ( Fib (Fin (suc k)) B f y)
        ( Prop-trunc/Prop (Fib (Fin k) B (\ x'. f (inl x')) y))
        ( \ t. Prop-trunc/unit (has-decidable-equality/is-finite/is-surj'' k B f y np t.1 t.2))
        ( is-surj-f y)

  has-decidable-equality/is-finite/is-surj (k : Nat) (B : U) (H : has-decidable-equality B) (f : Fin (suc k) -> B) (is-surj-f : is-surj (Fin (suc k)) B f)
                                           (x : Fin k) (p : Path B (f (inr star)) (f (inl x)))
                                              : is-surj (Fin k) B (\ x'. f (inl x')) =
    \ y. has-decidable-equality/is-finite/is-surj' k B f is-surj-f y x p (H y (f (inr star)))

  has-decidable-equality/is-finite/ind-map (k : Nat) (B : U) (f : Fin (suc k) -> B) (h : (x : Fin k) -> neg (Path B (f (inr star)) (f (inl x)))) (x : Fin k)
                                              : has-decidable-equality/is-finite/subtype k B f =
    (f (inl x), (\ p. h x (inv B (f (inl x)) (f (inr star)) p)))

  has-decidable-equality/is-finite/is-surj/o (k : Nat) (B : U) (f : Fin (suc k) -> B) (y : B) (np : neg (Path B y (f (inr star)))) (h : (x : Fin k) -> neg (Path B (f (inr star)) (f (inl x))))
                                                : (x : Fin (suc k)) -> Path B y (f x)
                                                  -> Fib (Fin k) (has-decidable-equality/is-finite/subtype k B f) (has-decidable-equality/is-finite/ind-map k B f h) (y, np) = split
    inr s ->
      ind-Unit
        ( \ x. Path B y (f (inr x)) -> Fib (Fin k) (has-decidable-equality/is-finite/subtype k B f) (has-decidable-equality/is-finite/ind-map k B f h) (y, np))
        ( \ q. ex-falso
                ( Fib (Fin k) (has-decidable-equality/is-finite/subtype k B f) (has-decidable-equality/is-finite/ind-map k B f h) (y, np))
                ( np q)) s
    inl x -> \ q.
      ( x,
        SgPath-prop B
          ( \ z. neg (Path B z (f (inr star))))
          ( \ z. Pi/is-prop
                ( Path B z (f (inr star)))
                ( \ _. Empty/Prop))
          ( y, np)
          ( has-decidable-equality/is-finite/ind-map k B f h x) q)    

  has-decidable-equality/is-finite' (k : Nat) (B : U) (H : has-decidable-equality B) (f : Fin (suc k) -> B) (is-surj-f : is-surj (Fin (suc k)) B f)
                                    (IH : (B' : U) (H' : has-decidable-equality B') (f' : Fin k -> B') -> is-surj (Fin k) B' f' -> is-finite B')
                                       : Coprod (Sg (Fin k) (\ x. Path B (f (inr star)) (f (inl x)))) ((x : Fin k) -> neg (Path B (f (inr star)) (f (inl x))))
                                        -> is-finite B = split
    inl t ->
      IH B H (\ x. f (inl x))
        ( has-decidable-equality/is-finite/is-surj k B H f is-surj-f t.1 t.2)
    inr h ->
      let g : Fin k -> has-decidable-equality/is-finite/subtype k B f = has-decidable-equality/is-finite/ind-map k B f h in
      is-finite/closed-Equiv B
        ( Maybe (has-decidable-equality/is-finite/subtype k B f))
        ( has-decidable-equality/is-finite/Equiv k B f H)
        ( is-finite/closed-Coprod 
          ( has-decidable-equality/is-finite/subtype k B f) Unit
          ( IH 
            ( has-decidable-equality/is-finite/subtype k B f)
            ( has-decidable-equality/is-finite/subtype-has-dec-eq k B f H) g          
            ( \ t. rec-Prop-trunc
                    ( Fib (Fin (suc k)) B f t.1)
                    ( Prop-trunc/Prop (Fib (Fin k) (has-decidable-equality/is-finite/subtype k B f) g t))
                    ( \ u. Prop-trunc/unit (has-decidable-equality/is-finite/is-surj/o k B f t.1 t.2 h u.1 u.2))
                    ( is-surj-f t.1)))
          ( Unit/is-finite))
#+end_src

Then, we can prove the result.
#+begin_src ctt
  has-decidable-equality/is-finite : (k : Nat) (B : U) (H : has-decidable-equality B) (f : Fin k -> B) (is-surj-f : is-surj (Fin k) B f) -> is-finite B = split
    zero -> \ B H f is-surj-f. count/is-finite B (has-decidable-equality/is-finite/base B f is-surj-f)
    suc k -> \ B H f is-surj-f.
      has-decidable-equality/is-finite' k B H f is-surj-f
        ( has-decidable-equality/is-finite k)
        ( has-decidable-equality/is-finite/decide B (f (inr star)) H k f)
#+end_src

#+RESULTS:
: Typecheck has succeeded.

*** Unlock
    #+begin_src ctt
  unlock Coprod/Eq/map
    #+end_src
