#+NAME: Counting
#+AUTHOR: Johann Rosain

* Counting

  #+begin_src ctt
  module Lib.Counting where
  #+end_src

This file defines the notion of /counting/ in HoTT, and basic counting properties.

** Packages imports

   #+begin_src ctt
  import Lib.Prop.Equiv
  import Lib.Data.Fin  
  import Lib.Prop.Proposition
  import Lib.Prop.Fin
   #+end_src

** Definition

A type =A= can be counted if there is some =k : Nat= such that =A= is equivalent to =Fin k=.
    #+begin_src ctt
  count (A : U) : U =
    Sg Nat (\ k. Equiv (Fin k) A)
    #+end_src
=k= is also called the /number of elements/ of =A=.
#+begin_src ctt
  number-of-elements (A : U) (c : count A) : Nat = c.1
  count/Equiv (A : U) (c : count A) : Equiv (Fin (number-of-elements A c)) A = c.2
#+end_src

** Properties

*** Canonical count
It follows from the definition that every standard finite type can be counted in a canonical way.
#+begin_src ctt
  count/fin-count (k : Nat) : count (Fin k) =
    (k, IdEquiv (Fin k))
#+end_src
*** Zero and one-counts
For instance, we can give the canonical version of counts for zero and one.
#+begin_src ctt
  count/zero-count : count (Fin zero) =
    count/fin-count zero

  count/one-count : count (Fin one-Nat) =
    count/fin-count one-Nat  
#+end_src

*** Closure under equivalence
Furthermore, types with counting are closed under equivalence.
#+begin_src ctt
  count/closed-equiv (A B : U) (e : Equiv A B) (c : count B) : count A =
    (number-of-elements B c,
     Equiv/trans (Fin (number-of-elements B c)) B A (count/Equiv B c) (Equiv/sym A B e))

  count/closed-equiv' (A B : U) (e : Equiv A B) (c : count A) : count B =
    count/closed-equiv B A (Equiv/sym A B e) c
#+end_src

*** Empty means no elements
If =(k, e)= is a counting of a type =A=, then =k = 0= iff =A= is =Empty=.
  * [\leftarrow] =f : is-empty A= is an equivalence, thus =Fin k= is equivalent to =Empty= and a quick induction on =k= is enough to conclude.
  #+begin_src ctt
  count/empty-has-zero-count (A : U) (c : count A) (f : is-empty A) : Path Nat zero (number-of-elements A c) =
    let e : Equiv (Fin (number-of-elements A c)) Empty =
          Equiv/trans (Fin (number-of-elements A c)) A Empty (count/Equiv A c) (Empty/equiv A f) in
    ind-Nat (\ k. (Equiv (Fin k) Empty) -> Path Nat zero k)
            (\ _. refl Nat zero)
            (\ n _ e'. ex-falso (Path Nat zero (suc n)) ((Equiv/map (Fin (suc n)) Empty e') (zero-Fin n)))
            (number-of-elements A c) e
  #+end_src
  * [\to] By sigma-induction on the counting, yielding =(k, e)= then by path induction as =inv e : A \to Empty=.
#+begin_src ctt
  count/zero-is-empty (A : U) (c : count A) (p : Path Nat zero (number-of-elements A c)) : is-empty A =
     ind-Sg Nat (\ k. Equiv (Fin k) A)
                (\ z. (Path Nat zero z.1) -> is-empty A)
                (\ k e p'. J Nat zero (\ k' _. Equiv (Fin k') A -> is-empty A) (\ e'. Equiv/inv-map Empty A e') k p' e)
                c p
#+end_src

*** Contractible iff one element
First, assume that =A= has one element, that is, there is an equivalence between =A= and =Fin 1=. As =Fin 1= is contractible, =A= is also contractible. Conversely, as =A= and =Fin 1= are both contractible, they are equivalent and thus all countings of =A= have one element.
#+begin_src ctt
  -- count/contractible-has-one-element (A : U) (c : count A) (cA : is-contr A) : Path Nat one-Nat (number-of-elements A c) =
  --   ind-Sg A (\ k. Equiv (Fin k) A)
  --            (\ p. Path Nat one-Nat p.1)
  --            (ind-Nat (\ k. Equiv (Fin k) A -> Path Nat one-Nat k)
  --                     (\ e. ex-falso (Path Nat one-Nat zero) (Equiv/inv-map (Fin zero) A e (center A cA)))
  --                     (\ k _ e. ind-Nat (\ k'. Equiv (Fin k') A -> Path Nat one-Nat k')
  --                                      (\ _. refl Nat one-Nat)
  --                                      (\ k' r e'. ex-falso (Path Nat one-Nat k') ?)) k e) c

  count/one-element-is-contr (A : U) (c : count A) (p : Path Nat one-Nat (number-of-elements A c)) : is-contr A =
    J Nat one-Nat (\ k' _. Equiv (Fin k') A -> is-contr A)
                  (\ e'. is-contr/is-contr-equiv' (Fin one-Nat) A e' Fin/fin-one-is-contr)
                  (number-of-elements A c) p (count/Equiv A c)

  -- count/contr-count (A : U) (c : is-contr A) : count A =
  --   (one-Nat, count/closed-equiv A (Fin one-Nat) () count/one-count)
#+end_src
TODO: last thing needs the last lemma of 3-for-2 property.

*** A proposition is countable iff it is decidable
First, if a type =X= is countable, then it is decidable as can be shown by a quick induction on the number of elements of =X=.
#+begin_src ctt
  count/countable-is-decidable (X : U) (c : count X) : is-decidable X =
    ind-Sg Nat (\ k. Equiv (Fin k) X)
               (\ _. is-decidable X)
               (ind-Nat (\ k'. Equiv (Fin k') X -> is-decidable X)
                        (\ e'. is-decidable/Equiv' Empty X e' is-decidable/Empty)
                        (\ k' _ e'. inl ((Equiv/map (Fin (suc k')) X e') (inr star)))) c 
#+end_src
Conversely, if =X= is a decidable proposition, then =X= is countable. Indeed, by case analysis, it yields either the zero-count or the one-count.
#+begin_src ctt
  count/is-decidable-is-countable (X : U) (p : is-prop X) : is-decidable X -> count X = split
    inl x -> (one-Nat, Equiv/trans (Fin one-Nat) Unit X (Equiv/Equiv-copr-empty-type Unit) (Equiv/sym X Unit (is-prop/is-subterminal X p x)))
    inr f -> (zero, Equiv/sym X Empty (Empty/equiv X f))
#+end_src

*** A countable type has a decidable equality
Actually, a type =A= equipped with a counting has decidable equality as =Fin k= has decidable equality.
#+begin_src ctt
  count/has-decidable-eq (A : U) (c : count A) : has-decidable-equality A =
    has-decidable-equality/Equiv' (Fin (number-of-elements A c)) A (count/Equiv A c) (Fin/decidable-eq (number-of-elements A c))
#+end_src

*** TODO A countable type is a set
Then, Hedberg's theorem allows us to conclude that if =A= has a counting, then =A= is a set.

*** Characterization of countings for coproduct and dependent pair
If =A= and =B= come equipped with a counting, then =Coprod A B= also comes with a counting. Indeed, if A \simeq Fin k and B \simeq Fin \ell, then Coprod A B \simeq Coprod (Fin k) (Fin \ell) \simeq Fin (k + \ell).
#+begin_src ctt
  count/closed-Coprod (A B : U) (cA : count A) (cB : count B) : count (Coprod A B) =
    let k : Nat = number-of-elements A cA
        l : Nat = number-of-elements B cB
    in
    (plus-Nat k l, (Equiv/trans (Fin (plus-Nat k l)) (Coprod (Fin k) (Fin l)) (Coprod A B)
                   (Fin/Equiv-add-copr k l) (Coprod/closed-Equiv (Fin k) A (Fin l) B (count/Equiv A cA) (count/Equiv B cB))))
#+end_src
If =A= comes equipped with a counting and =B= is a type family over =A=, then all =B x= come equipped with a counting iff Sg A B comes equipped with a counting.
#+begin_src ctt
  count/closed-Sg/sg (A : U) (B : A -> U) (H : (x : A) -> count (B x)) : (k : Nat) -> (e : Equiv (Fin k) A) -> count (Sg A B) = split
    zero -> \ _. count/closed-equiv (Sg A B) Empty (Equiv/Equiv-Sg-empty B) (count/zero-count)
    suc k -> \ e.
      let f : Fin (suc k) -> A = (Equiv/map (Fin (suc k)) A e) in
        count/closed-equiv (Sg A B) (Coprod (Sg (Fin k) (\ x. B (f (inl x)))) (B (f (inr star)))) ? -- Sg A B ~ Sg (Fin k + 1) B o e ~ (Sg (Fin k) B o e o inl) + B(e(inr(star)))
          (count/closed-Coprod (Sg (Fin k) (\ x. B (f (inl x))))
                               (B (f (inr star))) (count/closed-Sg/sg (Fin k) (\ x. B (f (inl x))) (\ x. H (f (inl x))) k (Equiv/refl (Fin k))))

  -- count/closed-Sg (A : U) (B : A -> U) (cA : count A) (H : (x : A) -> count (B x)) : count (Sg A B) =
#+end_src

#+RESULTS:
: Typecheck has succeeded.

*** Characterization of countings for product
