module Lib.SetTrunc where

import Lib.Prop.Levels
import Lib.PropTrunc

precomp-Set (A : U) (B : UU-Set) (f : A -> (Set/type B)) (C : UU-Set) (g : Set/hom B C) : A -> Set/type C =
  \ z. g (f z)

is-set-trunc (A : U) (B : UU-Set) (f : A -> (Set/type B)) : U =
  (C : UU-Set) -> is-equiv (Set/hom B C) (A -> Set/type C) (precomp-Set A B f C)

is-set-trunc/map (A : U) (B : UU-Set) (f : A -> Set/type B) (H : is-set-trunc A B f) (C : UU-Set) (g : A -> Set/type C) : Set/hom B C =
  (H C g).1.1

data Set-trunc (A : U) : U
  = Set-trunc/unit (a : A)
  | Set-trunc/squash (x y : Set-trunc A) (p q : Path (Set-trunc A) x y) <i j> [(i=0) -> p j, (i=1) -> q j, (j=0) -> x, (j=1) -> y]

Set-trunc/is-set (A : U) : is-set (Set-trunc A) =
  \ x y p q i j. Set-trunc/squash x y p q i j

Set-trunc/Set (A : U) : UU-Set =
  (Set-trunc A, Set-trunc/is-set A)

rec-Set-trunc (A : U) (B : UU-Set) (f : A -> Set/type B) : Set-trunc A -> Set/type B = split
  Set-trunc/unit a -> f a
  Set-trunc/squash x y p q i j ->
    ( Set/is-set B
      ( rec-Set-trunc A B f x)
      ( rec-Set-trunc A B f y)
      ( ap ( Set-trunc A) ( Set/type B) ( rec-Set-trunc A B f) x y p)
      ( ap ( Set-trunc A) ( Set/type B) ( rec-Set-trunc A B f) x y q)) i j

rec-Set-trunc/Prop (A : U) (B : UU-Prop) (f : A -> Prop/type B) : Set-trunc A -> Prop/type B =
  rec-Set-trunc A
    ( Prop/Set B) f

-- ind-Set-trunc (A : U) (B : (x : Set-trunc A) -> UU-Set) (f : (x : A) -> Set/type (B (Set-trunc/unit x))) : (x : Set-trunc A) -> Set/type (B x) = split
--   Set-trunc/unit a -> f a
--   Set-trunc/squash x y p q i j ->
--     Set/is-set
--       ( B y)
--       ( tr (Set-trunc A) x y p (\ z. Set/type (B z)) (ind-Set-trunc A B f x))
--       ( ind-Set-trunc A B f y)
--       ( apd (Set-trunc A) (\ z. Set/type (B z)) (ind-Set-trunc A B f) x y p)
--       ( apd (Set-trunc A) (\ z. Set/type (B z)) (ind-Set-trunc A B f) x y q) i j

Set-trunc/is-set-trunc/right-htpy (X : U) (Y : UU-Set) (h : X -> Set/type Y)
                                     : Path (X -> Set/type Y)
                                            (precomp-Set X (Set-trunc/Set X) (\ z. Set-trunc/unit z) Y (rec-Set-trunc X Y h)) h =
  refl (X -> Set/type Y) h

--   rinv f i x =
--    elim (λ x → isProp→isSet (Bset (rec Bset (λ x → f ∣ x ∣₂) x) (f x)))
--         (λ _ → refl) x i

-- Set-trunc/is-set-trunc/left-htpy (X : U) (Y : UU-Set) (h : (Set-trunc X) -> Set/type Y)
--                                      : Path (Set-trunc X -> Set/type Y)
--                                             (rec-Set-trunc X Y (precomp-Set X (Set-trunc/Set X) (\ z. Set-trunc/unit z) Y h)) h =
--   \ i x.

-- Set-trunc/is-set-trunc (X : U) : is-set-trunc X (Set-trunc X) (\ x. Set-trunc/unit x) =

Set-trunc/map (A B : U) (f : A -> B) : (Set-trunc A) -> Set-trunc B =
  rec-Set-trunc A
    ( Set-trunc/Set B)
    ( \ x. Set-trunc/unit (f x))

Set-trunc/eq/Prop (X : U) (x y : Set-trunc X) : UU-Prop =
  ( Path (Set-trunc X) x y,
    Set-trunc/is-set X x y)

Set/Set-trunc/map (X : UU-Set) : Set-trunc (Set/type X) -> Set/type X =
  rec-Set-trunc
    ( Set/type X) X
    ( id (Set/type X))

Prop/Set-trunc/map (X : UU-Prop) : Set-trunc (Prop/type X) -> Prop/type X =
  Set/Set-trunc/map
    ( Prop/Set X)

Set/Equiv-Set-trunc/left-htpy (X : UU-Set) (x : Set/type X)
                                 : Path (Set/type X) (Set/Set-trunc/map X (Set-trunc/unit x)) x =
  refl (Set/type X) x

Set-trunc-unit/inj (X : UU-Set) (x y : Set/type X) (p : Path (Set-trunc (Set/type X)) (Set-trunc/unit x) (Set-trunc/unit y)) : Path (Set/type X) x y =
  ap (Set-trunc (Set/type X)) (Set/type X) (Set/Set-trunc/map X) (Set-trunc/unit x) (Set-trunc/unit y) p

-- Set/Equiv-Set-trunc/right-htpy (X : UU-Set) : (x : Set-trunc (Set/type X))
--                                             -> Path (Set-trunc (Set/type X)) (Set-trunc/unit (Set/Set-trunc/map X x)) x =
--   htpy-eq'
--     ( Set-trunc (Set/type X))
--     ( Set-trunc (Set/type X))
--     ( \ z. (Set-trunc/unit (Set/Set-trunc/map X z)))
--     ( id (Set-trunc (Set/type X)))
--     ( \ i.
--       ( ( ? -- universal property
--           ( \ z. Set-trunc/unit (Set/Set-trunc/map X z),
--             \ z. ap (Set/type X) (Set-trunc (Set/type X)) (\ y. Set-trunc/unit y) (Set/Set-trunc/map X (Set-trunc/unit x)) x (Set/Equiv-Set-trunc/left-htpy X z))
--           ( id (Set-trunc (Set/type X)),
--             Hpy'/refl (Set-trunc (Set/type X)) (Set-trunc (Set/type X)) (id (Set-trunc (Set/type X))))) i).1)

Set-trunc/mere-eq/eq (X : U) (x y : X) (p : mere-eq X x y) : Path (Set-trunc X) (Set-trunc/unit x) (Set-trunc/unit y) =
  rec-Prop-trunc
    ( Path X x y)
    ( Set-trunc/eq/Prop X
      ( Set-trunc/unit x)
      ( Set-trunc/unit y))
    ( J X x
      ( \ z _. Path (Set-trunc X) (Set-trunc/unit x) (Set-trunc/unit z))
      ( refl (Set-trunc X) (Set-trunc/unit x)) y) p

Set-trunc/Path (A B : U) (p : Path U A B) : Path U (Set-trunc A) (Set-trunc B) =
  \ i. Set-trunc (p i)

Set-trunc/Equiv (A B : U) (e : Equiv A B) : Equiv (Set-trunc A) (Set-trunc B) =
  path-to-equiv
    ( Set-trunc A)
    ( Set-trunc B)
    ( Set-trunc/Path A B
      ( equiv-to-path A B e))

Set-trunc/Equiv/map (A B : U) (e : Equiv A B) : (Set-trunc A) -> (Set-trunc B) =
  Equiv/map
    ( Set-trunc A)
    ( Set-trunc B)
    ( Set-trunc/Equiv A B e)

Set-trunc/Equiv/inv-map (A B : U) (e : Equiv A B) : (Set-trunc B) -> (Set-trunc A) =
  Equiv/inv-map
    ( Set-trunc A)
    ( Set-trunc B)
    ( Set-trunc/Equiv A B e)

Set-trunc/prod/map (A B : U) (t : (Set-trunc A) * (Set-trunc B)) : Set-trunc (A * B) =
  rec-Set-trunc A
    ( Set-trunc/Set (A * B))
    ( \ x. rec-Set-trunc B
          ( Set-trunc/Set (A * B))
          ( \ y. Set-trunc/unit (x, y)) t.2) t.1

Set-trunc/prod/inv-map (A B : U) (t : Set-trunc (A * B)) : (Set-trunc A) * (Set-trunc B) =
  rec-Set-trunc (A * B)
    ( Set/closed-Prod
      ( Set-trunc/Set A)
      ( Set-trunc/Set B))
    ( \ u. (Set-trunc/unit u.1, Set-trunc/unit u.2)) t

-- Set-trunc/prod/right-htpy (A B : U) (t : Set-trunc (A * B))
--                                : Path (Set-trunc (A * B))
--                                       (Set-trunc/prod/map A B (Set-trunc/prod/inv-map A B t)) t =

Set-trunc/closed-Path (A : U) (x y : A) (p : Path A x y) : Path (Set-trunc A) (Set-trunc/unit x) (Set-trunc/unit y) =
  \ i. Set-trunc/unit (p i)

Set-trunc/closed-contr/aux (A : U) (is-contr-A : is-contr A) (x : A) : Path (Set-trunc A) (Set-trunc/unit (center A is-contr-A)) (Set-trunc/unit x) =
  Set-trunc/closed-Path A
    ( center A is-contr-A) x
    ( contraction A is-contr-A x)

-- Set-trunc/closed-contr (A : U) (is-contr-A : is-contr A) : is-contr (Set-trunc A) =
--   ( Set-trunc/unit (center A is-contr-A),
--     \ x.
--       rec-Set-trunc/Prop A
--         ( Set-trunc/eq/Prop A
--           ( Set-trunc/unit (center A is-contr-A)) x)
--  x)

is-conn (A : U) : U =
  is-contr (Set-trunc A)

is-conn/is-inhabited (A : U) (is-conn-A : is-conn A) : Prop-trunc A =
  rec-Set-trunc A
    ( Prop/Set (Prop-trunc/Prop A))
    ( \ x. Prop-trunc/unit x)
    ( center (Set-trunc A) is-conn-A)

-- is-conn/mere-eq (A : U) (is-conn-A : is-conn A) (x y : A) : mere-eq A x y =

fiber-inclusion (A : U) (B : A -> U) (a : A) : B a -> Sg A B =
  \ b. (a, b)

-- fiber-inclusion/is-surj/sg (A : U) (B : A -> U) (a : A) (is-conn-A : is-conn A) (x : A) (y : B x) : Prop-trunc (Fib A B f (x, y)) =
--   Prop-trunc/map
--     ( Prop-trunc (Path A a x))
--     ( Prop-trunc (Fib A B f (x, y)))
--     ( \ p.  )
--     ( is-conn/is-inhabited A is-conn-A) -- no

-- fiber-inclusion/is-surj (A : U) (B : A -> U) (a : A) (is-conn-A : is-conn A) : is-surj (B a) (Sg A B) (fiber-inclusion A B a) =
--   \ t. fiber-inclusion/is-surj/sg A B a is-conn-A t.1 t.2
