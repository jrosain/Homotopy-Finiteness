#+NAME: ActionPaths
#+AUTHOR: Johann Rosain

* Action on Paths (AP) Properties

  #+begin_src ctt
  module Lib.Prop.ActionPaths where
  #+end_src

This file states some useful properties of the function =ap=.

** Packages imports

   #+begin_src ctt
  import Lib.Prop.Comp
  import Lib.Data.BiInv
  import Lib.Data.Map  
  import Lib.Data.Nat
  import Lib.FunExt  
  import Lib.QInv
   #+end_src

** Properties

*** Identity
=ap id= is =id= for paths.
#+begin_src ctt
  ap/id (A : U) (x y : A) (p : Path A x y) : Path (Path A x y) p (ap A A (id A) x y p) =
    J A x (\ y' q. Path (Path A x y') q (ap A A (id A) x y' q))
          (refl (Path A x x) (refl A x)) y p

  ap/id' (A : U) (x y : A) (p : Path A x y) : Path (Path A x y) (ap A A (id A) x y p) p =
    inv (Path A x y) p (ap A A (id A) x y p) (ap/id A x y p)
#+end_src

*** Composition
ap g \circ ap f is ap (g \circ f).
#+begin_src ctt
  ap/comp (A B C : U) (f : A -> B) (g : B -> C) (x y : A) (p : Path A x y)
                 : Path (Path C (g (f x)) (g (f y))) (ap B C g (f x) (f y) (ap A B f x y p)) (ap A C (map/comp A B C g f) x y p) =
    J A x (\ z q. Path (Path C (g (f x)) (g (f z))) (ap B C g (f x) (f z) (ap A B f x z q)) (ap A C (map/comp A B C g f) x z q))
          (refl (Path C (g (f x)) (g (f x))) (refl C (g (f x)))) y p

  ap/comp' (A B C : U) (f : A -> B) (g : B -> C) (x y : A) (p : Path A x y)
                 : Path (Path C (g (f x)) (g (f y))) (ap A C (map/comp A B C g f) x y p) (ap B C g (f x) (f y) (ap A B f x y p)) =
    inv (Path C (g (f x)) (g (f y))) (ap B C g (f x) (f y) (ap A B f x y p)) (ap A C (map/comp A B C g f) x y p) (ap/comp A B C f g x y p)
#+end_src

*** Inverse
ap f p^-1 is (ap f p)^-1.
#+begin_src ctt
  ap/refl/refl (A B : U) (f : A -> B) (x : A) : Path (Path B (f x) (f x)) (ap A B f x x (inv A x x (refl A x)))
                                                                         (ap A B f x x (refl A x)) =
    ap (Path A x x) (Path B (f x) (f x)) (ap A B f x x) (inv A x x (refl A x)) (refl A x) (inv/refl A x)

  ap/inv (A B : U) (f : A -> B) (x y : A) (p : Path A x y)
              : Path (Path B (f y) (f x)) (ap A B f y x (inv A x y p)) (inv B (f x) (f y) (ap A B f x y p)) =
    J A x (\ z q. Path (Path B (f z) (f x)) (ap A B f z x (inv A x z q)) (inv B (f x) (f z) (ap A B f x z q)))
          (comp (Path B (f x) (f x)) (ap A B f x x (inv A x x (refl A x)))
                                     (ap A B f x x (refl A x)) (ap/refl/refl A B f x)
                                     (inv B (f x) (f x) (refl B (f x))) (refl/sym B (f x))) y p
#+end_src

*** Path concatenation
=ap f (comp p q)= is =comp (ap f p) (ap f q)=.
#+begin_src ctt
  ap/concat (A B : U) (f : A -> B) (x y z : A) (p : Path A x y) (q : Path A y z)
                 : Path (Path B (f x) (f z)) (ap A B f x z (comp A x y p z q))
                                           (comp B (f x) (f y) (ap A B f x y p) (f z) (ap A B f y z q)) =
    J A y (\ t r. Path (Path B (f x) (f t)) (ap A B f x t (comp A x y p t r))
                                            (comp B (f x) (f y) (ap A B f x y p) (f t) (ap A B f y t r)))
              (comp (Path B (f x) (f y)) (ap A B f x y (comp A x y p y (refl A y)))
                                         (ap A B f x y p) (ap (Path A x y) (Path B (f x) (f y)) (ap A B f x y) (comp A x y p y (refl A y)) p (comp/ident-r A x y p))
                                         (comp B (f x) (f y) (ap A B f x y p) (f y) (refl B (f y))) (refl/comp-r B (f x) (f y) (ap A B f x y p)))
      z q
#+end_src

*** Closure under homotopies
We show that if f \sim g, then =ap f= and =ap g= can be used in further computations, by something called the /naturality square/. We proceed by path induction and need to use the composition properties of =Prelude= as the judgmental equality in cubical is different than judgmental equality of HoTT.
#+begin_src ctt
  naturality (A B : U) (f g : A -> B) (H : Htpy' A B f g) (x y : A) (p : Path A x y)
                  : Path (Path B (f x) (g y)) (comp B (f x) (g x) (H x) (g y) (ap A B g x y p))
                                              (comp B (f x) (f y) (ap A B f x y p) (g y) (H y)) =
    J A x (\ z q. Path (Path B (f x) (g z)) (comp B (f x) (g x) (H x) (g z) (ap A B g x z q))
                                           (comp B (f x) (f z) (ap A B f x z q) (g z) (H z)))
          (comp (Path B (f x) (g x)) (comp B (f x) (g x) (H x) (g x) (refl B (g x))) (H x)
                                     (comp/ident-r B (f x) (g x) (H x)) (comp B (f x) (f x) (refl B (f x)) (g x) (H x))
                                     (comp/ident-l' B (f x) (g x) (H x))) y p

  naturality' (A B : U) (f g : A -> B) (H : Htpy' A B f g) (x y : A) (p : Path A x y)
                   : Path (Path B (f x) (g y)) (comp B (f x) (f y) (ap A B f x y p) (g y) (H y))
                                               (comp B (f x) (g x) (H x) (g y) (ap A B g x y p)) =
    inv (Path B (f x) (g y)) (comp B (f x) (g x) (H x) (g y) (ap A B g x y p)) (comp B (f x) (f y) (ap A B f x y p) (g y) (H y))
        (naturality A B f g H x y p)
#+end_src

*** Closure of bi-invertibility 
If =f= is bi-invertible, then =ap f= is bi-invertible aswell.

**** Map
Indeed, if \alpha is the homotopy f^-1 \circ f \sim id, then the inverse of =ap f= is the concatenation of \alpha^-1 x, ap f^-1 q, \alpha y where q : x = y.
#+begin_src ctt
  ap/closure-bi-inv-inv-map (A B : U) (f : A -> B) (b : is-bi-inv A B f) (x y : A) (p : Path B (f x) (f y)) : Path A x y =
    let g : B -> A = is-bi-inv/inv-map A B f b
        H : Htpy' A A (\ z. g (f z)) (id A) = is-bi-inv/inv-left-htpy A B f b
    in
    comp-n A three-Nat x (g (f x)) (inv A (g (f x)) x (H x))
                     (g (f y)) (ap B A g (f x) (f y) p)
                     y (H y)
#+end_src

**** Left inverse
First, we show that it is the left inverse of =ap f=. To do so, remark that (ap f (ap f^-1 p)) is (ap (f \circ f^-1) p). Then, using the naturality square is enough to conclude. The code is somewhat tedious, but what is happening is clear:

  (H x)^-1 \cdot (ap f^-1 (ap f p)) \cdot (H y) --(ap + ap-comp)--> ((H x)^-1 \cdot (ap (f^-1 \circ f) p)) \cdot (H y)
                                     --(assoc)--> (H x)^-1 \cdot ((ap (f^-1 \circ f) p) \cdot (H y))
                                     --(naturality)--> (H x)^-1 \cdot ((H x) \cdot (ap id p))
                                     --(assoc)--> ((H x)^-1 \cdot (H x)) \cdot (ap id p)
                                     --(ap + inverses cancel)--> refl \cdot ap id p
                                     --(refl-identity)--> ap id p
                                     --(ap-id)--> p
#+begin_src ctt
  ap/closure-bi-inv-left-htpy (A B : U) (f : A -> B) (b : is-bi-inv A B f) (x y : A)
                                   : Htpy' (Path A x y) (Path A x y) (\ p. (ap/closure-bi-inv-inv-map A B f b x y) ((ap A B f x y p))) (id (Path A x y)) =
    \ p.
      let g : B -> A = is-bi-inv/inv-map A B f b
          H : Htpy' A A (\ z . g (f z)) (id A) = is-bi-inv/inv-left-htpy A B f b
          h : Path A (g (f x)) (g (f y)) -> Path A x y = \ q. (comp-n A three-Nat x (g (f x)) (inv A (g (f x)) x (H x))
                                                                                  (g (f y)) q
                                                                                   y (H y))
          assoc1 : Path A x y = (comp A x (g (f x)) (inv A (g (f x)) x (H x)) y (comp A (g (f x)) (g (f y)) (ap B A g (f x) (f y) (ap A B f x y p)) y (H y)))
          nat : Path A x y = comp A x (g (f x)) (inv A (g (f x)) x (H x)) y (comp A (g (f x)) x (H x) y (ap A A (id A) x y p))
          assoc2 : Path A x y = comp-n A three-Nat x (g (f x)) (inv A (g (f x)) x (H x)) x (H x) y (ap A A (id A) x y p)
          q1 : Path (Path A x y) ((ap/closure-bi-inv-inv-map A B f b x y) (ap A B f x y p)) (h (ap A A (\ z. (g (f z))) x y p))
                                  = ap (Path A (g (f x)) (g (f y))) (Path A x y) h (ap B A g (f x) (f y) (ap A B f x y p)) (ap A A (\ z. g (f z)) x y p) (ap/comp A B A f g x y p)
          q2 : Path (Path A x y) (h (ap A A (\ z. (g (f z))) x y p)) assoc1
                                  = comp/assoc A x (g (f x)) (inv A (g (f x)) x (H x)) (g (f y)) (ap B A g (f x) (f y) (ap A B f x y p)) y (H y)
          q3 : Path (Path A x y) assoc1 nat
                                  = ap (Path A (g (f x)) y) (Path A x y) (\ q. comp A x (g (f x)) (inv A (g (f x)) x (H x)) y q)
                                       (comp A (g (f x)) (g (f y)) (ap B A g (f x) (f y) (ap A B f x y p)) y (H y))
                                       (comp A (g (f x)) x (H x) y (ap A A (id A) x y p)) (naturality' A A (\ z. g (f z)) (id A) H x y p)
          q4 : Path (Path A x y) nat assoc2
                                  = inv (Path A x y) assoc2 nat
                                        (comp/assoc A x (g (f x)) (inv A (g (f x)) x (H x)) x (H x) y (ap A A (id A) x y p))
          q5 : Path (Path A x y) assoc2 (comp A x x (refl A x) y (ap A A (id A) x y p))
                                  = ap (Path A x x) (Path A x y) (\ q. comp A x x q y (ap A A (id A) x y p))
                                       (comp A x (g (f x)) (inv A (g (f x)) x (H x)) x (H x)) (refl A x)
                                       (comp/inv-l A (g (f x)) x (H x))
          q6 : Path (Path A x y) (comp A x x (refl A x) y (ap A A (id A) x y p)) (ap A A (id A) x y p)
                                  = comp/ident-l A x y (ap A A (id A) x y p)
          q7 : Path (Path A x y) (ap A A (id A) x y p) p =
                                  ap/id' A x y p
      in comp-n (Path A x y) seven-Nat ((ap/closure-bi-inv-inv-map A B f b x y) (ap A B f x y p))
                                       (h (ap A A (\ z. (g (f z))) x y p)) q1
                                       assoc1 q2
                                       nat q3
                                       assoc2 q4
                                       (comp A x x (refl A x) y (ap A A (id A) x y p)) q5
                                       (ap A A (id A) x y p) q6
                                       p q7
#+end_src

**** Right inverse
We now show that it is the right inverse of =ap f=. We proceed in multiple steps, as the proof is way more involved.

***** 1^st step: concat
First, we make =G (f x)= and =G (f y)= appear by concatenating left by G (f x)^-1 \cdot G (f x) and right by G (f y)^-1 \cdot G (f y).
#+begin_src ctt
  ap/closure-bi-inv-right-htpy-path1 (A B : U) (f : A -> B) (g : B -> A) (H : Htpy' A A (\ z. g (f z)) (id A))
                                     (G : Htpy' B B (\ z. f (g z)) (id B)) (x y : A) (q : Path B (f x) (f y)) : Path B (f x) (f y) =
    (ap A B f x y (comp-n A three-Nat x (g (f x)) (inv A (g (f x)) x (H x))
                                        (g (f y)) (ap B A g (f x) (f y) q) y (H y)))

  ap/closure-bi-inv-right-htpy-path2 (A B : U) (f : A -> B) (g : B -> A) (H : Htpy' A A (\ z. g (f z)) (id A))
                                     (G : Htpy' B B (\ z. f (g z)) (id B)) (x y : A) (q : Path B (f x) (f y)) : Path B (f x) (f y) =
    (comp B (f x) (f (g (f x))) (inv B (f (g (f x))) (f x) (G (f x)))
            (f y) (comp B (f (g (f x))) (f y)
                          (comp B (f (g (f x))) (f x) (G (f x))
                                  (f y) (ap/closure-bi-inv-right-htpy-path1 A B f g H G x y q))
                          (f y)
                          (comp B (f y) (f (g (f y))) (inv B (f (g (f y))) (f y) (G (f y)))
                                  (f y) (G (f y)))))

  ap/closure-bi-inv-right-htpy-step1 (A B : U) (f : A -> B) (g : B -> A) (H : Htpy' A A (\ z. g (f z)) (id A))
                                      (G : Htpy' B B (\ z. f (g z)) (id B)) (x y : A) (q : Path B (f x) (f y))
                                         : Path (Path B (f x) (f y)) (ap/closure-bi-inv-right-htpy-path1 A B f g H G x y q)
                                                                     (ap/closure-bi-inv-right-htpy-path2 A B f g H G x y q) =
    let invG : (z : A) -> Path B (f z) (f (g (f z))) = \ z. inv B (f (g (f z))) (f z) (G (f z))
        concat : (z : A) -> Path B (f z) (f z) = \ z. comp B (f z) (f (g (f z))) (invG z) (f z) (G (f z))
        i1 : Path B (f x) (f y) = comp B (f x) (f y) (ap/closure-bi-inv-right-htpy-path1 A B f g H G x y q) (f y) (refl B (f y))
        i2 : Path B (f x) (f y) = comp B (f x) (f y) (ap/closure-bi-inv-right-htpy-path1 A B f g H G x y q) (f y) (concat y)
        i3 : Path B (f x) (f y) = comp B (f x) (f x) (refl B (f x)) (f y) i2
        i4 : Path B (f x) (f y) = comp B (f x) (f x) (concat x) (f y) i2
        i5 : Path B (f x) (f y) = comp B (f x) (f (g (f x))) (invG x) (f y) (comp B (f (g (f x))) (f x) (G (f x)) (f y) i2)
    in comp-n (Path B (f x) (f y)) six-Nat
          (ap/closure-bi-inv-right-htpy-path1 A B f g H G x y q) i1 (refl/comp-r B (f x) (f y) (ap/closure-bi-inv-right-htpy-path1 A B f g H G x y q))
          i2 (ap (Path B (f y) (f y)) (Path B (f x) (f y)) (\ p. comp B (f x) (f y) (ap/closure-bi-inv-right-htpy-path1 A B f g H G x y q) (f y) p)
                 (refl B (f y)) (comp B (f y) (f (g (f y))) (inv B (f (g (f y))) (f y) (G (f y))) (f y) (G (f y)))
                 (inv (Path B (f y) (f y)) (comp B (f y) (f (g (f y))) (inv B (f (g (f y))) (f y) (G (f y))) (f y) (G (f y))) (refl B (f y)) (comp/inv-l B (f (g (f y))) (f y) (G (f y)))))
          i3 (comp/ident-l' B (f x) (f y) i2)
          i4 (ap (Path B (f x) (f x)) (Path B (f x) (f y)) (\ p. comp B (f x) (f x) p (f y) i2)
                 (refl B (f x)) (comp B (f x) (f (g (f x))) (inv B (f (g (f x))) (f x) (G (f x))) (f x) (G (f x))) 
                 (inv (Path B (f x) (f x)) (comp B (f x) (f (g (f x))) (inv B (f (g (f x))) (f x) (G (f x))) (f x) (G (f x))) (refl B (f x)) (comp/inv-l B (f (g (f x))) (f x) (G (f x)))))
          i5 (comp/assoc B (f x) (f (g (f x))) (invG x) (f x) (G (f x)) (f y) i2)
          (ap/closure-bi-inv-right-htpy-path2 A B f g H G x y q)
                (ap (Path B (f (g (f x))) (f y)) (Path B (f x) (f y)) (\ p. comp B (f x) (f (g (f x))) (invG x) (f y) p)
                    (comp B (f (g (f x))) (f x) (G (f x)) (f y) i2)
                    (comp B (f (g (f x))) (f y) (comp B (f (g (f x))) (f x) (G (f x)) (f y) (ap/closure-bi-inv-right-htpy-path1 A B f g H G x y q))
                                                                                      (f y) (concat y))
                    (inv (Path B (f (g (f x))) (f y)) (comp B (f (g (f x))) (f y) (comp B (f (g (f x))) (f x) (G (f x)) (f y) (ap/closure-bi-inv-right-htpy-path1 A B f g H G x y q))
                                                                                                        (f y) (concat y))
                                                      (comp B (f (g (f x))) (f x) (G (f x)) (f y) i2) 
                           (comp/assoc B (f (g (f x))) (f x) (G (f x)) (f y) (ap/closure-bi-inv-right-htpy-path1 A B f g H G x y q) (f y) (concat y))))
#+end_src

***** 2^nd step: naturality
We make the inner =G (f x)= and =G (f y)= disappear using naturality + inverses cancel.
#+begin_src ctt
  ap/closure-bi-inv-right-htpy-path3 (A B : U) (f : A -> B) (g : B -> A) (H : Htpy' A A (\ z. g (f z)) (id A))
                                     (G : Htpy' B B (\ z. f (g z)) (id B)) (x y : A) (q : Path B (f x) (f y)) : Path B (f x) (f y) =
    comp B (f x) (f (g (f x))) (inv B (f (g (f x))) (f x) (G (f x))) (f y)
                               (comp B (f (g (f x))) (f (g (f y)))
                                       (ap A B f (g (f x)) (g (f y)) (ap B A g (f x) (f y) (ap/closure-bi-inv-right-htpy-path1 A B f g H G x y q)))
                                       (f y) (G (f y)))

  ap/closure-bi-inv-right-htpy-step2 (A B : U) (f : A -> B) (g : B -> A) (H : Htpy' A A (\ z. g (f z)) (id A))
                                     (G : Htpy' B B (\ z. f (g z)) (id B)) (x y : A) (q : Path B (f x) (f y))
                                         : Path (Path B (f x) (f y)) (ap/closure-bi-inv-right-htpy-path2 A B f g H G x y q)
                                                                     (ap/closure-bi-inv-right-htpy-path3 A B f g H G x y q) =
    let invG : (z : A) -> Path B (f z) (f (g (f z))) = \ z. inv B (f (g (f z))) (f z) (G (f z))
        concat : (z : A) -> Path B (f z) (f z) = \ z. comp B (f z) (f (g (f z))) (invG z) (f z) (G (f z))
        i1 : Path B (f x) (f y) = (comp B (f x) (f (g (f x))) (invG x)
                                          (f y) (comp B (f (g (f x))) (f y)
                                                (comp B (f (g (f x))) (f x) (G (f x))
                                                                      (f y) (ap B B (id B) (f x) (f y) (ap/closure-bi-inv-right-htpy-path1 A B f g H G x y q)))
                                                (f y) (concat y)))
        i2 : Path B (f x) (f y) = (comp B (f x) (f (g (f x))) (invG x)
                                          (f y) (comp B (f (g (f x))) (f y)
                                                        (comp B (f (g (f x))) (f (g (f y)))
                                                                (ap B B (\ z. f (g z)) (f x) (f y) (ap/closure-bi-inv-right-htpy-path1 A B f g H G x y q))
                                                                (f y) (G (f y)))
                                                        (f y) (concat y)))
        i3 : Path B (f x) (f y) = (comp B (f x) (f (g (f x))) (invG x)
                                          (f y) (comp B (f (g (f x))) (f y)
                                                        (comp B (f (g (f x))) (f (g (f y)))
                                                                (ap B B (\ z. f (g z)) (f x) (f y) (ap/closure-bi-inv-right-htpy-path1 A B f g H G x y q))
                                                                (f y) (G (f y)))
                                                        (f y) (refl B (f y))))
        i4 : Path B (f x) (f y) = comp B (f x) (f (g (f x))) (invG x) (f y)
                                         (comp B (f (g (f x))) (f (g (f y))) (ap B B (\ z. f (g z)) (f x) (f y) (ap/closure-bi-inv-right-htpy-path1 A B f g H G x y q)) (f y) (G (f y)))
    in comp-n (Path B (f x) (f y)) five-Nat
          (ap/closure-bi-inv-right-htpy-path2 A B f g H G x y q) i1
          (ap (Path B (f x) (f y)) (Path B (f x) (f y)) (\ p. (comp B (f x) (f (g (f x))) (invG x)
                                                               (f y) (comp B (f (g (f x))) (f y) (comp B (f (g (f x))) (f x) (G (f x)) (f y) p) (f y) (concat y))))
              (ap/closure-bi-inv-right-htpy-path1 A B f g H G x y q) (ap B B (id B) (f x) (f y) (ap/closure-bi-inv-right-htpy-path1 A B f g H G x y q))
              (ap/id B (f x) (f y) (ap/closure-bi-inv-right-htpy-path1 A B f g H G x y q)))
        i2
          (ap (Path B (f (g (f x))) (f y)) (Path B (f x) (f y)) (\ p. (comp B (f x) (f (g (f x))) (invG x) (f y) (comp B (f (g (f x))) (f y) p (f y) (concat y))))
              (comp B (f (g (f x))) (f x) (G (f x)) (f y)
                            (ap B B (id B) (f x) (f y) (ap/closure-bi-inv-right-htpy-path1 A B f g H G x y q)))
              (comp B (f (g (f x))) (f (g (f y))) (ap B B (\ z. f (g z)) (f x) (f y) (ap/closure-bi-inv-right-htpy-path1 A B f g H G x y q)) (f y) (G (f y)))
              (naturality B B (\ z. f (g z)) (id B) G (f x) (f y) (ap/closure-bi-inv-right-htpy-path1 A B f g H G x y q)))
        i3
          (ap (Path B (f y) (f y)) (Path B (f x) (f y)) (\ p. comp B (f x) (f (g (f x))) (invG x) (f y)
                                                                (comp B (f (g (f x))) (f y)
                                                                  (comp B (f (g (f x))) (f (g (f y))) (ap B B (\ z. f (g z)) (f x) (f y) (ap/closure-bi-inv-right-htpy-path1 A B f g H G x y q)) (f y) (G (f y)))
                                                                  (f y) p))
              (concat y) (refl B (f y)) (comp/inv-l B (f (g (f y))) (f y) (G (f y))))
        i4
          (ap (Path B (f (g (f x))) (f y)) (Path B (f x) (f y)) (\ p. comp B (f x) (f (g (f x))) (invG x) (f y) p)
              (comp B (f (g (f x))) (f y) (comp B (f (g (f x))) (f (g (f y))) (ap B B (\ z. f (g z)) (f x) (f y) (ap/closure-bi-inv-right-htpy-path1 A B f g H G x y q))
                                                  (f y) (G (f y))) (f y) (refl B (f y)))
              (comp B (f (g (f x))) (f (g (f y))) (ap B B (\ z. f (g z)) (f x) (f y) (ap/closure-bi-inv-right-htpy-path1 A B f g H G x y q)) (f y) (G (f y)))
              (comp/ident-r B (f (g (f x))) (f y) (comp B (f (g (f x))) (f (g (f y))) (ap B B (\ z. f (g z)) (f x) (f y) (ap/closure-bi-inv-right-htpy-path1 A B f g H G x y q)) (f y) (G (f y)))))
        (ap/closure-bi-inv-right-htpy-path3 A B f g H G x y q)
          (ap (Path B (f (g (f x))) (f (g (f y)))) (Path B (f x) (f y)) (\ p. comp B (f x) (f (g (f x))) (invG x) (f y) (comp B (f (g (f x))) (f (g (f y))) p (f y) (G (f y))))
              (ap B B (\ z. f (g z)) (f x) (f y) (ap/closure-bi-inv-right-htpy-path1 A B f g H G x y q))
              (ap A B f (g (f x)) (g (f y)) (ap B A g (f x) (f y) (ap/closure-bi-inv-right-htpy-path1 A B f g H G x y q)))
              (ap/comp' B A B g f (f x) (f y) (ap/closure-bi-inv-right-htpy-path1 A B f g H G x y q)))
#+end_src

***** 3^rd step: left inverse
We use the fact that the map we have defined is the left inverse to remove most things and get something that is close to what we had at the start of the left inverse. First, we transform (ap f^-1 (ap f p)) to (H x) \cdot p \cdot (H y)^-1 using the left inverse. All the steps are trivial (associativity, concatenation of inverses is identity) but it is still quite the hassle to do.
#+begin_src ctt
  ap/closure-bi-inv-left-htpy' (A B : U) (f : A -> B) (b : is-bi-inv A B f)
                               (x y : A) (p : Path A x y) : Path (Path A ((is-bi-inv/inv-map A B f b) (f x)) ((is-bi-inv/inv-map A B f b) (f y)))
                                                                 (ap B A (is-bi-inv/inv-map A B f b) (f x) (f y) (ap A B f x y p))
                                                                 (comp A ((is-bi-inv/inv-map A B f b) (f x)) x ((is-bi-inv/inv-left-htpy A B f b) x) ((is-bi-inv/inv-map A B f b) (f y))
                                                                         (comp A x y p ((is-bi-inv/inv-map A B f b) (f y)) (inv A ((is-bi-inv/inv-map A B f b) (f y)) y
                                                                                        ((is-bi-inv/inv-left-htpy A B f b) y)))) =
    let g : B -> A = is-bi-inv/inv-map A B f b
        H : Htpy' A A (\ z. g (f z)) (id A) = is-bi-inv/inv-left-htpy A B f b
        G : Htpy' B B (\ z. f (g z)) (id B) = is-bi-inv/inv-right-htpy A B f b
        invH : (z : A) -> Path A z (g (f z)) = \ z. inv A (g (f z)) z (H z)
        concat : (z : A) -> Path A (g (f z)) (g (f z)) = \ z. comp A (g (f z)) z (H z) (g (f z)) (invH z)
        o  : Path A (g (f x)) (g (f y)) = (ap B A g (f x) (f y) (ap A B f x y p))
        i0 : Path A (g (f x)) (g (f y)) = comp A (g (f x)) (g (f x)) (refl A (g (f x))) (g (f y)) o
        i1 : Path A (g (f x)) (g (f y)) = comp A (g (f x)) (g (f x)) (concat x) (g (f y)) o
        i2 : Path A (g (f x)) (g (f y)) = comp A (g (f x)) (g (f y)) i1 (g (f y)) (refl A (g (f y)))
        i3 : Path A (g (f x)) (g (f y)) = comp A (g (f x)) (g (f y)) i1 (g (f y)) (concat y)
        i4 : Path A (g (f x)) (g (f y)) = comp A (g (f x)) (g (f y)) (comp A (g (f x)) x (H x) (g (f y)) (comp A x (g (f x)) (invH x) (g (f y)) o)) (g (f y)) (concat y)
        i5 : Path A (g (f x)) (g (f y)) = comp A (g (f x)) y (comp A (g (f x)) (g (f y)) (comp A (g (f x)) x (H x) (g (f y)) (comp A x (g (f x)) (invH x) (g (f y)) o)) y (H y))
                                                 (g (f y)) (invH y)
        i6 : Path A (g (f x)) (g (f y)) = comp A (g (f x)) y (comp A (g (f x)) x (H x) y (comp A x (g (f y)) (comp A x (g (f x)) (invH x) (g (f y)) o) y (H y))) (g (f y)) (invH y)
        i7 : Path A (g (f x)) (g (f y)) = comp A (g (f x)) y (comp A (g (f x)) x (H x) y p) (g (f y)) (invH y)
        goal : Path A (g (f x)) (g (f y)) = comp A (g (f x)) x (H x) (g (f y)) (comp A x y p (g (f y)) (invH y))
    in comp-n (Path A (g (f x)) (g (f y))) nine-Nat o i0 (comp/ident-l' A (g (f x)) (g (f y)) o)
                                                      i1 (ap (Path A (g (f x)) (g (f x))) (Path A (g (f x)) (g (f y))) (\ q. comp A (g (f x)) (g (f x)) q (g (f y)) o)
                                                             (refl A (g (f x))) (concat x) (comp/inv-r' A (g (f x)) x (H x)))
                                                      i2 (refl/comp-r A (g (f x)) (g (f y)) i1)
                                                      i3 (ap (Path A (g (f y)) (g (f y))) (Path A (g (f x)) (g (f y))) (\ q. comp A (g (f x)) (g (f y)) i1 (g (f y)) q)
                                                             (refl A (g (f y))) (concat y) (comp/inv-r' A (g (f y)) y (H y)))
                                                      i4 (ap (Path A (g (f x)) (g (f y))) (Path A (g (f x)) (g (f y))) (\ q. comp A (g (f x)) (g (f y)) q (g (f y)) (concat y))
                                                             i1 (comp A (g (f x)) x (H x) (g (f y)) (comp A x (g (f x)) (invH x) (g (f y)) o))
                                                             (comp/assoc A (g (f x)) x (H x) (g (f x)) (invH x) (g (f y)) o))
                                                      i5 (comp/assoc' A (g (f x)) (g (f y)) (comp A (g (f x)) x (H x) (g (f y)) (comp A x (g (f x)) (invH x) (g (f y)) o)) y (H y) (g (f y)) (invH y))
                                                      i6 (ap (Path A (g (f x)) y) (Path A (g (f x)) (g (f y))) (\ q. comp A (g (f x)) y q (g (f y)) (invH y))
                                                             (comp A (g (f x)) (g (f y)) (comp A (g (f x)) x (H x) (g (f y)) (comp A x (g (f x)) (invH x) (g (f y)) o)) y (H y))
                                                             (comp A (g (f x)) x (H x) y (comp A x (g (f y)) (comp A x (g (f x)) (invH x) (g (f y)) o) y (H y)))
                                                             (comp/assoc A (g (f x)) x (H x) (g (f y)) (comp A x (g (f x)) (invH x) (g (f y)) o) y (H y)))
                                                      i7 (ap (Path A x y) (Path A (g (f x)) (g (f y))) (\ q. comp A (g (f x)) y (comp A (g (f x)) x (H x) y q) (g (f y)) (invH y))
                                                             (comp A x (g (f y)) (comp A x (g (f x)) (invH x) (g (f y)) o) y (H y)) p
                                                             (ap/closure-bi-inv-left-htpy A B f b x y p))
                                                   goal (comp/assoc A (g (f x)) x (H x) y p (g (f y)) (invH y))
#+end_src
Then, using this property, we can transform (G (f x))^-1 \cdot ap f (ap f^-1 (ap f ((H x)^-1 \cdot ap f^-1 q \cdot (H y)))) \cdot (G (f y)) to (G (f x))^-1 \cdot ap f (ap f^-1 q) \cdot G (f y).
#+begin_src ctt
  ap/closure-bi-inv-right-htpy-path4 (A B : U) (f : A -> B) (b : is-bi-inv A B f) (x y : A) (q : Path B (f x) (f y)) : Path B (f x) (f y) =
    let g : B -> A = is-bi-inv/inv-map A B f b
        H : Htpy' A A (\ z. g (f z)) (id A) = is-bi-inv/inv-left-htpy A B f b
        G : Htpy' B B (\ z. f (g z)) (id B) = is-bi-inv/inv-right-htpy A B f b
        invG : (z : B) -> Path B z (f (g z)) = \ z. inv B (f (g z)) z (G z)
    in
    comp B (f x) (f (g (f x))) (invG (f x)) (f y) (comp B (f (g (f x))) (f (g (f y))) (ap A B f (g (f x)) (g (f y)) (ap B A g (f x) (f y) q)) (f y) (G (f y)))

  ap/closure-bi-inv-right-htpy-step3 (A B : U) (f : A -> B) (b : is-bi-inv A B f) (x y : A) (q : Path B (f x) (f y))
                                          : Path (Path B (f x) (f y))
                                                 (ap/closure-bi-inv-right-htpy-path3 A B f (is-bi-inv/inv-map A B f b) (is-bi-inv/inv-left-htpy A B f b) (is-bi-inv/inv-right-htpy A B f b) x y q)
                                                 (ap/closure-bi-inv-right-htpy-path4 A B f b x y q) =
    let g : B -> A = is-bi-inv/inv-map A B f b
        H : Htpy' A A (\ z. g (f z)) (id A) = is-bi-inv/inv-left-htpy A B f b
        G : Htpy' B B (\ z. f (g z)) (id B) = is-bi-inv/inv-right-htpy A B f b
        invG : (z : B) -> Path B z (f (g z)) = \ z. inv B (f (g z)) z (G z)
        invH : (z : A) -> Path A z (g (f z)) = \ z. inv A (g (f z)) z (H z)
        r : Path A x y = (comp-n A three-Nat x (g (f x)) (invH x) (g (f y)) (ap B A g (f x) (f y) q) y (H y))

        wrapper : Path A (g (f x)) (g (f y)) -> Path B (f x) (f y) = \ p. comp B (f x) (f (g (f x))) (invG (f x)) (f y)
                                                                               (comp B (f (g (f x))) (f (g (f y))) (ap A B f (g (f x)) (g (f y)) p) (f y) (G (f y)))

        i1 : Path A (g (f x)) (g (f y)) = (comp A (g (f x)) x (H x) (g (f y)) (comp A x y r (g (f y)) (invH y)))
        i2 : Path A (g (f x)) (g (f y)) = (comp A (g (f x)) x (H x) (g (f y)) (comp A x (g (f y)) (comp A x (g (f x)) (invH x) (g (f y)) (ap B A g (f x) (f y) q)) (g (f y))
                                                                                                  (comp A (g (f y)) y (H y) (g (f y)) (invH y))))
        i3 : Path A (g (f x)) (g (f y)) = (comp A (g (f x)) x (H x) (g (f y)) (comp A x (g (f y)) (comp A x (g (f x)) (invH x) (g (f y)) (ap B A g (f x) (f y) q)) (g (f y))
                                                                                                  (refl A (g (f y)))))
        i4 : Path A (g (f x)) (g (f y)) = (comp A (g (f x)) x (H x) (g (f y)) (comp A x (g (f x)) (invH x) (g (f y)) (ap B A g (f x) (f y) q)))
        i5 : Path A (g (f x)) (g (f y)) = (comp A (g (f x)) (g (f x)) (comp A (g (f x)) x (H x) (g (f x)) (invH x)) (g (f y)) (ap B A g (f x) (f y) q))
        i6 : Path A (g (f x)) (g (f y)) = (comp A (g (f x)) (g (f x)) (refl A (g (f x))) (g (f y)) (ap B A g (f x) (f y) q))

    in comp-n (Path B (f x) (f y)) seven-Nat (ap/closure-bi-inv-right-htpy-path3 A B f g H G x y q)
                                             (wrapper i1) (ap (Path A (g (f x)) (g (f y))) (Path B (f x) (f y)) wrapper
                                                              (ap B A g (f x) (f y) (ap A B f x y r)) i1
                                                              (ap/closure-bi-inv-left-htpy' A B f b x y r))
                                             (wrapper i2) (ap (Path A x (g (f y))) (Path B (f x) (f y)) (\ p. wrapper (comp A (g (f x)) x (H x) (g (f y)) p))
                                                              (comp A x y r (g (f y)) (invH y)) (comp A x (g (f y)) (comp A x (g (f x)) (invH x) (g (f y)) (ap B A g (f x) (f y) q)) (g (f y))
                                                                                                          (comp A (g (f y)) y (H y) (g (f y)) (invH y)))
                                                              (comp/assoc A x (g (f y)) (comp A x (g (f x)) (invH x) (g (f y)) (ap B A g (f x) (f y) q)) y (H y) (g (f y)) (invH y)))
                                             (wrapper i3) (ap (Path A (g (f y)) (g (f y))) (Path B (f x) (f y)) (\ p. wrapper (comp A (g (f x)) x (H x) (g (f y))
                                                                                                                (comp A x (g (f y)) (comp A x (g (f x)) (invH x) (g (f y)) (ap B A g (f x) (f y) q))
                                                                                                                          (g (f y)) p)))
                                                              (comp A (g (f y)) y (H y) (g (f y)) (invH y)) (refl A (g (f y)))
                                                              (comp/inv-r A (g (f y)) y (H y)))
                                             (wrapper i4) (ap (Path A x (g (f y))) (Path B (f x) (f y)) (\ p. wrapper (comp A (g (f x)) x (H x) (g (f y)) p))
                                                              (comp A x (g (f y)) (comp A x (g (f x)) (invH x) (g (f y)) (ap B A g (f x) (f y) q)) (g (f y)) (refl A (g (f y))))
                                                              (comp A x (g (f x)) (invH x) (g (f y)) (ap B A g (f x) (f y) q))
                                                              (comp/ident-r A x (g (f y)) (comp A x (g (f x)) (invH x) (g (f y)) (ap B A g (f x) (f y) q))))
                                             (wrapper i5) (ap (Path A (g (f x)) (g (f y))) (Path B (f x) (f y)) wrapper
                                                              i4 i5 (comp/assoc' A (g (f x)) x (H x) (g (f x)) (invH x) (g (f y)) (ap B A g (f x) (f y) q)))
                                             (wrapper i6) (ap (Path A (g (f x)) (g (f x))) (Path B (f x) (f y))
                                                              (\ p. wrapper (comp A (g (f x)) (g (f x)) p (g (f y)) (ap B A g (f x) (f y) q)))
                                                              (comp A (g (f x)) x (H x) (g (f x)) (invH x)) (refl A (g (f x)))
                                                              (comp/inv-r A (g (f x)) x (H x)))
                                             (ap/closure-bi-inv-right-htpy-path4 A B f b x y q)
                                                            (ap (Path A (g (f x)) (g (f y))) (Path B (f x) (f y)) wrapper
                                                              i6 (ap B A g (f x) (f y) q)
                                                              (comp/ident-l A (g (f x)) (g (f y)) (ap B A g (f x) (f y) q)))
#+end_src

***** Final step: right inverse
We now have: (G (f x))^-1 \cdot ((ap f (ap f^-1 q)) \cdot (G (f y))). It thus suffices to do the same proof as the left inverse.
#+begin_src ctt
  ap/closure-bi-inv-right-htpy-step4 (A B : U) (f : A -> B) (b : is-bi-inv A B f) (x y : A) (q : Path B (f x) (f y))
                                          : Path (Path B (f x) (f y)) (ap/closure-bi-inv-right-htpy-path4 A B f b x y q) q =
    let g : B -> A = is-bi-inv/inv-map A B f b
        H : Htpy' A A (\ z. g (f z)) (id A) = is-bi-inv/inv-left-htpy A B f b
        G : Htpy' B B (\ z. f (g z)) (id B) = is-bi-inv/inv-right-htpy A B f b
        invG : (z : B) -> Path B z (f (g z)) = \ z. inv B (f (g z)) z (G z)
        invH : (z : A) -> Path A z (g (f z)) = \ z. inv A (g (f z)) z (H z)

        i1 : Path B (f x) (f y) = comp B (f x) (f (g (f x))) (invG (f x)) (f y) (comp B (f (g (f x))) (f (g (f y))) (ap B B (\ z. f (g z)) (f x) (f y) q) (f y) (G (f y)))
        i2 : Path B (f x) (f y) = comp B (f x) (f (g (f x))) (invG (f x)) (f y) (comp B (f (g (f x))) (f x) (G (f x)) (f y) (ap B B (id B) (f x) (f y) q))
        i3 : Path B (f x) (f y) = comp B (f x) (f x) (comp B (f x) (f (g (f x))) (invG (f x)) (f x) (G (f x))) (f y) (ap B B (id B) (f x) (f y) q)
        i4 : Path B (f x) (f y) = comp B (f x) (f x) (refl B (f x)) (f y) (ap B B (id B) (f x) (f y) q)
        i5 : Path B (f x) (f y) = ap B B (id B) (f x) (f y) q

    in comp-n (Path B (f x) (f y))
              six-Nat (ap/closure-bi-inv-right-htpy-path4 A B f b x y q)
                      i1 (ap (Path B (f (g (f x))) (f (g (f y)))) (Path B (f x) (f y)) (\ p. comp B (f x) (f (g (f x))) (invG (f x)) (f y) (comp B (f (g (f x))) (f (g (f y))) p (f y) (G (f y))))
                             (ap A B f (g (f x)) (g (f y)) (ap B A g (f x) (f y) q)) (ap B B (\ z. f (g z)) (f x) (f y) q)
                             (ap/comp B A B g f (f x) (f y) q))
                      i2 (ap (Path B (f (g (f x))) (f y)) (Path B (f x) (f y)) (\ p. comp B (f x) (f (g (f x))) (invG (f x)) (f y) p)
                             (comp B (f (g (f x))) (f (g (f y))) (ap B B (\ z. f (g z)) (f x) (f y) q) (f y) (G (f y)))
                             (comp B (f (g (f x))) (f x) (G (f x)) (f y) (ap B B (id B) (f x) (f y) q))
                             (naturality' B B (\ z. f (g z)) (id B) G (f x) (f y) q))
                      i3 (comp/assoc' B (f x) (f (g (f x))) (invG (f x)) (f x) (G (f x)) (f y) (ap B B (id B) (f x) (f y) q))
                      i4 (ap (Path B (f x) (f x)) (Path B (f x) (f y)) (\ p. comp B (f x) (f x) p (f y) (ap B B (id B) (f x) (f y) q))
                             (comp B (f x) (f (g (f x))) (invG (f x)) (f x) (G (f x))) (refl B (f x))
                             (comp/inv-l B (f (g (f x))) (f x) (G (f x))))
                      i5 (comp/ident-l B (f x) (f y) (ap B B (id B) (f x) (f y) q))
                      q  (ap/id' B (f x) (f y) q)
#+end_src

***** Conclusion

#+begin_src ctt
  ap/closure-bi-inv-right-htpy (A B : U) (f : A -> B) (b : is-bi-inv A B f) (x y : A)
                                    : Htpy' (Path B (f x) (f y)) (Path B (f x) (f y))
                                           (\ q. (ap A B f x y) (ap/closure-bi-inv-inv-map A B f b x y q)) (id (Path B (f x) (f y))) =
    \ q.
      let g : B -> A = is-bi-inv/inv-map A B f b
          H : Htpy' A A (\ z. g (f z)) (id A) = is-bi-inv/inv-left-htpy A B f b
          G : Htpy' B B (\ z. f (g z)) (id B) = is-bi-inv/inv-right-htpy A B f b
      in comp-n (Path B (f x) (f y)) four-Nat (ap/closure-bi-inv-right-htpy-path1 A B f g H G x y q)
                (ap/closure-bi-inv-right-htpy-path2 A B f g H G x y q) (ap/closure-bi-inv-right-htpy-step1 A B f g H G x y q)
                (ap/closure-bi-inv-right-htpy-path3 A B f g H G x y q) (ap/closure-bi-inv-right-htpy-step2 A B f g H G x y q)
                (ap/closure-bi-inv-right-htpy-path4 A B f b x y q) (ap/closure-bi-inv-right-htpy-step3 A B f b x y q)
                q (ap/closure-bi-inv-right-htpy-step4 A B f b x y q)                  
#+end_src

**** Result

#+begin_src ctt
  ap/closure-bi-inv-has-inv (A B : U) (f : A -> B) (b : is-bi-inv A B f) (x y : A) : has-inverse (Path A x y) (Path B (f x) (f y)) (ap A B f x y) =
    (ap/closure-bi-inv-inv-map A B f b x y, (ap/closure-bi-inv-right-htpy A B f b x y, ap/closure-bi-inv-left-htpy A B f b x y))

  ap/closure-bi-inv (A B : U) (f : A -> B) (b : is-bi-inv A B f) (x y : A) : is-bi-inv (Path A x y) (Path B (f x) (f y)) (ap A B f x y) =
    has-inverse-is-bi-inv (Path A x y) (Path B (f x) (f y)) (ap A B f x y) (ap/closure-bi-inv-has-inv A B f b x y)
#+end_src





 
