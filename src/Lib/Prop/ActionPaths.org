#+NAME: ActionPaths
#+AUTHOR: Johann Rosain

* Action on Paths (AP) Properties

  #+begin_src ctt
  module Lib.Prop.ActionPaths where
  #+end_src

This file states some useful properties of the function =ap=.

** Packages imports

   #+begin_src ctt
  import Lib.Prop.Comp
  import Lib.Data.BiInv
  import Lib.Data.Map  
  import Lib.Data.Nat
  import Lib.FunExt  
  import Lib.QInv
  import Lib.Prop.MiscPaths
   #+end_src

** Properties

*** Dependent AP
    #+begin_src ctt
  apd (A : U) (B : A -> U) (f : (x : A) -> B x) (x y : A) (p : Path A x y) : Path (B y) (tr A x y p B (f x)) (f y) =
    J A x (\ z q. Path (B z) (tr A x z q B (f x)) (f z)) (tr/refl-path A x B (f x)) y p
    #+end_src

*** Identity
=ap id= is =id= for paths.
#+begin_src ctt
  ap/id (A : U) (x y : A) (p : Path A x y) : Path (Path A x y) p (ap A A (id A) x y p) =
    J A x (\ y' q. Path (Path A x y') q (ap A A (id A) x y' q))
          (refl (Path A x x) (refl A x)) y p

  ap/id' (A : U) (x y : A) (p : Path A x y) : Path (Path A x y) (ap A A (id A) x y p) p =
    inv (Path A x y) p (ap A A (id A) x y p) (ap/id A x y p)
#+end_src
=ap id= is also clearly bi-invertible.
#+begin_src ctt
  is-bi-inv/ap-id-inv-htpy (A : U) (x y : A) : Htpy' (Path A x y) (Path A x y) (\ p. (ap A A (id A) x y) (ap A A (id A) x y p)) (id (Path A x y)) =
    \ p. comp (Path A x y) ((ap A A (id A) x y) (ap A A (id A) x y p)) (ap A A (id A) x y p)
                          (ap/id' A x y (ap A A (id A) x y p)) p (ap/id' A x y p)

  is-bi-inv/ap-id-is-bi-inv (A : U) (x y : A) : is-bi-inv (Path A x y) (Path A x y) (ap A A (id A) x y) =
    ((ap A A (id A) x y, is-bi-inv/ap-id-inv-htpy A x y), (ap A A (id A) x y, is-bi-inv/ap-id-inv-htpy A x y))
#+end_src
A useful lemma is that =tr whatever ap id= is also bi-invertible.
#+begin_src ctt
  is-bi-inv/ap-eq-id (A : U) (f : A -> A) (p : Path (A -> A) (id A) f) (x y : A)
                        : is-bi-inv (Path A x y) (Path A (f x) (f y)) (ap A A f x y) =
    tr (A -> A) (id A) f p (\ h. is-bi-inv (Path A x y) (Path A (h x) (h y)) (ap A A h x y))
      (is-bi-inv/ap-id-is-bi-inv A x y)    
#+end_src

*** Composition
ap g \circ ap f is ap (g \circ f).
#+begin_src ctt
  ap/comp (A B C : U) (f : A -> B) (g : B -> C) (x y : A) (p : Path A x y)
                 : Path (Path C (g (f x)) (g (f y))) (ap B C g (f x) (f y) (ap A B f x y p)) (ap A C (map/comp A B C g f) x y p) =
    J A x (\ z q. Path (Path C (g (f x)) (g (f z))) (ap B C g (f x) (f z) (ap A B f x z q)) (ap A C (map/comp A B C g f) x z q))
          (refl (Path C (g (f x)) (g (f x))) (refl C (g (f x)))) y p

  ap/comp' (A B C : U) (f : A -> B) (g : B -> C) (x y : A) (p : Path A x y)
                 : Path (Path C (g (f x)) (g (f y))) (ap A C (map/comp A B C g f) x y p) (ap B C g (f x) (f y) (ap A B f x y p)) =
    inv (Path C (g (f x)) (g (f y))) (ap B C g (f x) (f y) (ap A B f x y p)) (ap A C (map/comp A B C g f) x y p) (ap/comp A B C f g x y p)
#+end_src

*** Inverse
ap f p^-1 is (ap f p)^-1.
#+begin_src ctt
  ap/refl/refl (A B : U) (f : A -> B) (x : A) : Path (Path B (f x) (f x)) (ap A B f x x (inv A x x (refl A x)))
                                                                         (ap A B f x x (refl A x)) =
    ap (Path A x x) (Path B (f x) (f x)) (ap A B f x x) (inv A x x (refl A x)) (refl A x) (inv/refl A x)

  ap/inv (A B : U) (f : A -> B) (x y : A) (p : Path A x y)
              : Path (Path B (f y) (f x)) (ap A B f y x (inv A x y p)) (inv B (f x) (f y) (ap A B f x y p)) =
    J A x (\ z q. Path (Path B (f z) (f x)) (ap A B f z x (inv A x z q)) (inv B (f x) (f z) (ap A B f x z q)))
          (comp (Path B (f x) (f x)) (ap A B f x x (inv A x x (refl A x)))
                                     (ap A B f x x (refl A x)) (ap/refl/refl A B f x)
                                     (inv B (f x) (f x) (refl B (f x))) (refl/sym B (f x))) y p
#+end_src

*** Path between identifiable functions
    #+begin_src ctt
  ap/eq (A B : U) (f g : A -> B) (p : Path (A -> B) f g) (x y : A) : Path ((Path A x y) -> Path B (g x) (g y)) (tr (A -> B) f g p (\ h. Path A x y -> Path B (h x) (h y)) (ap A B f x y))
                                                                        (ap A B g x y) =
    apd (A -> B) (\ h. Path A x y -> Path B (h x) (h y)) (\ h. ap A B h x y) f g p
    #+end_src

*** Path concatenation
=ap f (comp p q)= is =comp (ap f p) (ap f q)=.
#+begin_src ctt
  ap/concat (A B : U) (f : A -> B) (x y z : A) (p : Path A x y) (q : Path A y z)
                 : Path (Path B (f x) (f z)) (ap A B f x z (comp A x y p z q))
                                           (comp B (f x) (f y) (ap A B f x y p) (f z) (ap A B f y z q)) =
    J A y (\ t r. Path (Path B (f x) (f t)) (ap A B f x t (comp A x y p t r))
                                            (comp B (f x) (f y) (ap A B f x y p) (f t) (ap A B f y t r)))
              (comp (Path B (f x) (f y)) (ap A B f x y (comp A x y p y (refl A y)))
                                         (ap A B f x y p) (ap (Path A x y) (Path B (f x) (f y)) (ap A B f x y) (comp A x y p y (refl A y)) p (comp/ident-r A x y p))
                                         (comp B (f x) (f y) (ap A B f x y p) (f y) (refl B (f y))) (refl/comp-r B (f x) (f y) (ap A B f x y p)))
      z q
#+end_src

*** Closure under homotopies
We show that if f \sim g, then =ap f= and =ap g= can be used in further computations, by something called the /naturality square/. We proceed by path induction and need to use the composition properties of =Prelude= as the judgmental equality in cubical is different than judgmental equality of HoTT.
#+begin_src ctt
  naturality (A B : U) (f g : A -> B) (H : Htpy' A B f g) (x y : A) (p : Path A x y)
                  : Path (Path B (f x) (g y)) (comp B (f x) (g x) (H x) (g y) (ap A B g x y p))
                                              (comp B (f x) (f y) (ap A B f x y p) (g y) (H y)) =
    J A x (\ z q. Path (Path B (f x) (g z)) (comp B (f x) (g x) (H x) (g z) (ap A B g x z q))
                                           (comp B (f x) (f z) (ap A B f x z q) (g z) (H z)))
          (comp (Path B (f x) (g x)) (comp B (f x) (g x) (H x) (g x) (refl B (g x))) (H x)
                                     (comp/ident-r B (f x) (g x) (H x)) (comp B (f x) (f x) (refl B (f x)) (g x) (H x))
                                     (comp/ident-l' B (f x) (g x) (H x))) y p

  naturality' (A B : U) (f g : A -> B) (H : Htpy' A B f g) (x y : A) (p : Path A x y)
                   : Path (Path B (f x) (g y)) (comp B (f x) (f y) (ap A B f x y p) (g y) (H y))
                                               (comp B (f x) (g x) (H x) (g y) (ap A B g x y p)) =
    inv (Path B (f x) (g y)) (comp B (f x) (g x) (H x) (g y) (ap A B g x y p)) (comp B (f x) (f y) (ap A B f x y p) (g y) (H y))
        (naturality A B f g H x y p)
#+end_src

*** Closure of bi-invertibility 
This result is in =ContrMap.org=.
