#+NAME: ActionPaths
#+AUTHOR: Johann Rosain

* Action on Paths (AP) Properties

  #+begin_src ctt
  module Lib.Prop.ActionPaths where
  #+end_src

This file states some useful properties of the function =ap=.

** Packages imports

   #+begin_src ctt
  import Stdlib.Prelude
  import Lib.Data.BiInv
  import Lib.Data.Map  
  import Lib.Data.Nat
  import Lib.FunExt  
  import Lib.QInv
   #+end_src

** Properties

*** Identity
=ap id= is =id= for paths.
#+begin_src ctt
  ap/id (A : U) (x y : A) (p : Path A x y) : Path (Path A x y) p (ap A A (id A) x y p) =
    J A x (\ y' q. Path (Path A x y') q (ap A A (id A) x y' q))
          (refl (Path A x x) (refl A x)) y p

  ap/id' (A : U) (x y : A) (p : Path A x y) : Path (Path A x y) (ap A A (id A) x y p) p =
    inv (Path A x y) p (ap A A (id A) x y p) (ap/id A x y p)
#+end_src

*** Composition
ap g \circ ap f is ap (g \circ f).
#+begin_src ctt
  ap/comp (A B C : U) (f : A -> B) (g : B -> C) (x y : A) (p : Path A x y)
                 : Path (Path C (g (f x)) (g (f y))) (ap B C g (f x) (f y) (ap A B f x y p)) (ap A C (map/comp A B C g f) x y p) =
    J A x (\ z q. Path (Path C (g (f x)) (g (f z))) (ap B C g (f x) (f z) (ap A B f x z q)) (ap A C (map/comp A B C g f) x z q))
          (refl (Path C (g (f x)) (g (f x))) (refl C (g (f x)))) y p
#+end_src

*** Inverse
ap f p^-1 is (ap f p)^-1.
#+begin_src ctt
  refl/sym (A : U) (x : A) : Path (Path A x x) (refl A x) (inv A x x (refl A x)) =
    (inv (Path A x x) (inv A x x (refl A x)) (refl A x) (inv/refl A x))

  ap/refl/refl (A B : U) (f : A -> B) (x : A) : Path (Path B (f x) (f x)) (ap A B f x x (inv A x x (refl A x)))
                                                                         (ap A B f x x (refl A x)) =
    ap (Path A x x) (Path B (f x) (f x)) (ap A B f x x) (inv A x x (refl A x)) (refl A x) (inv/refl A x)

  ap/inv (A B : U) (f : A -> B) (x y : A) (p : Path A x y)
              : Path (Path B (f y) (f x)) (ap A B f y x (inv A x y p)) (inv B (f x) (f y) (ap A B f x y p)) =
    J A x (\ z q. Path (Path B (f z) (f x)) (ap A B f z x (inv A x z q)) (inv B (f x) (f z) (ap A B f x z q)))
          (comp (Path B (f x) (f x)) (ap A B f x x (inv A x x (refl A x)))
                                     (ap A B f x x (refl A x)) (ap/refl/refl A B f x)
                                     (inv B (f x) (f x) (refl B (f x))) (refl/sym B (f x))) y p
#+end_src

*** Path concatenation
=ap f (comp p q)= is =comp (ap f p) (ap f q)=.
#+begin_src ctt
  refl/comp-r (A : U) (x y : A) (p : Path A x y) : Path (Path A x y) p (comp A x y p y (refl A y)) =
    inv (Path A x y) (comp A x y p y (refl A y)) p (comp/ident-r A x y p)

  ap/concat (A B : U) (f : A -> B) (x y z : A) (p : Path A x y) (q : Path A y z)
                 : Path (Path B (f x) (f z)) (ap A B f x z (comp A x y p z q))
                                           (comp B (f x) (f y) (ap A B f x y p) (f z) (ap A B f y z q)) =
    J A y (\ t r. Path (Path B (f x) (f t)) (ap A B f x t (comp A x y p t r))
                                            (comp B (f x) (f y) (ap A B f x y p) (f t) (ap A B f y t r)))
              (comp (Path B (f x) (f y)) (ap A B f x y (comp A x y p y (refl A y)))
                                         (ap A B f x y p) (ap (Path A x y) (Path B (f x) (f y)) (ap A B f x y) (comp A x y p y (refl A y)) p (comp/ident-r A x y p))
                                         (comp B (f x) (f y) (ap A B f x y p) (f y) (refl B (f y))) (refl/comp-r B (f x) (f y) (ap A B f x y p)))
      z q
#+end_src

*** Closure under homotopies
We show that if f \sim g, then =ap f= and =ap g= can be used in further computations, by something called the /naturality square/. We proceed by path induction and need to use the composition properties of =Prelude= as the judgmental equality in cubical is different than judgmental equality of HoTT.
#+begin_src ctt
  naturality (A B : U) (f g : A -> B) (H : Htpy' A B f g) (x y : A) (p : Path A x y)
                  : Path (Path B (f x) (g y)) (comp B (f x) (g x) (H x) (g y) (ap A B g x y p))
                                              (comp B (f x) (f y) (ap A B f x y p) (g y) (H y)) =
    J A x (\ z q. Path (Path B (f x) (g z)) (comp B (f x) (g x) (H x) (g z) (ap A B g x z q))
                                           (comp B (f x) (f z) (ap A B f x z q) (g z) (H z)))
          (comp (Path B (f x) (g x)) (comp B (f x) (g x) (H x) (g x) (refl B (g x))) (H x)
                                     (comp/ident-r B (f x) (g x) (H x)) (comp B (f x) (f x) (refl B (f x)) (g x) (H x))
                                     (comp/ident-l' B (f x) (g x) (H x))) y p

  naturality' (A B : U) (f g : A -> B) (H : Htpy' A B f g) (x y : A) (p : Path A x y)
                   : Path (Path B (f x) (g y)) (comp B (f x) (f y) (ap A B f x y p) (g y) (H y))
                                               (comp B (f x) (g x) (H x) (g y) (ap A B g x y p)) =
    inv (Path B (f x) (g y)) (comp B (f x) (g x) (H x) (g y) (ap A B g x y p)) (comp B (f x) (f y) (ap A B f x y p) (g y) (H y))
        (naturality A B f g H x y p)
#+end_src

*** Closure of bi-invertibility 
If =f= is bi-invertible, then =ap f= is bi-invertible aswell.

Indeed, if \alpha is the homotopy f^-1 \circ f \sim id, then the inverse of =ap f= is the concatenation of \alpha^-1 x, ap f^-1 q, \alpha y where q : x = y.
#+begin_src ctt
  ap/closure-bi-inv-inv-map (A B : U) (f : A -> B) (b : is-bi-inv A B f) (x y : A) (p : Path B (f x) (f y)) : Path A x y =
    let g : B -> A = is-bi-inv/inv-map A B f b
        H : Htpy' A A (\ z. g (f z)) (id A) = is-bi-inv/inv-left-htpy A B f b
    in
    comp-n A three-Nat x (g (f x)) (inv A (g (f x)) x (H x))
                     (g (f y)) (ap B A g (f x) (f y) p)
                     y (H y)
#+end_src
First, we show that it is the left inverse of =ap f=. To do so, remark that (ap f (ap f^-1 p)) is (ap (f \circ f^-1) p). Then, using the naturality square is enough to conclude. The code is somewhat tedious, but what is happening is clear:

  (H x)^-1 \cdot (ap f^-1 (ap f p)) \cdot (H y) --(ap + ap-comp)--> ((H x)^-1 \cdot (ap (f^-1 \circ f) p)) \cdot (H y)
                                     --(assoc)--> (H x)^-1 \cdot ((ap (f^-1 \circ f) p) \cdot (H y))
                                     --(naturality)--> (H x)^-1 \cdot ((H x) \cdot (ap id p))
                                     --(assoc)--> ((H x)^-1 \cdot (H x)) \cdot (ap id p)
                                     --(ap + inverses cancel)--> refl \cdot ap id p
                                     --(refl-identity)--> ap id p
                                     --(ap-id)--> p
#+begin_src ctt
  ap/closure-bi-inv-left-htpy (A B : U) (f : A -> B) (b : is-bi-inv A B f) (x y : A)
                                   : Htpy' (Path A x y) (Path A x y) (\ p. (ap/closure-bi-inv-inv-map A B f b x y) ((ap A B f x y p))) (id (Path A x y)) =
    \ p.
      let g : B -> A = is-bi-inv/inv-map A B f b
          H : Htpy' A A (\ z . g (f z)) (id A) = is-bi-inv/inv-left-htpy A B f b
          h : Path A (g (f x)) (g (f y)) -> Path A x y = \ q. (comp-n A three-Nat x (g (f x)) (inv A (g (f x)) x (H x))
                                                                                  (g (f y)) q
                                                                                   y (H y))
          assoc1 : Path A x y = (comp A x (g (f x)) (inv A (g (f x)) x (H x)) y (comp A (g (f x)) (g (f y)) (ap B A g (f x) (f y) (ap A B f x y p)) y (H y)))
          nat : Path A x y = comp A x (g (f x)) (inv A (g (f x)) x (H x)) y (comp A (g (f x)) x (H x) y (ap A A (id A) x y p))
          assoc2 : Path A x y = comp-n A three-Nat x (g (f x)) (inv A (g (f x)) x (H x)) x (H x) y (ap A A (id A) x y p)
          q1 : Path (Path A x y) ((ap/closure-bi-inv-inv-map A B f b x y) (ap A B f x y p)) (h (ap A A (\ z. (g (f z))) x y p))
                                  = ap (Path A (g (f x)) (g (f y))) (Path A x y) h (ap B A g (f x) (f y) (ap A B f x y p)) (ap A A (\ z. g (f z)) x y p) (ap/comp A B A f g x y p)
          q2 : Path (Path A x y) (h (ap A A (\ z. (g (f z))) x y p)) assoc1
                                  = comp/assoc A x (g (f x)) (inv A (g (f x)) x (H x)) (g (f y)) (ap B A g (f x) (f y) (ap A B f x y p)) y (H y)
          q3 : Path (Path A x y) assoc1 nat
                                  = ap (Path A (g (f x)) y) (Path A x y) (\ q. comp A x (g (f x)) (inv A (g (f x)) x (H x)) y q)
                                       (comp A (g (f x)) (g (f y)) (ap B A g (f x) (f y) (ap A B f x y p)) y (H y))
                                       (comp A (g (f x)) x (H x) y (ap A A (id A) x y p)) (naturality' A A (\ z. g (f z)) (id A) H x y p)
          q4 : Path (Path A x y) nat assoc2
                                  = inv (Path A x y) assoc2 nat
                                        (comp/assoc A x (g (f x)) (inv A (g (f x)) x (H x)) x (H x) y (ap A A (id A) x y p))
          q5 : Path (Path A x y) assoc2 (comp A x x (refl A x) y (ap A A (id A) x y p))
                                  = ap (Path A x x) (Path A x y) (\ q. comp A x x q y (ap A A (id A) x y p))
                                       (comp A x (g (f x)) (inv A (g (f x)) x (H x)) x (H x)) (refl A x)
                                       (comp/inv-l A (g (f x)) x (H x))
          q6 : Path (Path A x y) (comp A x x (refl A x) y (ap A A (id A) x y p)) (ap A A (id A) x y p)
                                  = comp/ident-l A x y (ap A A (id A) x y p)
          q7 : Path (Path A x y) (ap A A (id A) x y p) p =
                                  ap/id' A x y p
      in comp-n (Path A x y) seven-Nat ((ap/closure-bi-inv-inv-map A B f b x y) (ap A B f x y p))
                                       (h (ap A A (\ z. (g (f z))) x y p)) q1
                                       assoc1 q2
                                       nat q3
                                       assoc2 q4
                                       (comp A x x (refl A x) y (ap A A (id A) x y p)) q5
                                       (ap A A (id A) x y p) q6
                                       p q7
#+end_src
We now show that it is the right inverse of =ap f=. Indeed, remark that =ap f (H x)= is actually =G (f x))=, and thus we have: ap f ((H x)^-1 \cdot ap f^-1 p \cdot (H y)) = (ap f (H x)^-1) \cdot ap (f \circ f^-1) p \cdot (ap f (H y)) = (G (f x))^-1 \cdot ap (f \circ f^-1) p \cdot G (f y). Then, we proceed as above.
#+begin_src ctt
  -- ap/closure-bi-inv-right-htpy (A B : U) (f : A -> B) (b : is-bi-inv A B f) (x y : A)
  --                                   : Htpy' (Path B (f x) (f y)) (Path B (f x) (f y))
  --                                          (\ p. (ap A B f x y) (ap/closure-bi-inv-inv-map A B f b x y p)) (id (Path B (f x) (f y))) =
  --   \ q.
  --     let g : B -> A = is-bi-inv/inv-map A B f b
  --         H : Htpy' A A (\ z. g (f z)) (id A) = is-bi-inv/inv-left-htpy A B f b
  --         G : Htpy' B B (\ z. f (g z)) (id B) = is-bi-inv/inv-right-htpy A B f b
  --     in refl (Path B (f x) (f y)) (refl B (f x))
#+end_src

#+begin_src ctt
  -- ap/closure-bi-inv (A B : U) (f : A -> B) (b : is-bi-inv A B f) (x y : A) : is-bi-inv (ap A B f x y) =
#+end_src




