#+NAME: Equiv
#+AUTHOR: Johann Rosain

* Equivalence Properties

  #+begin_src ctt
  module Lib.Prop.Equiv where
  #+end_src

This file regroups the properties of =Equiv= and =is-equiv= that are not provided by the standard library.

** Packages imports

   #+begin_src ctt
  import Lib.Prop.Contr
  import Lib.Prop.Sg
  import Lib.Data.Map
  import Lib.Data.Empty
   #+end_src

** Accessors
   #+begin_src ctt
  Equiv/map (A B : U) (e : Equiv A B) : A -> B = e.1
  Equiv/is-equiv (A B : U) (e : Equiv A B) : is-equiv A B (Equiv/map A B e) = e.2    
   #+end_src

** Inverse of an equivalence

TODO: use the property that =is-equiv iff is-bi-inv iff has-inverse= to get the inverse of an equivalence.
#+begin_src ctt
  -- is-equiv/inv-map (A B : U) (f : A -> B) (e : is-equiv A B f) : B -> A =
  -- Equiv/inv-map (A B : U) (e : Equiv A B) : B -> A =
  --  is-equiv/inv-map A B (Equiv/map A B e) (Equiv/is-equiv A B e)  

  Equiv/inv-map (A B : U) (e : Equiv A B) : B -> A =
    Equiv/map B A (path-to-equiv B A (inv U A B (equiv-to-path A B e)))
#+end_src

** Equivalence relation properties

=is-equiv= and =Equiv= are equivalence relations, that is, they are:
   * reflexive ;
   * symmetric ;
   * transitive.
The first property is handled in [[../Stdlib/Prelude.ctt][Prelude.ctt]], but we redefine them here with a name consistent with the others properties: =is-equiv/prop= (resp. =Equiv/prop=). Then, we focus on showing the symmetry and the transitivity of this relation.

TODO: rework proofs of symmetry/transitivity when we have =is-equiv iff is-bi-inv= as they are straightforward using =is-bi-inv-has-inverse=.

*** Reflexivity

    #+begin_src ctt
  is-equiv/refl (A : U) : is-equiv A A (id A)
    = id/is-equiv A

  Equiv/refl (A : U) : Equiv A A
    = IdEquiv A
    #+end_src

*** Symmetry
**** Symmetry of =is-equiv=

    #+begin_src ctt
    
    #+end_src

**** Symmetry of =Equiv=

     #+begin_src ctt
  Equiv/sym (A B : U) (e : Equiv A B) : Equiv B A =
    path-to-equiv B A (inv U A B (equiv-to-path A B e))
    #+end_src

*** Transitivity
**** Transitivity of =is-equiv=

First, we show that =is-equiv= is transitive. To show that a map is an equivalence, it suffices to prove that its fibers are contractible. 

The center of contraction is the pair =(x, p)= where =x= is the preimage by =f= of =z=, that is the preimage of =y= by =g= and =p= is simply the path concatenation of y \to g z \to g (f x) where the first path is obtained using the center of =is-equiv g= and the second is obtained using =ap= over =is-equiv f=.
    #+begin_src ctt
    is-equiv/trans/center (A B C : U) (f : A -> B) (e-f : is-equiv A B f) (g : B -> C) (e-g : is-equiv B C g) (y : C)
      : Fib A C (map/comp A B C g f) y =
      let z : B = (center (Fib B C g y) (e-g y)).1 in
      let x : A = (center (Fib A B f z) (e-f z)).1 in
      (x,
       comp C y (g z) (center (Fib B C g y) (e-g y)).2
                (g (f x)) (ap B C g z (f x) (center (Fib A B f z) (e-f z)).2))
#+end_src
Then, we may obtain a path between dependent pairs =u, v= by giving a path =p= between =u.1, v.1= and showing that =is-contr= is a proposition (that is, we don't need to show that there is a path between =u.2= and =v.2=). First, we show that from a fibration from =A= to =C=, we can obtain a fibration from =A= to =B=.
#+begin_src ctt
  is-equiv/trans/fib (A B C : U) (f : A -> B) (g : B -> C) (y : C) (H : Fib A C (map/comp A B C g f) y)
    : Fib A B f (f H.1) = (H.1, refl B (f H.1))
#+end_src
This enables us to show that there is a path between the first element of =is-equiv/trans/center= and the first element of any fibration from =A= to =C= for =g=. Indeed, the first element of =is-equiv/trans/center= is the center of contraction of =is-equiv f=, that is, we have a proof that the first element of any fibration of =f= is equal to it. We use the previous lemma to find a fibration for =f= from a fibration for =g \circ f= and it allows us to conclude.
    #+begin_src ctt
  is-equiv/trans/contr/proj1 (A B C : U) (f : A -> B) (e-f : is-equiv A B f) (g : B -> C) (e-g : is-equiv B C g) (y : C) (H : Fib A C (map/comp A B C g f) y)
   : Path A (e-f (f H.1)).1.1 H.1 =
    let x : A = (is-equiv/trans/center A B C f e-f g e-g y).1 in
    let x' : A = H.1 in
    let c : is-contr (Fib A B f (f x')) = e-f (f x') in
    let fib' : Fib A B f (f x') = is-equiv/trans/fib A B C f g y H in
    (Sg-path/left A (\ z. Path B (f x') (f z)) c.1 fib' (c.2 fib'))
#+end_src

Finally, we can show that =is-equiv= is transitive.
#+begin_src ctt
  -- is-equiv/trans (A B C : U) (f : A -> B) (e-f : is-equiv A B f) (g : B -> C) (e-g : is-equiv B C g) :
  --   is-equiv (map/comp g f) =
  --     \ y. (is-equiv/trans/center A B C f e-f g e-g y, is-equiv/trans/contr A B C f e-f g e-g y)
#+end_src

**** Transitivity of =Equiv=
 
The fact that =Equiv= is transitive follows immediatly from the fact that =is-equiv= is transitive.
   #+begin_src ctt
  Equiv/trans (A B C : U) (e-AB : Equiv A B) (e-BC : Equiv B C) : Equiv A C =
     path-to-equiv A C (comp U A B (equiv-to-path A B e-AB) C (equiv-to-path B C e-BC))
   #+end_src

** Some trivial equivalences

*** A map to =Empty= is always an equivalence

First, we show that if =f : is-empty A=, then =is-equiv f=. Hence, we are given an element of =Empty= and thus ex-falso suffices to show that the fibers of =f= are contractible.
    #+begin_src ctt
  is-empty/is-equiv (A : U) (f : is-empty A) : is-equiv A Empty f =
    \ x. ind-Empty (\ y. is-contr (Fib A Empty f y)) x
    #+end_src
Thus, if =is-empty A=, we have an equivalence between =A= and =Empty=.
#+begin_src ctt
  Empty/equiv (A : U) (f : is-empty A) : Equiv A Empty =
    (f, is-empty/is-equiv A f)
#+end_src

** 3-for-2 properties

*** 3-for-2 property of contractibility
Given =f : A \to B=, the 3-for-2 property of contractibility states that if any two of the three assertions
  * =A= is contractible
  * =B= is contractible
  * =f= is an equivalence
hold, then so does the third. We start by showing that if one of =A= or =B= is contractible and =f= is an equivalence, then the other is also contractible. It is easy: take the center of the contraction to be =(inv f (center contr))=, and the path is obtained using =ap (inv f)= together with the contractibility of =contr= and the homotopy =(inv f) \circ f ~ id=.
#+begin_src ctt
  is-contr/is-contr-equiv (A B : U) (f : A -> B) (e : is-equiv A B f) (c : is-contr B) : is-contr A =
    ?
#+end_src
#+RESULTS:
: Typecheck has succeeded.
