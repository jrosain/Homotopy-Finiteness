#+NAME: Equiv
#+AUTHOR: Johann Rosain

* Equivalence Properties

  #+begin_src ctt
  module Lib.Prop.Equiv where
  #+end_src

This file regroups the properties of =Equiv= and =is-equiv= that are not provided by the standard library.

** Packages imports

   #+begin_src ctt
  import Lib.Prop.Contr
  import Lib.Prop.Sg
  import Lib.Data.Map
  import Lib.Data.Empty
  import Lib.Data.Decidability  
  import Lib.QInv
  import Lib.ContrMap
  import Lib.Prop.ActionPaths
   #+end_src

** Accessors
   #+begin_src ctt
  Equiv/map (A B : U) (e : Equiv A B) : A -> B = e.1
  Equiv/is-equiv (A B : U) (e : Equiv A B) : is-equiv A B (Equiv/map A B e) = e.2    
   #+end_src

** Inverse of an equivalence
We can define the inverse map of an equivalence.
#+begin_src ctt
  is-equiv/inv-map (A B : U) (f : A -> B) (e : is-equiv A B f) : B -> A =
    is-bi-inv/inv-map A B f (is-equiv/is-bi-inv A B f e)

  Equiv/inv-map (A B : U) (e : Equiv A B) : B -> A =
    is-equiv/inv-map A B (Equiv/map A B e) (Equiv/is-equiv A B e)
#+end_src
Futhermore, this inverse map is also an equivalence.
#+begin_src ctt
  is-equiv/inv-is-equiv (A B : U) (f : A -> B) (e : is-equiv A B f) : is-equiv B A (is-equiv/inv-map A B f e) =
    let b : is-bi-inv A B f = is-equiv/is-bi-inv A B f e
        g : B -> A = is-bi-inv/inv-map A B f b
        b' : is-bi-inv B A g = ((f, is-bi-inv/inv-left-htpy A B f b), (f, is-bi-inv/inv-right-htpy A B f b))
    in is-bi-inv/is-equiv B A g b'

  Equiv/inv-equiv (A B : U) (e : Equiv A B) : Equiv B A =
    (Equiv/inv-map A B e, is-equiv/inv-is-equiv A B (Equiv/map A B e) (Equiv/is-equiv A B e))
#+end_src
Moreover, we get the nice properties of inverse maps.
#+begin_src ctt
  is-equiv/inv-right-htpy (A B : U) (f : A -> B) (e : is-equiv A B f)
                               :  Htpy' B B (\ z. f (is-equiv/inv-map A B f e z)) (id B) =
    is-bi-inv/inv-right-htpy A B f (is-equiv/is-bi-inv A B f e)

  is-equiv/inv-left-htpy (A B : U) (f : A -> B) (e : is-equiv A B f)
                              : Htpy' A A (\ z . (is-equiv/inv-map A B f e) (f z)) (id A) =
    is-bi-inv/inv-left-htpy A B f (is-equiv/is-bi-inv A B f e)

  Equiv/inv-right-htpy (A B : U) (e : Equiv A B) : Htpy' B B (\ z. (Equiv/map A B e) (Equiv/inv-map A B e z)) (id B) =
    is-equiv/inv-right-htpy A B (Equiv/map A B e) (Equiv/is-equiv A B e)

  Equiv/inv-left-htpy (A B : U) (e : Equiv A B) : Htpy' A A (\ z. (Equiv/inv-map A B e) (Equiv/map A B e z)) (id A) =
    is-equiv/inv-left-htpy A B (Equiv/map A B e) (Equiv/is-equiv A B e)
#+end_src

** Equivalence relation properties

=is-equiv= and =Equiv= are equivalence relations, that is, they are:
   * reflexive ;
   * symmetric ;
   * transitive.
The first property is handled in [[../Stdlib/Prelude.ctt][Prelude.ctt]], but we redefine them here with a name consistent with the others properties: =is-equiv/prop= (resp. =Equiv/prop=). Then, we focus on showing the symmetry and the transitivity of this relation.

*** Reflexivity

    #+begin_src ctt
  is-equiv/refl (A : U) : is-equiv A A (id A)
    = id/is-equiv A

  Equiv/refl (A : U) : Equiv A A
    = IdEquiv A
    #+end_src

*** Symmetry

     #+begin_src ctt
  is-equiv/sym : (A B : U) -> (f : A -> B) -> (e : is-equiv A B f) -> is-equiv B A (is-equiv/inv-map A B f e) = is-equiv/inv-is-equiv 

  Equiv/sym : (A B : U) -> (e : Equiv A B) -> Equiv B A = Equiv/inv-equiv
    #+end_src

*** Transitivity

    #+begin_src ctt
  is-equiv/trans (A B C : U) (f : A -> B) (g : B -> C) (eF : is-equiv A B f) (eG : is-equiv B C g) : is-equiv A C (map/comp A B C g f) =
    is-bi-inv/is-equiv A C (map/comp A B C g f)
                           (is-bi-inv/comp-is-bi-inv A B C f g (is-equiv/is-bi-inv A B f eF) (is-equiv/is-bi-inv B C g eG))

  Equiv/trans (A B C : U) (e-AB : Equiv A B) (e-BC : Equiv B C) : Equiv A C =
    (map/comp A B C (Equiv/map B C e-BC) (Equiv/map A B e-AB), is-equiv/trans A B C (Equiv/map A B e-AB) (Equiv/map B C e-BC) (Equiv/is-equiv A B e-AB) (Equiv/is-equiv B C e-BC))
    #+end_src

** Some facts on equivalences

*** A map to =Empty= is always an equivalence

First, we show that if =f : is-empty A=, then =is-equiv f=. Hence, we are given an element of =Empty= and thus ex-falso suffices to show that the fibers of =f= are contractible.
    #+begin_src ctt
  is-empty/is-equiv (A : U) (f : is-empty A) : is-equiv A Empty f =
    \ x. ind-Empty (\ y. is-contr (Fib A Empty f y)) x
    #+end_src
Thus, if =is-empty A=, we have an equivalence between =A= and =Empty=.
#+begin_src ctt
  Empty/equiv (A : U) (f : is-empty A) : Equiv A Empty =
    (f, is-empty/is-equiv A f)
#+end_src

*** Decidability is closed under equivalences 
We show that if =A= and =B= are equivalent, then =A= is decidable iff =B= is decidable.
#+begin_src ctt
  is-decidable/is-equiv (A B : U) (f : A -> B) (e : is-equiv A B f) (dB : is-decidable B) : is-decidable A =
    Coprod/map B (neg B) A (neg A)
               (is-equiv/inv-map A B f e)
               (\ g a. g (f a)) dB

  is-decidable-is-equiv' (A B : U) (f : A -> B) (e : is-equiv A B f) (dA : is-decidable A) : is-decidable B =
    is-decidable/is-equiv B A (is-equiv/inv-map A B f e) (is-equiv/sym A B f e) dA

  is-decidable/Equiv (A B : U) (e : Equiv A B) (dB : is-decidable B) : is-decidable A =
    Coprod/map B (neg B) A (neg A)
               (Equiv/inv-map A B e)
               (\ f a. f ((Equiv/map A B e) a)) dB

  is-decidable/Equiv' (A B : U) (e : Equiv A B) (dA : is-decidable A) : is-decidable B =
    is-decidable/Equiv B A (Equiv/sym A B e) dA
#+end_src

*** Equality decidability is closed under equivalences
We show that if =A= and =B= are equivalent, then =A= has decidable equality iff =B= has decidable equality.
#+begin_src ctt
  has-decidable-equality/is-equiv (A B : U) (f : A -> B) (e : is-equiv A B f) (dB : has-decidable-equality B) : has-decidable-equality A =
    \ x y.
      let eq-A : U = (Path A x y)
          eq-B : U = (Path B (f x) (f y)) 
          g : B -> A = is-equiv/inv-map A B f e
          p : Path (A -> A) (\ z. g (f z)) (id A) = eq-htpy A A (\ z. g (f z)) (id A) (is-equiv/inv-left-htpy A B f e)
          h : Path B (f x) (f y) -> Path A x y = \ q. (tr (A -> A) (\ z. g (f z)) (id A) p (\ i. Path A (i x) (i y)) (ap B A g (f x) (f y) q))
      in
      Coprod/map eq-B (neg eq-B) eq-A (neg eq-A) h
                      (\ i q. i (ap A B f x y q)) (dB (f x) (f y))

  has-decidable-equality/is-equiv' (A B : U) (f : A -> B) (e : is-equiv A B f) (dA : has-decidable-equality A) : has-decidable-equality B =
    has-decidable-equality/is-equiv B A (is-equiv/inv-map A B f e) (is-equiv/inv-is-equiv A B f e) dA

  has-decidable-equality/Equiv (A B : U) (e : Equiv A B) (dB : has-decidable-equality B) : has-decidable-equality A =
    has-decidable-equality/is-equiv A B (Equiv/map A B e) (Equiv/is-equiv A B e) dB

  has-decidable-equality/Equiv' (A B : U) (e : Equiv A B) (dA : has-decidable-equality A) : has-decidable-equality B =
    has-decidable-equality/is-equiv' A B (Equiv/map A B e) (Equiv/is-equiv A B e) dA
#+end_src

*** Equivalent types have equivalent identity types
If =A= and =B= are two equivalent types, then there is also an equivalence between their identity types.
#+begin_src ctt
  is-equiv/is-equiv-id (A B : U) (f : A -> B) (e : is-equiv A B f) (x y : A)
                            : is-equiv (Path A x y) (Path B (f x) (f y)) (ap A B f x y) =
    is-bi-inv/is-equiv (Path A x y) (Path B (f x) (f y)) (ap A B f x y)
                       (ap/closure-bi-inv A B f (is-equiv/is-bi-inv A B f e) x y)

  Equiv/Equiv-id (A B : U) (e : Equiv A B) (x y : A) : Equiv (Path A x y) (Path B (Equiv/map A B e x) (Equiv/map A B e y)) =
    (ap A B (Equiv/map A B e) x y, is-equiv/is-equiv-id A B (Equiv/map A B e) (Equiv/is-equiv A B e) x y)
#+end_src

#+RESULTS:
: Typecheck has succeeded.

** 3-for-2 properties
*** 3-for-2 property of contractibility
Given =f : A \to B=, the 3-for-2 property of contractibility states that if any two of the three assertions
  * =A= is contractible
  * =B= is contractible
  * =f= is an equivalence
hold, then so does the third. We start by showing that if one of =A= or =B= is contractible and =f= is an equivalence, then the other is also contractible. It is easy: take the center of the contraction to be the =x= such that =f x = b= (given by the center of the equivalence), and the path is obtained using the contractibility of the fibrations of =f=.
#+begin_src ctt
  is-contr/is-contr-equiv (A B : U) (e : Equiv A B) (c : is-contr B) : is-contr A =
    let b : B = center B c
        f : A -> B = Equiv/map A B e
        fc : Fib A B f b = (center (Fib A B f b) (Equiv/is-equiv A B e b))
        x : A = fc.1
        p : (y : A) -> Path A x y = \ y. Sg-path/left A (\ z. Path B b (f z)) fc (y, contraction B c (f y)) ((Equiv/is-equiv A B e b).2 (y, contraction B c (f y)))
    in (x, p)
#+end_src
The other side is trivial.
#+begin_src ctt
  is-contr/is-contr-equiv' (A B : U) (e : Equiv A B) (c : is-contr A) : is-contr B =
    is-contr/is-contr-equiv B A (Equiv/sym A B e) c
#+end_src
Now, if two types are contractible, they are obviously equivalent: they both hold only one object, thus there is a trivial bijection between them.
#+begin_src ctt
  is-contr/is-equiv-contr (A B : U) (cA : is-contr A) (cB : is-contr B) : Equiv A B =
    is-bi-inv/Equiv A B (is-bi-inv/is-bi-inv-contr-map A B cB) (is-bi-inv/is-bi-inv-contr A B cA cB)
#+end_src

#+RESULTS:
: Typecheck has succeeded.
** Equivalences between types
*** =Coprod Empty A=
There is a bi-invertible map between =Coprod Empty A= and =A=.
#+begin_src ctt
  is-equiv/is-bi-inv-copr-empty-type-map (A : U) : Coprod Empty A -> A = split
    inl x -> ex-falso A x
    inr y -> y

  is-equiv/is-bi-inv-copr-empty-type-inv-map (A : U) : A -> Coprod Empty A = \ x. inr x

  is-equiv/is-bi-inv-copr-empty-type-left-htpy (A : U) : Htpy' (Coprod Empty A) (Coprod Empty A)
                                                               (\ z. (is-equiv/is-bi-inv-copr-empty-type-inv-map A) (is-equiv/is-bi-inv-copr-empty-type-map A z)) (id (Coprod Empty A)) = split
    inl x -> ex-falso (Path (Coprod Empty A) ((is-equiv/is-bi-inv-copr-empty-type-inv-map A) (is-equiv/is-bi-inv-copr-empty-type-map A (inl x))) (inl x)) x
    inr y -> refl (Coprod Empty A) (inr y)

  is-equiv/is-bi-inv-copr-empty-type (A : U) : is-bi-inv (Coprod Empty A) A (is-equiv/is-bi-inv-copr-empty-type-map A) =
    has-inverse-is-bi-inv (Coprod Empty A) A (is-equiv/is-bi-inv-copr-empty-type-map A)
      (is-equiv/is-bi-inv-copr-empty-type-inv-map A, (\ x. refl A x, is-equiv/is-bi-inv-copr-empty-type-left-htpy A))
#+end_src
That is, these types are equivalent.
#+begin_src ctt
  is-equiv/is-equiv-copr-empty-type (A : U) : is-equiv (Coprod Empty A) A (is-equiv/is-bi-inv-copr-empty-type-map A) =
    is-bi-inv/is-equiv (Coprod Empty A) A (is-equiv/is-bi-inv-copr-empty-type-map A) (is-equiv/is-bi-inv-copr-empty-type A)

  Equiv/Equiv-copr-empty-type (A : U) : Equiv (Coprod Empty A) A =
    (is-equiv/is-bi-inv-copr-empty-type-map A, is-equiv/is-equiv-copr-empty-type A)
#+end_src
*** =Coprod= is commutative
As expected, there is a bi-invertible map between =Coprod A B= and =Coprod B A=.
    #+begin_src ctt
  is-equiv/is-bi-inv-comm-copr-map (A B : U) : Coprod A B -> Coprod B A = split
    inl x -> inr x
    inr y -> inl y

  is-equiv/is-bi-inv-comm-copr-map-htpy (A B : U) : Htpy' (Coprod B A) (Coprod B A) 
                                                          (\ z. (is-equiv/is-bi-inv-comm-copr-map A B) (is-equiv/is-bi-inv-comm-copr-map B A z)) (id (Coprod B A)) = split
    inl x -> refl (Coprod B A) (inl x)
    inr y -> refl (Coprod B A) (inr y)

  is-equiv/is-bi-inv-comm-copr (A B : U) : is-bi-inv (Coprod A B) (Coprod B A) (is-equiv/is-bi-inv-comm-copr-map A B) =
    has-inverse-is-bi-inv (Coprod A B) (Coprod B A) (is-equiv/is-bi-inv-comm-copr-map A B)
      (is-equiv/is-bi-inv-comm-copr-map B A, (is-equiv/is-bi-inv-comm-copr-map-htpy A B, is-equiv/is-bi-inv-comm-copr-map-htpy B A))
    #+end_src
That is, =Coprod= is commutative.
#+begin_src ctt
  is-equiv/commutative-coprod (A B : U) : is-equiv (Coprod A B) (Coprod B A) (is-equiv/is-bi-inv-comm-copr-map A B) =
    is-bi-inv/is-equiv (Coprod A B) (Coprod B A) (is-equiv/is-bi-inv-comm-copr-map A B) (is-equiv/is-bi-inv-comm-copr A B)

  Equiv/commutative-coprod (A B : U) : Equiv (Coprod A B) (Coprod B A) =
    (is-equiv/is-bi-inv-comm-copr-map A B, is-equiv/commutative-coprod A B)  
#+end_src

*** =Coprod A Empty=
As such, =Coprod A Empty= is also equivalent to =A=.
#+begin_src ctt
  Equiv/Equiv-copr-type-empty (A : U) : Equiv (Coprod A Empty) A =
    Equiv/trans (Coprod A Empty) (Coprod Empty A) A (Equiv/commutative-coprod A Empty) (Equiv/Equiv-copr-empty-type A)
#+end_src
TODO: this loops infinitely (but it typechecks!)?

#+RESULTS:
: Typecheck has succeeded.
