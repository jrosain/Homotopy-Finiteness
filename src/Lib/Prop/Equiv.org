#+NAME: Equiv
#+AUTHOR: Johann Rosain

* Equivalence Properties

  #+begin_src ctt
  module Lib.Prop.Equiv where
  #+end_src

This file regroups the properties of =Equiv= and =is-equiv= that are not provided by the standard library.

** Packages imports

   #+begin_src ctt
  import Lib.Prop.Contr
  import Lib.Prop.Sg
  import Lib.Data.Map
   #+end_src

** Accessors
   #+begin_src ctt
  Equiv/map (A B : U) (e : Equiv A B) : A -> B = e.1
  Equiv/is-equiv (A B : U) (e : Equiv A B) : is-equiv A B (Equiv/map A B e) = e.2    
   #+end_src
** Equivalence relation properties

=is-equiv= and =Equiv= are equivalence relations, that is, they are:
   * reflexive ;
   * symmetric ;
   * transitive.
The first property is handled in [[../Stdlib/Prelude.ctt][Prelude.ctt]], but we redefine them here with a name consistent with the others properties: =is-equiv/prop= (resp. =Equiv/prop=). Then, we focus on showing the symmetry and the transitivity of this relation.

*** Reflexivity

    #+begin_src ctt
  is-equiv/refl (A : U) : is-equiv A A (id A)
    = id/is-equiv A

  Equiv/refl (A : U) : Equiv A A
    = IdEquiv A
    #+end_src

*** Symmetry
**** Symmetry of =is-equiv=

    #+begin_src ctt
    
    #+end_src

**** Symmetry of =Equiv=

     #+begin_src ctt
  Equiv/sym (A B : U) (e : Equiv A B) : Equiv B A =
    path-to-equiv B A (inv U A B (equiv-to-path A B e))
    #+end_src

*** Transitivity
**** Transitivity of =is-equiv=

First, we show that =is-equiv= is transitive. To show that a map is an equivalence, it suffices to prove that its fibers are contractible. 

The center of contraction is the pair =(x, p)= where =x= is the preimage by =f= of =z=, that is the preimage of =y= by =g= and =p= is simply the path concatenation of y \to g z \to g (f x) where the first path is obtained using the center of =is-equiv g= and the second is obtained using =ap= over =is-equiv f=.
    #+begin_src ctt
    is-equiv/trans/center (A B C : U) (f : A -> B) (e-f : is-equiv A B f) (g : B -> C) (e-g : is-equiv B C g) (y : C)
      : Fib A C (map/comp A B C g f) y =
      let z : B = (center (Fib B C g y) (e-g y)).1 in
      let x : A = (center (Fib A B f z) (e-f z)).1 in
      (x,
       comp C y (g z) (center (Fib B C g y) (e-g y)).2
                (g (f x)) (ap B C g z (f x) (center (Fib A B f z) (e-f z)).2))
#+end_src
Then, we may obtain a path between dependent pairs =u, v= by giving a path =p= between =u.1, v.1= and showing that =is-contr= is a proposition (that is, we don't need to show that there is a path between =u.2= and =v.2=). First, we show that from a fibration from =A= to =C=, we can obtain a fibration from =A= to =B=.
#+begin_src ctt
  is-equiv/trans/fib (A B C : U) (f : A -> B) (g : B -> C) (y : C) (H : Fib A C (map/comp A B C g f) y)
    : Fib A B f (f H.1) = (H.1, refl B (f H.1))
#+end_src
This enables us to show that there is a path between the first element of =is-equiv/trans/center= and the first element of any fibration from =A= to =C= for =g=. Indeed, the first element of =is-equiv/trans/center= is the center of contraction of =is-equiv f=, that is, we have a proof that the first element of any fibration of =f= is equal to it. We use the previous lemma to find a fibration for =f= from a fibration for =g \circ f= and it allows us to conclude.
    #+begin_src ctt
  is-equiv/trans/contr/proj1 (A B C : U) (f : A -> B) (e-f : is-equiv A B f) (g : B -> C) (e-g : is-equiv B C g) (y : C) (H : Fib A C (map/comp A B C g f) y)
   : Path A (e-f (f H.1)).1.1 H.1 =
    let x : A = (is-equiv/trans/center A B C f e-f g e-g y).1 in
    let x' : A = H.1 in
    let c : is-contr (Fib A B f (f x')) = e-f (f x') in
    let fib' : Fib A B f (f x') = is-equiv/trans/fib A B C f g y H in
    (Sg-path/left A (\ z. Path B (f x') (f z)) c.1 fib' (c.2 fib'))
#+end_src

Finally, we can show that =is-equiv= is transitive.
#+begin_src ctt
  -- is-equiv/trans (A B C : U) (f : A -> B) (e-f : is-equiv A B f) (g : B -> C) (e-g : is-equiv B C g) :
  --   is-equiv (map/comp g f) =
  --     \ y. (is-equiv/trans/center A B C f e-f g e-g y, is-equiv/trans/contr A B C f e-f g e-g y)
#+end_src

**** Transitivity of =Equiv=
 
There are two ways to show the transitivity of =Equiv=. The first is using univalence, i.e., an equivalence is a path. To do so, we use the following facts:
   * an equivalence is a path (=equiv-to-path=) ;
   * a path is an equivalence (=path-to-equiv=) ;
   * paths can be concatenated (=comp=).
   #+begin_src ctt
  Equiv/trans (A B C : U) (e-AB : Equiv A B) (e-BC : Equiv B C) : Equiv A C =
     path-to-equiv A C (comp U A B (equiv-to-path A B e-AB) C (equiv-to-path B C e-BC))
   #+end_src

The second is to directly use that =is-equiv= is transitive, the equivalence map being the composition between the two equivalences.
#+begin_src ctt
  -- Equiv/trans'
#+end_src
