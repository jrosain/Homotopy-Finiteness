#+NAME: Equiv
#+AUTHOR: Johann Rosain

* Equivalence Properties

  #+begin_src ctt
  module Lib.Prop.Equiv where
  #+end_src

This file regroups the properties of =Equiv= and =is-equiv= that are not provided by the standard library.

** Packages imports

   #+begin_src ctt
  import Lib.Prop.Contr
  import Lib.Prop.Sg
  import Lib.Data.Map
  import Lib.Data.Empty
  import Lib.Data.Decidability  
  import Lib.QInv
  import Lib.ContrMap
   #+end_src

** Accessors
   #+begin_src ctt
  Equiv/map (A B : U) (e : Equiv A B) : A -> B = e.1
  Equiv/is-equiv (A B : U) (e : Equiv A B) : is-equiv A B (Equiv/map A B e) = e.2    
   #+end_src

** Inverse of an equivalence
We can define the inverse map of an equivalence.
#+begin_src ctt
  is-equiv/inv-map (A B : U) (f : A -> B) (e : is-equiv A B f) : B -> A =
    is-bi-inv/inv-map A B f (is-equiv/is-bi-inv A B f e)

  Equiv/inv-map (A B : U) (e : Equiv A B) : B -> A =
    is-equiv/inv-map A B (Equiv/map A B e) (Equiv/is-equiv A B e)
#+end_src
Futhermore, this inverse map is also an equivalence.
#+begin_src ctt
  is-equiv/inv-is-equiv (A B : U) (f : A -> B) (e : is-equiv A B f) : is-equiv B A (is-equiv/inv-map A B f e) =
    is-bi-inv/is-equiv-is-equiv-left-map B A f (is-equiv/is-bi-inv A B f e)

  Equiv/inv-equiv (A B : U) (e : Equiv A B) : Equiv B A =
    (Equiv/inv-map A B e, is-equiv/inv-is-equiv A B (Equiv/map A B e) (Equiv/is-equiv A B e))
#+end_src

** Equivalence relation properties

=is-equiv= and =Equiv= are equivalence relations, that is, they are:
   * reflexive ;
   * symmetric ;
   * transitive.
The first property is handled in [[../Stdlib/Prelude.ctt][Prelude.ctt]], but we redefine them here with a name consistent with the others properties: =is-equiv/prop= (resp. =Equiv/prop=). Then, we focus on showing the symmetry and the transitivity of this relation.

*** Reflexivity

    #+begin_src ctt
  is-equiv/refl (A : U) : is-equiv A A (id A)
    = id/is-equiv A

  Equiv/refl (A : U) : Equiv A A
    = IdEquiv A
    #+end_src

*** Symmetry

     #+begin_src ctt
  is-equiv/sym : (A B : U) -> (f : A -> B) -> (e : is-equiv A B f) -> is-equiv B A (is-equiv/inv-map A B f e) = is-equiv/inv-is-equiv 

  Equiv/sym : (A B : U) -> (e : Equiv A B) -> Equiv B A = Equiv/inv-equiv
    #+end_src

*** Transitivity

    #+begin_src ctt
  is-equiv/trans (A B C : U) (f : A -> B) (g : B -> C) (eF : is-equiv A B f) (eG : is-equiv B C g) : is-equiv A C (map/comp A B C g f) =
    is-bi-inv/is-equiv A C (map/comp A B C g f)
                           (is-bi-inv/comp-is-bi-inv A B C f g (is-equiv/is-bi-inv A B f eF) (is-equiv/is-bi-inv B C g eG))

  Equiv/trans (A B C : U) (e-AB : Equiv A B) (e-BC : Equiv B C) : Equiv A C =
    (map/comp A B C (Equiv/map B C e-BC) (Equiv/map A B e-AB), is-equiv/trans A B C (Equiv/map A B e-AB) (Equiv/map B C e-BC) (Equiv/is-equiv A B e-AB) (Equiv/is-equiv B C e-BC))
    #+end_src

** Some facts on equivalences

*** A map to =Empty= is always an equivalence

First, we show that if =f : is-empty A=, then =is-equiv f=. Hence, we are given an element of =Empty= and thus ex-falso suffices to show that the fibers of =f= are contractible.
    #+begin_src ctt
  is-empty/is-equiv (A : U) (f : is-empty A) : is-equiv A Empty f =
    \ x. ind-Empty (\ y. is-contr (Fib A Empty f y)) x
    #+end_src
Thus, if =is-empty A=, we have an equivalence between =A= and =Empty=.
#+begin_src ctt
  Empty/equiv (A : U) (f : is-empty A) : Equiv A Empty =
    (f, is-empty/is-equiv A f)
#+end_src

*** Decidability is closed under equivalences 
We show that if =A= and =B= are equivalent, then =A= is decidable iff =B= is decidable.
#+begin_src ctt
  is-decidable/Equiv (A B : U) (e : Equiv A B) (dB : is-decidable B) : is-decidable A =
    Coprod/map B (neg B) A (neg A)
               (Equiv/inv-map A B e)
               (\ f a. f ((Equiv/map A B e) a)) dB

  is-decidable/Equiv' (A B : U) (e : Equiv A B) (dA : is-decidable A) : is-decidable B =
    is-decidable/Equiv B A (Equiv/sym A B e) dA
#+end_src
TODO: show the same thing for =is-equiv= once we can easily get its inverse.

*** Equality decidability is closed under equivalences
We show that if =A= and =B= are equivalent, then =A= has decidable equality iff =B= has decidable equality.
#+begin_src ctt
  -- has-decidable-equality/Equiv (A B : U) (e : Equiv A B) (dB : has-decidable-equality B) : has-decidable-equality A =
  --   \ x y.
  --     let eq-B = (Path B (Map/Equiv x) (Map/Equiv y))
  --         eq-A = (Path A x y) in
  --    Coprod/map eq-B (neg eq-B) eq-A (neg eq-A)
  --               (\ p. 
#+end_src
TODO: needs that =Map/Equiv e \circ Map/inv-Equiv e ~ id=.

#+RESULTS:
: Typecheck has succeeded.

** 3-for-2 properties
*** 3-for-2 property of contractibility
Given =f : A \to B=, the 3-for-2 property of contractibility states that if any two of the three assertions
  * =A= is contractible
  * =B= is contractible
  * =f= is an equivalence
hold, then so does the third. We start by showing that if one of =A= or =B= is contractible and =f= is an equivalence, then the other is also contractible. It is easy: take the center of the contraction to be the =x= such that =f x = b= (given by the center of the equivalence), and the path is obtained using the contractibility of the fibrations of =f=.
#+begin_src ctt
  is-contr/is-contr-equiv (A B : U) (e : Equiv A B) (c : is-contr B) : is-contr A =
    let b : B = center B c
        f : A -> B = Equiv/map A B e
        fc : Fib A B f b = (center (Fib A B f b) (Equiv/is-equiv A B e b))
        x : A = fc.1
        p : (y : A) -> Path A x y = \ y. Sg-path/left A (\ z. Path B b (f z)) fc (y, contraction B c (f y)) ((Equiv/is-equiv A B e b).2 (y, contraction B c (f y)))
    in (x, p)
#+end_src
The other side is trivial.
#+begin_src ctt
  is-contr/is-contr-equiv' (A B : U) (e : Equiv A B) (c : is-contr A) : is-contr B =
    is-contr/is-contr-equiv B A (Equiv/sym A B e) c
#+end_src
Now, if two types are contractible, they are obviously equivalent: they both hold only one object, thus there is a trivial bijection between them.
#+begin_src ctt
  is-contr/is-equiv-contr (A B : U) (cA : is-contr A) (cB : is-contr B) : Equiv A B =
    is-bi-inv/Equiv A B (is-bi-inv/is-bi-inv-contr-map A B cB) (is-bi-inv/is-bi-inv-contr A B cA cB)
#+end_src

#+RESULTS:
: Typecheck has succeeded.
