#+NAME: Equiv
#+AUTHOR: Johann Rosain

* Equivalence Properties

  #+begin_src ctt
  module Lib.Prop.Equiv where
  #+end_src

This file regroups the properties of =Equiv= and =is-equiv= that are not provided by the standard library.

** Packages imports

   #+begin_src ctt
  import Lib.Prop.Contr
  import Lib.Prop.Sg
  import Lib.Data.Map
  import Lib.Data.Empty
  import Lib.Data.Decidability  
  import Lib.QInv
  import Lib.ContrMap
  import Lib.Prop.Paths
  import Lib.Prop.Unit
   #+end_src

** Accessors
   #+begin_src ctt
  Equiv/map (A B : U) (e : Equiv A B) : A -> B = e.1
  Equiv/is-equiv (A B : U) (e : Equiv A B) : is-equiv A B (Equiv/map A B e) = e.2    
   #+end_src

** Inverse of an equivalence
We can define the inverse map of an equivalence.
#+begin_src ctt
  is-equiv/inv-map (A B : U) (f : A -> B) (e : is-equiv A B f) : B -> A =
    \ y. (e y).1.1

  Equiv/inv-map (A B : U) (e : Equiv A B) : B -> A =
    is-equiv/inv-map A B (Equiv/map A B e) (Equiv/is-equiv A B e)
#+end_src

Futhermore, this inverse map is also an equivalence.
#+begin_src ctt
  is-equiv/inv-left-htpy (A B : U) (f : A -> B) (e : is-equiv A B f) (x : A)
                              : Path A (is-equiv/inv-map A B f e (f x)) x =
    \ i. ((e (f x)).2 (x, refl B (f x)) i).1

  is-equiv/inv-right-htpy (A B : U) (f : A -> B) (e : is-equiv A B f) (y : B)
                               : Path B (f (is-equiv/inv-map A B f e y)) y =
    inv B y
      ( f (is-equiv/inv-map A B f e y))
      ( e y).1.2

  is-equiv/inv-is-equiv (A B : U) (f : A -> B) (e : is-equiv A B f) : is-equiv B A (is-equiv/inv-map A B f e) =
    has-inverse/is-equiv B A
      ( is-equiv/inv-map A B f e)
      ( f,
        ( is-equiv/inv-left-htpy A B f e,
          is-equiv/inv-right-htpy A B f e))

  Equiv/inv-equiv (A B : U) (e : Equiv A B) : Equiv B A =
    ( Equiv/inv-map A B e,
      is-equiv/inv-is-equiv A B
        ( Equiv/map A B e)
        ( Equiv/is-equiv A B e))
#+end_src
Moreover, we get the nice properties of inverse maps.
#+begin_src ctt
  Equiv/inv-right-htpy (A B : U) (e : Equiv A B) : Htpy' B B (\ z. (Equiv/map A B e) (Equiv/inv-map A B e z)) (id B) =
    is-equiv/inv-right-htpy A B (Equiv/map A B e) (Equiv/is-equiv A B e)

  Equiv/inv-left-htpy (A B : U) (e : Equiv A B) : Htpy' A A (\ z. (Equiv/inv-map A B e) (Equiv/map A B e z)) (id A) =
    is-equiv/inv-left-htpy A B (Equiv/map A B e) (Equiv/is-equiv A B e)
#+end_src

** Equivalence relation properties

=is-equiv= and =Equiv= are equivalence relations, that is, they are:
   * reflexive ;
   * symmetric ;
   * transitive.
The first property is handled in [[../Stdlib/Prelude.ctt][Prelude.ctt]], but we redefine them here with a name consistent with the others properties: =is-equiv/prop= (resp. =Equiv/prop=). Then, we focus on showing the symmetry and the transitivity of this relation.

*** Reflexivity

    #+begin_src ctt
  is-equiv/refl (A : U) : is-equiv A A (id A)
    = id/is-equiv A

  Equiv/refl (A : U) : Equiv A A
    = IdEquiv A
    #+end_src

*** Symmetry

     #+begin_src ctt
  is-equiv/sym : (A B : U) -> (f : A -> B) -> (e : is-equiv A B f) -> is-equiv B A (is-equiv/inv-map A B f e) = is-equiv/inv-is-equiv 

  Equiv/sym : (A B : U) -> (e : Equiv A B) -> Equiv B A = Equiv/inv-equiv
    #+end_src

*** Transitivity

    #+begin_src ctt
  is-equiv/trans (A B C : U) (f : A -> B) (g : B -> C) (eF : is-equiv A B f) (eG : is-equiv B C g) : is-equiv A C (map/comp A B C g f) =
    is-bi-inv/is-equiv A C (map/comp A B C g f)
                           (is-bi-inv/comp-is-bi-inv A B C f g (is-equiv/is-bi-inv A B f eF) (is-equiv/is-bi-inv B C g eG))

  Equiv/trans (A B C : U) (e-AB : Equiv A B) (e-BC : Equiv B C) : Equiv A C =
    (map/comp A B C (Equiv/map B C e-BC) (Equiv/map A B e-AB), is-equiv/trans A B C (Equiv/map A B e-AB) (Equiv/map B C e-BC) (Equiv/is-equiv A B e-AB) (Equiv/is-equiv B C e-BC))
    #+end_src

** Some facts on equivalences

*** A map to =Empty= is always an equivalence

First, we show that if =f : is-empty A=, then =is-equiv f=. Hence, we are given an element of =Empty= and thus ex-falso suffices to show that the fibers of =f= are contractible.
    #+begin_src ctt
  is-empty/is-equiv (A : U) (f : is-empty A) : is-equiv A Empty f =
    \ x. ind-Empty (\ y. is-contr (Fib A Empty f y)) x
    #+end_src
Thus, if =is-empty A=, we have an equivalence between =A= and =Empty=.
#+begin_src ctt
  Empty/equiv (A : U) (f : is-empty A) : Equiv A Empty =
    (f, is-empty/is-equiv A f)
#+end_src

*** Decidability is closed under equivalences 
We show that if =A= and =B= are equivalent, then =A= is decidable iff =B= is decidable.
#+begin_src ctt
  is-decidable/is-equiv (A B : U) (f : A -> B) (e : is-equiv A B f) (dB : is-decidable B) : is-decidable A =
    Coprod/map B (neg B) A (neg A)
               (is-equiv/inv-map A B f e)
               (\ g a. g (f a)) dB

  is-decidable-is-equiv' (A B : U) (f : A -> B) (e : is-equiv A B f) (dA : is-decidable A) : is-decidable B =
    is-decidable/is-equiv B A (is-equiv/inv-map A B f e) (is-equiv/sym A B f e) dA

  is-decidable/Equiv (A B : U) (e : Equiv A B) (dB : is-decidable B) : is-decidable A =
    Coprod/map B (neg B) A (neg A)
               (Equiv/inv-map A B e)
               (\ f a. f ((Equiv/map A B e) a)) dB

  is-decidable/Equiv' (A B : U) (e : Equiv A B) (dA : is-decidable A) : is-decidable B =
    is-decidable/Equiv B A (Equiv/sym A B e) dA
#+end_src

*** Equality decidability is closed under equivalences
We show that if =A= and =B= are equivalent, then =A= has decidable equality iff =B= has decidable equality.
#+begin_src ctt
  has-decidable-equality/is-equiv (A B : U) (f : A -> B) (e : is-equiv A B f) (dB : has-decidable-equality B) : has-decidable-equality A =
    \ x y.
      let eq-A : U = (Path A x y)
          eq-B : U = (Path B (f x) (f y)) 
          g : B -> A = is-equiv/inv-map A B f e
          p : Path (A -> A) (\ z. g (f z)) (id A) = eq-htpy A (\ _. A) (\ z. g (f z)) (id A) (is-equiv/inv-left-htpy A B f e)
          h : Path B (f x) (f y) -> Path A x y = \ q. (tr (A -> A) (\ z. g (f z)) (id A) p (\ i. Path A (i x) (i y)) (ap B A g (f x) (f y) q))
      in
      Coprod/map eq-B (neg eq-B) eq-A (neg eq-A) h
                      (\ i q. i (ap A B f x y q)) (dB (f x) (f y))

  has-decidable-equality/is-equiv' (A B : U) (f : A -> B) (e : is-equiv A B f) (dA : has-decidable-equality A) : has-decidable-equality B =
    has-decidable-equality/is-equiv B A (is-equiv/inv-map A B f e) (is-equiv/inv-is-equiv A B f e) dA

  has-decidable-equality/Equiv (A B : U) (e : Equiv A B) (dB : has-decidable-equality B) : has-decidable-equality A =
    has-decidable-equality/is-equiv A B (Equiv/map A B e) (Equiv/is-equiv A B e) dB

  has-decidable-equality/Equiv' (A B : U) (e : Equiv A B) (dA : has-decidable-equality A) : has-decidable-equality B =
    has-decidable-equality/is-equiv' A B (Equiv/map A B e) (Equiv/is-equiv A B e) dA
#+end_src

#+RESULTS:
: Typecheck has succeeded.

*** Equivalent types have equivalent identity types
If =A= and =B= are two equivalent types, then there is also an equivalence between their identity types.
#+begin_src ctt
  Equiv/Equiv-id (A B : U) (e : Equiv A B) (x y : A) : Equiv (Path A x y) (Path B (Equiv/map A B e x) (Equiv/map A B e y)) =
    (ap A B (Equiv/map A B e) x y, Equiv/is-inj A B (Equiv/map A B e) (Equiv/is-equiv A B e) x y)
#+end_src

** Chain of equivalences
A comp-like chaining of equivalences.
#+begin_src ctt
  Equiv/comp/type (A : U) : Nat -> U -> U = split
    zero -> \ B. Equiv A B
    suc n -> \ B. (C : U) (e : Equiv B C) -> Equiv/comp/type A n C  

  Equiv/comp : (n : Nat) (A : U) (B : U) (e : Equiv A B) -> Equiv/comp/type A n B = split
    zero -> \ _ _ e. e
    suc n -> \ A B e C e'. Equiv/comp n A C (Equiv/trans A B C e e')
#+end_src

** 3-for-2 properties

*** 3-for-2 property of equiv closure under composition
Given f : A \to B and g : B \to C the 3-for-2 property of equivalence closure under composition states that if any two of the three assertions
  * f is an equivalence
  * g is an equivalence
  * g \circ f is an equivalence
hold, then so does the third.
#+begin_src ctt
  is-equiv/comp-is-equiv (A B C : U) (f : A -> B) (g : B -> C) (e : is-equiv A B f) (e' : is-equiv B C g)
                                : is-equiv A C (\ z. g (f z)) =
    is-bi-inv/is-equiv A C
      ( \ z. g (f z))
      ( is-bi-inv/comp-is-bi-inv A B C f g
          ( is-equiv/is-bi-inv A B f e)
          ( is-equiv/is-bi-inv B C g e'))

  is-equiv/comp-left-is-equiv (A B C : U) (f : A -> B) (g : B -> C) (e : is-equiv B C g) (e' : is-equiv A C (\ z. g (f z)))
                                     : is-equiv A B f =
    is-bi-inv/is-equiv A B f
      ( is-bi-inv/is-bi-inv-comp-left A B C f g
        ( is-equiv/is-bi-inv B C g e)
        ( is-equiv/is-bi-inv A C (\ z. g (f z)) e'))

  is-equiv/comp-right-is-equiv (A B C : U) (f : A -> B) (g : B -> C) (e : is-equiv A B f) (e' : is-equiv A C (\ z. g (f z)))
                                      : is-equiv B C g =
    is-bi-inv/is-equiv B C g
      ( is-bi-inv/is-bi-inv-comp-right A B C f g
        ( is-equiv/is-bi-inv A B f e)
        ( is-equiv/is-bi-inv A C (\ z. g (f z)) e'))  
#+end_src

*** 3-for-2 property of contractibility
Given =f : A \to B=, the 3-for-2 property of contractibility states that if any two of the three assertions
  * =A= is contractible
  * =B= is contractible
  * =f= is an equivalence
hold, then so does the third. We start by showing that if one of =A= or =B= is contractible and =f= is an equivalence, then the other is also contractible. It is easy: take the center of the contraction to be the =x= such that =f x = b= (given by the center of the equivalence), and the path is obtained using the contractibility of the fibrations of =f=.
#+begin_src ctt
  is-contr/is-contr-equiv (A B : U) (e : Equiv A B) (c : is-contr B) : is-contr A =
    let b : B = center B c
        f : A -> B = Equiv/map A B e
        fc : Fib A B f b = (center (Fib A B f b) (Equiv/is-equiv A B e b))
        x : A = fc.1
        p : (y : A) -> Path A x y = \ y. Sg-path/left A (\ z. Path B b (f z)) fc (y, contraction B c (f y)) ((Equiv/is-equiv A B e b).2 (y, contraction B c (f y)))
    in (x, p)
#+end_src
The other side is trivial.
#+begin_src ctt
  is-contr/is-contr-equiv' (A B : U) (e : Equiv A B) (c : is-contr A) : is-contr B =
    is-contr/is-contr-equiv B A (Equiv/sym A B e) c
#+end_src
Now, if two types are contractible, they are obviously equivalent: they both hold only one object, thus there is a trivial bijection between them.
#+begin_src ctt
  is-contr/Equiv (A B : U) (cA : is-contr A) (cB : is-contr B) : Equiv A B =
    is-bi-inv/Equiv A B (is-bi-inv/is-bi-inv-contr-map A B cB) (is-bi-inv/is-bi-inv-contr A B cA cB)

  is-contr/is-equiv (A B : U) (f : A -> B) (cA : is-contr A) (cB : is-contr B) : is-equiv A B f =
    is-bi-inv/is-equiv A B f (is-bi-inv/is-bi-inv-contr' A B f cA cB)
#+end_src

** Equivalences between types
*** =Coprod Empty A=
There is a bi-invertible map between =Coprod Empty A= and =A=.
#+begin_src ctt
  is-equiv/is-bi-inv-copr-empty-type-map (A : U) : Coprod Empty A -> A = split
    inl x -> ex-falso A x
    inr y -> y

  is-equiv/is-bi-inv-copr-empty-type-inv-map (A : U) : A -> Coprod Empty A = \ x. inr x

  is-equiv/is-bi-inv-copr-empty-type-left-htpy (A : U) : Htpy' (Coprod Empty A) (Coprod Empty A)
                                                               (\ z. (is-equiv/is-bi-inv-copr-empty-type-inv-map A) (is-equiv/is-bi-inv-copr-empty-type-map A z)) (id (Coprod Empty A)) = split
    inl x -> ex-falso (Path (Coprod Empty A) ((is-equiv/is-bi-inv-copr-empty-type-inv-map A) (is-equiv/is-bi-inv-copr-empty-type-map A (inl x))) (inl x)) x
    inr y -> refl (Coprod Empty A) (inr y)

  is-equiv/is-bi-inv-copr-empty-type (A : U) : is-bi-inv (Coprod Empty A) A (is-equiv/is-bi-inv-copr-empty-type-map A) =
    has-inverse-is-bi-inv (Coprod Empty A) A (is-equiv/is-bi-inv-copr-empty-type-map A)
      (is-equiv/is-bi-inv-copr-empty-type-inv-map A, (\ x. refl A x, is-equiv/is-bi-inv-copr-empty-type-left-htpy A))
#+end_src
That is, these types are equivalent.
#+begin_src ctt
  is-equiv/is-equiv-copr-empty-type (A : U) : is-equiv (Coprod Empty A) A (is-equiv/is-bi-inv-copr-empty-type-map A) =
    is-bi-inv/is-equiv (Coprod Empty A) A (is-equiv/is-bi-inv-copr-empty-type-map A) (is-equiv/is-bi-inv-copr-empty-type A)

  Equiv/Equiv-copr-empty-type (A : U) : Equiv (Coprod Empty A) A =
    (is-equiv/is-bi-inv-copr-empty-type-map A, is-equiv/is-equiv-copr-empty-type A)
#+end_src
*** =Coprod= is commutative
As expected, there is a bi-invertible map between =Coprod A B= and =Coprod B A=.
    #+begin_src ctt
  is-equiv/is-bi-inv-comm-copr-map (A B : U) : Coprod A B -> Coprod B A = split
    inl x -> inr x
    inr y -> inl y

  is-equiv/is-bi-inv-comm-copr-map-htpy (A B : U) : Htpy' (Coprod B A) (Coprod B A) 
                                                          (\ z. (is-equiv/is-bi-inv-comm-copr-map A B) (is-equiv/is-bi-inv-comm-copr-map B A z)) (id (Coprod B A)) = split
    inl x -> refl (Coprod B A) (inl x)
    inr y -> refl (Coprod B A) (inr y)

  is-equiv/is-bi-inv-comm-copr (A B : U) : is-bi-inv (Coprod A B) (Coprod B A) (is-equiv/is-bi-inv-comm-copr-map A B) =
    has-inverse-is-bi-inv (Coprod A B) (Coprod B A) (is-equiv/is-bi-inv-comm-copr-map A B)
      (is-equiv/is-bi-inv-comm-copr-map B A, (is-equiv/is-bi-inv-comm-copr-map-htpy A B, is-equiv/is-bi-inv-comm-copr-map-htpy B A))
    #+end_src
That is, =Coprod= is commutative.
#+begin_src ctt
  is-equiv/commutative-coprod (A B : U) : is-equiv (Coprod A B) (Coprod B A) (is-equiv/is-bi-inv-comm-copr-map A B) =
    is-bi-inv/is-equiv (Coprod A B) (Coprod B A) (is-equiv/is-bi-inv-comm-copr-map A B) (is-equiv/is-bi-inv-comm-copr A B)

  Equiv/commutative-coprod (A B : U) : Equiv (Coprod A B) (Coprod B A) =
    (is-equiv/is-bi-inv-comm-copr-map A B, is-equiv/commutative-coprod A B)  
#+end_src

*** =Coprod A Empty=
As such, =Coprod A Empty= is also equivalent to =A=.
#+begin_src ctt
  Equiv/Equiv-copr-type-empty (A : U) : Equiv (Coprod A Empty) A =
    Equiv/trans (Coprod A Empty) (Coprod Empty A) A (Equiv/commutative-coprod A Empty) (Equiv/Equiv-copr-empty-type A)
#+end_src
*** \Sigma Empty A is A
For any type family =A= over =Empty=, Sg Empty A is empty.
#+begin_src ctt
  Equiv/is-equiv-Sg-empty-map (A : Empty -> U) : (Sg Empty A) -> Empty =
    \ u. u.1

  Equiv/is-equiv-Sg-empty-inv-map (A : Empty -> U) : Empty -> (Sg Empty A) =
    \ x. (x, ex-falso (A x) x)

  Equiv/is-equiv-Sg-empty-right-htpy (A : Empty -> U) : Htpy' Empty Empty
                                                             (\ z. (Equiv/is-equiv-Sg-empty-map A) (Equiv/is-equiv-Sg-empty-inv-map A z))
                                                             (id Empty) = \ x. refl Empty x

  Equiv/is-equiv-Sg-empty-left-htpy (A : Empty -> U) : Htpy' (Sg Empty A) (Sg Empty A)
                                                            (\ z. (Equiv/is-equiv-Sg-empty-inv-map A) (Equiv/is-equiv-Sg-empty-map A z))
                                                            (id (Sg Empty A)) =
    \ u. ex-falso (Path (Sg Empty A) ((Equiv/is-equiv-Sg-empty-inv-map A) (Equiv/is-equiv-Sg-empty-map A u)) u) u.1

  Equiv/is-equiv-Sg-empty (A : Empty -> U) : is-equiv (Sg Empty A) Empty (Equiv/is-equiv-Sg-empty-map A) =
    has-inverse/is-equiv (Sg Empty A) Empty (Equiv/is-equiv-Sg-empty-map A)
      (Equiv/is-equiv-Sg-empty-inv-map A, (Equiv/is-equiv-Sg-empty-right-htpy A, Equiv/is-equiv-Sg-empty-left-htpy A))

  Equiv/Equiv-Sg-empty (A : Empty -> U) : Equiv (Sg Empty A) Empty =
    (Equiv/is-equiv-Sg-empty-map A, Equiv/is-equiv-Sg-empty A)
#+end_src
*** \Sigma distributes over coproduct
    #+begin_src ctt
  Equiv/Sg-distr-over-coprod-map/sg (A B : U) (C : (Coprod A B) -> U) : (z : Coprod A B) -> (C z) -> (Coprod (Sg A (\ x. C (inl x))) (Sg B (\ y. C (inr y)))) = split
    inl x -> \ c. inl (x, c)
    inr y -> \ c. inr (y, c)

  Equiv/Sg-distr-over-coprod-map (A B : U) (C : (Coprod A B) -> U) : (Sg (Coprod A B) C) -> (Coprod (Sg A (\ x. C (inl x))) (Sg B (\ y. C (inr y)))) =
    \ u. Equiv/Sg-distr-over-coprod-map/sg A B C u.1 u.2

  Equiv/Sg-distr-over-coprod-inv-map (A B : U) (C : (Coprod A B) -> U) : (Coprod (Sg A (\ x. C (inl x))) (Sg B (\ y. C (inr y)))) -> (Sg (Coprod A B) C) = split
    inl u -> (inl u.1, u.2)
    inr v -> (inr v.1, v.2)

  Equiv/Sg-distr-over-coprod-right-htpy (A B : U) (C : (Coprod A B) -> U) : Htpy' (Coprod (Sg A (\ x. C (inl x))) (Sg B (\ y. C (inr y))))
                                                                                 (Coprod (Sg A (\ x. C (inl x))) (Sg B (\ y. C (inr y))))
                                                                                 (\ z. (Equiv/Sg-distr-over-coprod-map A B C) (Equiv/Sg-distr-over-coprod-inv-map A B C z))
                                                                                 (id (Coprod (Sg A (\ x. C (inl x))) (Sg B (\ y. C (inr y))))) = split
    inl u -> refl (Coprod (Sg A (\ x. C (inl x))) (Sg B (\ y. C (inr y)))) (inl u)
    inr v -> refl (Coprod (Sg A (\ x. C (inl x))) (Sg B (\ y. C (inr y)))) (inr v)

  Equiv/Sg-distr-over-coprod-left-htpy/sg (A B : U) (C : (Coprod A B) -> U)
                                               : (z : (Coprod A B)) -> (c : C z) -> Path (Sg (Coprod A B) C)
                                                                                       ((Equiv/Sg-distr-over-coprod-inv-map A B C) (Equiv/Sg-distr-over-coprod-map A B C (z, c)))
                                                                                       (z, c) = split
    inl x -> \ c. refl (Sg (Coprod A B) C) (inl x, c)
    inr y -> \ c. refl (Sg (Coprod A B) C) (inr y, c)

  Equiv/Sg-distr-over-coprod-left-htpy (A B : U) (C : (Coprod A B) -> U) : Htpy' (Sg (Coprod A B) C) (Sg (Coprod A B) C)
                                                                                (\ z. (Equiv/Sg-distr-over-coprod-inv-map A B C) (Equiv/Sg-distr-over-coprod-map A B C z))
                                                                                (id (Sg (Coprod A B) C)) =
    \ u. Equiv/Sg-distr-over-coprod-left-htpy/sg A B C u.1 u.2

  Equiv/Sg-distr-over-coprod-is-equiv (A B : U) (C : (Coprod A B) -> U) : is-equiv (Sg (Coprod A B) C) (Coprod (Sg A (\ x. C (inl x))) (Sg B (\ y. C (inr y))))
                                                                                  (Equiv/Sg-distr-over-coprod-map A B C) =
    has-inverse/is-equiv (Sg (Coprod A B) C) (Coprod (Sg A (\ x. C (inl x))) (Sg B (\ y. C (inr y)))) (Equiv/Sg-distr-over-coprod-map A B C)
      (Equiv/Sg-distr-over-coprod-inv-map A B C, (Equiv/Sg-distr-over-coprod-right-htpy A B C, Equiv/Sg-distr-over-coprod-left-htpy A B C))


  Equiv/Sg-distr-over-coprod (A B : U) (C : (Coprod A B) -> U) : Equiv (Sg (Coprod A B) C) (Coprod (Sg A (\ x. C (inl x))) (Sg B (\ y. C (inr y)))) =
    (Equiv/Sg-distr-over-coprod-map A B C, Equiv/Sg-distr-over-coprod-is-equiv A B C)  
    #+end_src
*** \Sigma Unit A is (A star)
    #+begin_src ctt
  Equiv/Sg-unit-map/sg (A : Unit -> U) : (x : Unit) -> (A x) -> A star = split
    star -> (id (A star))

  Equiv/Sg-unit-map (A : Unit -> U) : (Sg Unit A) -> (A star) = \ u. Equiv/Sg-unit-map/sg A u.1 u.2

  Equiv/Sg-unit-inv-map (A : Unit -> U) : (A star) -> (Sg Unit A) = \ a. (star, a)

  Equiv/Sg-unit-right-htpy (A : Unit -> U) : Htpy' (A star) (A star) (\ z. (Equiv/Sg-unit-map A) (Equiv/Sg-unit-inv-map A z)) (id (A star)) =
    \ a. refl (A star) a

  Equiv/Sg-unit-left-htpy/sg (A : Unit -> U) : (x : Unit) -> (a : A x) -> Path (Sg Unit A) ((Equiv/Sg-unit-inv-map A) (Equiv/Sg-unit-map A (x, a))) (x, a) = split
    star -> \ a. refl (Sg Unit A) (star, a)

  Equiv/Sg-unit-left-htpy (A : Unit -> U) : Htpy' (Sg Unit A) (Sg Unit A) (\ z. (Equiv/Sg-unit-inv-map A) (Equiv/Sg-unit-map A z)) (id (Sg Unit A)) =
    \ u. Equiv/Sg-unit-left-htpy/sg A u.1 u.2

  Equiv/Sg-unit-is-equiv (A : Unit -> U) : is-equiv (Sg Unit A) (A star) (Equiv/Sg-unit-map A) =
    has-inverse/is-equiv (Sg Unit A) (A star) (Equiv/Sg-unit-map A)
      (Equiv/Sg-unit-inv-map A, (Equiv/Sg-unit-right-htpy A, Equiv/Sg-unit-left-htpy A))

  Equiv/Sg-unit (A : Unit -> U) : Equiv (Sg Unit A) (A star) =
    (Equiv/Sg-unit-map A, Equiv/Sg-unit-is-equiv A)
    #+end_src
*** Fib pr1 is B x
    #+begin_src ctt
  Equiv/fib-pr1-space-map (A : U) (B : A -> U) (x : A) (u : Fib (Sg A B) A (\ u. u.1) x) : B x =
    let x' : A = u.1.1
        y  : B x' = u.1.2
        p  : Path A x x' = u.2
    in tr A x' x (inv A x x' p) B y

  Equiv/fib-pr1-space-inv-map (A : U) (B : A -> U) (x : A) (y : B x) : Fib (Sg A B) A (\ u. u.1) x =
    ((x, y), refl A x)

  Equiv/fib-pr1-space-right-htpy (A : U) (B : A -> U) (x : A) : Htpy' (B x) (B x)
                                                                     (\ z. (Equiv/fib-pr1-space-map A B x) (Equiv/fib-pr1-space-inv-map A B x z))
                                                                     (id (B x)) =
    \ y. comp (B x) (tr A x x (inv A x x (refl A x)) B y)
             (tr A x x (refl A x) B y) (ap (Path A x x) (B x) (\ p. tr A x x p B y) (inv A x x (refl A x)) (refl A x) (inv/refl A x))
             y (tr/refl-path A x B y)

  Equiv/fib-pr1-space-left-htpy/refl (A : U) (B : A -> U) (x : A) (y : B x)
                                        : Path (Fib (Sg A B) A (\ u. u.1) x)
                                               ((Equiv/fib-pr1-space-inv-map A B x) (Equiv/fib-pr1-space-map A B x ((x, y), refl A x)))
                                               ((x, y), refl A x) =
    comp (Fib (Sg A B) A (\ u. u.1) x) ((x, tr A x x (inv A x x (refl A x)) B y), refl A x)
                                     ((x, tr A x x (refl A x) B y), refl A x)
                                     (ap (Path A x x) (Fib (Sg A B) A (\ u. u.1) x) (\ p. ((x, tr A x x p B y), refl A x))
                                         (inv A x x (refl A x)) (refl A x) (inv/refl A x))
                                     ((x, y), refl A x)
                                     (ap (B x) (Fib (Sg A B) A (\ u. u.1) x) (\ y'. ((x, y'), refl A x)) (tr A x x (refl A x) B y) y
                                         (tr/refl-path A x B y))

  Equiv/fib-pr1-space-left-htpy/sg (A : U) (B : A -> U) (x : A) (x' : A) (y : B x') (p : Path A x x')
                                      : Path (Fib (Sg A B) A (\ u. u.1) x)
                                             ((Equiv/fib-pr1-space-inv-map A B x) (Equiv/fib-pr1-space-map A B x ((x', y), p)))
                                             ((x', y), p) =
    J A x (\ x'' q. (y' : B x'') -> Path (Fib (Sg A B) A (\ u. u.1) x) ((Equiv/fib-pr1-space-inv-map A B x) (Equiv/fib-pr1-space-map A B x ((x'', y'), q))) ((x'', y'), q))
          (\ y'. Equiv/fib-pr1-space-left-htpy/refl A B x y') x' p y

  Equiv/fib-pr1-space-left-htpy (A : U) (B : A -> U) (x : A) : Htpy' (Fib (Sg A B) A (\ u. u.1) x) (Fib (Sg A B) A (\ u. u.1) x)
                                                                    (\ z. (Equiv/fib-pr1-space-inv-map A B x) (Equiv/fib-pr1-space-map A B x z))
                                                                    (id (Fib (Sg A B) A (\ u. u.1) x)) =
    \ u. Equiv/fib-pr1-space-left-htpy/sg A B x u.1.1 u.1.2 u.2
    #+end_src
We have shown that there is a bijection between (Fib pr1 x) and (B x), that is, these two spaces are equivalent.
#+begin_src ctt
  Equiv/fib-space-is-equiv (A : U) (B : A -> U) (x : A) : is-equiv (Fib (Sg A B) A (\ u. u.1) x) (B x) (Equiv/fib-pr1-space-map A B x) =
    has-inverse/is-equiv (Fib (Sg A B) A (\ u. u.1) x) (B x) (Equiv/fib-pr1-space-map A B x)
      (Equiv/fib-pr1-space-inv-map A B x, (Equiv/fib-pr1-space-right-htpy A B x, Equiv/fib-pr1-space-left-htpy A B x))

  Equiv/fib-space-Equiv (A : U) (B : A -> U) (x : A) : Equiv (Fib (Sg A B) A (\ u. u.1) x) (B x) =
    (Equiv/fib-pr1-space-map A B x, Equiv/fib-space-is-equiv A B x)
#+end_src

*** \Sigma fib is A
    #+begin_src ctt
  equiv-total-fib/map (A B : U) (f : A -> B) (t : Sg B (Fib A B f)) : A = t.2.1

  equiv-total-fib/inv-map (A B : U) (f : A -> B) (x : A) : Sg B (Fib A B f) = (f x, (x, refl B (f x)))

  equiv-total-fib/right-htpy (A B : U) (f : A -> B) : Htpy' A A (\ z. (equiv-total-fib/map A B f) (equiv-total-fib/inv-map A B f z)) (id A) =
    \ x. refl A x

  equiv-total-fib/left-htpy/refl (A B : U) (f : A -> B) (x : A) 
                                       : Path (Sg B (Fib A B f)) ((equiv-total-fib/inv-map A B f) (equiv-total-fib/map A B f (f x, (x, inv B (f x) (f x) (refl B (f x))))))
                                              (f x, (x, inv B (f x) (f x) (refl B (f x)))) =
    ap (Path B (f x) (f x)) (Sg B (Fib A B f)) (\ p. (f x, (x, p))) (refl B (f x)) (inv B (f x) (f x) (refl B (f x))) (refl/sym B (f x))

  equiv-total-fib/left-htpy' (A B : U) (f : A -> B) (y : B) (x : A) (p : Path B (f x) y)
                                  : Path (Sg B (Fib A B f)) ((equiv-total-fib/inv-map A B f) (equiv-total-fib/map A B f (y, (x, inv B (f x) y p)))) (y, (x, inv B (f x) y p)) =
    J B (f x) (\ z q. Path (Sg B (Fib A B f)) ((equiv-total-fib/inv-map A B f) (equiv-total-fib/map A B f (z, (x, inv B (f x) z q)))) (z, (x, inv B (f x) z q)))
              (equiv-total-fib/left-htpy/refl A B f x) y p

  equiv-total-fib/left-htpy (A B : U) (f : A -> B)
                                 : Htpy' (Sg B (Fib A B f)) (Sg B (Fib A B f))
                                         (\ z. (equiv-total-fib/inv-map A B f) (equiv-total-fib/map A B f z)) (id (Sg B (Fib A B f))) =
    \ u.
      let x : A = u.2.1
          y : B = u.1
          p : Path B y (f x) = u.2.2
      in comp-n (Sg B (Fib A B f)) three-Nat ((equiv-total-fib/inv-map A B f) (equiv-total-fib/map A B f (y, (x, p))))
          ((equiv-total-fib/inv-map A B f) (equiv-total-fib/map A B f (y, (x, inv B (f x) y (inv B y (f x) p)))))
          (ap (Path B y (f x)) (Sg B (Fib A B f)) (\ q. (equiv-total-fib/inv-map A B f) (equiv-total-fib/map A B f (y, (x, q)))) p (inv B (f x) y (inv B y (f x) p))
              (inv/involutive' B y (f x) p))
          (y, (x, inv B (f x) y (inv B y (f x) p))) (equiv-total-fib/left-htpy' A B f y x (inv B y (f x) p))
          (y, (x, p)) (ap (Path B y (f x)) (Sg B (Fib A B f)) (\ q. (y, (x, q))) (inv B (f x) y (inv B y (f x) p)) p (inv/involutive B y (f x) p))

  equiv-total-fib/Equiv (A B : U) (f : A -> B) : Equiv (Sg B (Fib A B f)) A =
    has-inverse/Equiv (Sg B (Fib A B f)) A (equiv-total-fib/map A B f)
      (equiv-total-fib/inv-map A B f, (equiv-total-fib/right-htpy A B f, equiv-total-fib/left-htpy A B f))
    #+end_src

#+RESULTS:
: Typecheck has succeeded.

*** \Sigma A Empty is empty
    #+begin_src ctt
  Equiv/Sg-empty-map (A : U) (u : Sg A (\ _. Empty)) : Empty = u.2

  Equiv/Sg-empty-inv-map (A : U) (n : Empty) : Sg A (\ _. Empty) = (ex-falso A n, n)

  Equiv/Sg-empty-right-htpy (A : U) : Htpy' Empty Empty (\ z. (Equiv/Sg-empty-map A) (Equiv/Sg-empty-inv-map A z)) (id Empty) =
    \ n. ex-falso (Path Empty ((Equiv/Sg-empty-map A) (Equiv/Sg-empty-inv-map A n)) n) n

  Equiv/Sg-empty-left-htpy (A : U) : Htpy' (Sg A (\ _. Empty)) (Sg A (\ _. Empty)) (\ z. (Equiv/Sg-empty-inv-map A) (Equiv/Sg-empty-map A z)) (id (Sg A (\ _. Empty))) =
    \ n. ex-falso (Path (Sg A (\ _. Empty)) ((Equiv/Sg-empty-inv-map A) (Equiv/Sg-empty-map A n)) n) (n.2)

  Equiv/Sg-empty (A : U) : Equiv (Sg A (\ _. Empty)) Empty =
    has-inverse/Equiv (Sg A (\ _. Empty)) Empty (Equiv/Sg-empty-map A)
      (Equiv/Sg-empty-inv-map A, (Equiv/Sg-empty-right-htpy A, Equiv/Sg-empty-left-htpy A))
     #+end_src

*** \Sigma A Unit is A
    #+begin_src ctt
  Equiv/Sg-base-unit-map (A : U) (u : Sg A (\ _. Unit)) : A = u.1

  Equiv/Sg-base-unit-inv-map (A : U) (x : A) : Sg A (\ _. Unit) = (x, star)

  Equiv/Sg-base-unit-right-htpy (A : U) : Htpy' A A (\ z. (Equiv/Sg-base-unit-map A) (Equiv/Sg-base-unit-inv-map A z)) (id A) =
    \ x. refl A x

  Equiv/Sg-base-unit-left-htpy (A : U) : Htpy' (Sg A (\ _. Unit)) (Sg A (\ _. Unit))
                                               (\ z. (Equiv/Sg-base-unit-inv-map A) (Equiv/Sg-base-unit-map A z)) (id (Sg A (\ _. Unit))) =
    \ u. Eq-prod/eq A Unit ((Equiv/Sg-base-unit-inv-map A) (Equiv/Sg-base-unit-map A u)) u (refl A u.1, Unit/all-elements-equal star u.2)

  Equiv/Sg-base-unit (A : U) : Equiv (Sg A (\ _. Unit)) A =
    has-inverse/Equiv (Sg A (\ _. Unit)) A (Equiv/Sg-base-unit-map A)
      (Equiv/Sg-base-unit-inv-map A, (Equiv/Sg-base-unit-right-htpy A, Equiv/Sg-base-unit-left-htpy A))
    #+end_src

*** \Sigma (\Sigma A B) (C \circ pr1) is \Sigma (\Sigma A C) (B \circ pr1)
Forward map.
    #+begin_src ctt
  Equiv/assoc-Sg/map (A : U) (B C : A -> U) : Sg (Sg A B) (\ t. C t.1) -> Sg (Sg A C) (\ t. B t.1) =
    \ u. ((u.1.1, u.2), u.1.2)
    #+end_src
Inverse map.
#+begin_src ctt
  Equiv/assoc-Sg/inv-map (A : U) (B C : A -> U) : Sg (Sg A C) (\ t. B t.1) -> Sg (Sg A B) (\ t. C t.1) =
    \ u. ((u.1.1, u.2), u.1.2)
#+end_src
Right homotopy.
#+begin_src ctt
  Equiv/assoc-Sg/right-htpy/sg (A : U) (B C : A -> U) (a : A) (b : B a) (c : C a)
                                  : Path (Sg (Sg A C) (\ t. B t.1)) (Equiv/assoc-Sg/map A B C (Equiv/assoc-Sg/inv-map A B C ((a, c), b))) ((a, c), b) =
    refl (Sg (Sg A C) (\ t. B t.1)) ((a, c), b)

  Equiv/assoc-Sg/right-htpy (A : U) (B C : A -> U) : Htpy' (Sg (Sg A C) (\ t. B t.1)) (Sg (Sg A C) (\ t. B t.1))
                                                          (\ t. Equiv/assoc-Sg/map A B C (Equiv/assoc-Sg/inv-map A B C t)) (id (Sg (Sg A C) (\ t. B t.1))) =
    \ t. Equiv/assoc-Sg/right-htpy/sg A B C t.1.1 t.2 t.1.2
#+end_src
Left homotopy.
#+begin_src ctt
  Equiv/assoc-Sg/left-htpy/sg (A : U) (B C : A -> U) (a : A) (b : B a) (c : C a)
                                  : Path (Sg (Sg A B) (\ t. C t.1)) (Equiv/assoc-Sg/inv-map A B C (Equiv/assoc-Sg/map A B C ((a, b), c))) ((a, b), c) =
    refl (Sg (Sg A B) (\ t. C t.1)) ((a, b), c)

  Equiv/assoc-Sg/left-htpy (A : U) (B C : A -> U) : Htpy' (Sg (Sg A B) (\ t. C t.1)) (Sg (Sg A B) (\ t. C t.1))
                                                         (\ t. Equiv/assoc-Sg/inv-map A B C (Equiv/assoc-Sg/map A B C t)) (id (Sg (Sg A B) (\ t. C t.1))) =
    \ t. Equiv/assoc-Sg/left-htpy/sg A B C t.1.1 t.1.2 t.2
#+end_src
Thus, it is an equivalence.
#+begin_src ctt
  Equiv/assoc-Sg (A : U) (B C : A -> U) : Equiv (Sg (Sg A B) (\ t. C t.1)) (Sg (Sg A C) (\ t. B t.1)) =
    has-inverse/Equiv (Sg (Sg A B) (\ t. C t.1)) (Sg (Sg A C) (\ t. B t.1))
      (Equiv/assoc-Sg/map A B C) (Equiv/assoc-Sg/inv-map A B C, (Equiv/assoc-Sg/right-htpy A B C, Equiv/assoc-Sg/left-htpy A B C))
#+end_src

*** \Sigma A B and \Sigma A C whenever B is equivalent to C
    #+begin_src ctt
  Equiv/Sg-fam/map' (A : U) (B C : A -> U) (f : (x : A) -> (B x) -> (C x)) : Sg A B -> Sg A C =
    \ t. (t.1, (f t.1) t.2)

  Equiv/Sg-fam/map (A : U) (B C : A -> U) (e : (x : A) -> Equiv (B x) (C x)) : Sg A B -> Sg A C =
    \ t. Equiv/Sg-fam/map' A B C (\ x. Equiv/map (B x) (C x) (e x)) t

  Equiv/Sg-fam/inv-map (A : U) (B C : A -> U) (e : (x : A) -> Equiv (B x) (C x)) : Sg A C -> Sg A B =
    \ t. (t.1, Equiv/inv-map (B t.1) (C t.1) (e t.1) t.2)

  Equiv/Sg-fam/right-htpy/sg (A : U) (B C : A -> U) (e : (x : A) -> Equiv (B x) (C x)) (a : A) (c : C a)
                                : Path (Sg A C) (Equiv/Sg-fam/map A B C e (Equiv/Sg-fam/inv-map A B C e (a, c))) (a, c) =
    SgPathO->PathSg A C
      ( Equiv/Sg-fam/map A B C e (Equiv/Sg-fam/inv-map A B C e (a, c))) (a, c)
      ( refl A a,
        PathO/refl A a C
          ( Equiv/map (B a) (C a) (e a) (Equiv/inv-map (B a) (C a) (e a) c)) c
          ( Equiv/inv-right-htpy (B a) (C a) (e a) c))

  Equiv/Sg-fam/right-htpy (A : U) (B C : A -> U) (e : (x : A) -> Equiv (B x) (C x)) (t : Sg A C)
                             : Path (Sg A C) (Equiv/Sg-fam/map A B C e (Equiv/Sg-fam/inv-map A B C e t)) t =
    Equiv/Sg-fam/right-htpy/sg A B C e t.1 t.2

  Equiv/Sg-fam/left-htpy/sg (A : U) (B C : A -> U) (e : (x : A) -> Equiv (B x) (C x)) (a : A) (b : B a)
                               : Path (Sg A B) (Equiv/Sg-fam/inv-map A B C e (Equiv/Sg-fam/map A B C e (a, b))) (a, b) =
    SgPathO->PathSg A B
      ( Equiv/Sg-fam/inv-map A B C e (Equiv/Sg-fam/map A B C e (a, b))) (a, b)
      ( refl A a,
        PathO/refl A a B
          ( Equiv/inv-map (B a) (C a) (e a) (Equiv/map (B a) (C a) (e a) b)) b
          ( Equiv/inv-left-htpy (B a) (C a) (e a) b))

  Equiv/Sg-fam/left-htpy (A : U) (B C : A -> U) (e : (x : A) -> Equiv (B x) (C x)) (t : Sg A B)
                            : Path (Sg A B) (Equiv/Sg-fam/inv-map A B C e (Equiv/Sg-fam/map A B C e t)) t =
    Equiv/Sg-fam/left-htpy/sg A B C e t.1 t.2

  is-equiv/Sg-fam (A : U) (B C : A -> U) (e : (x : A) -> Equiv (B x) (C x)) : is-equiv (Sg A B) (Sg A C) (Equiv/Sg-fam/map A B C e) =
    has-inverse/is-equiv
      ( Sg A B)
      ( Sg A C)
      ( Equiv/Sg-fam/map A B C e)
      ( Equiv/Sg-fam/inv-map A B C e,
        ( Equiv/Sg-fam/right-htpy A B C e,
          Equiv/Sg-fam/left-htpy A B C e))

  Equiv/Sg-fam (A : U) (B C : A -> U) (e : (x : A) -> Equiv (B x) (C x)) : Equiv (Sg A B) (Sg A C) =
    ( Equiv/Sg-fam/map A B C e,
      is-equiv/Sg-fam A B C e)
    #+end_src

*** A \times B and A' \times B
If A is equivalent to C and B is equivalent to D, then A \times B is equivalent to C \times D.
#+begin_src ctt
  Equiv/prod/map (A A' B : U) (e : Equiv A A') : (A * B) -> (A' * B) =
    \ t. (Equiv/map A A' e t.1, t.2)

  Equiv/prod/inv-map (A A' B : U) (e : Equiv A A') : (A' * B) -> (A * B) =
    \ t. (Equiv/inv-map A A' e t.1, t.2)

  Equiv/prod/right-htpy/sg (A A' B : U) (e : Equiv A A') (x : A') (y : B)
                                : Path (A' * B) (Equiv/prod/map A A' B e (Equiv/prod/inv-map A A' B e (x, y))) (x, y) =
    Eq-prod/eq A' B
      ( Equiv/prod/map A A' B e (Equiv/prod/inv-map A A' B e (x, y)))
      ( x, y)
      ( Equiv/inv-right-htpy A A' e x,
        refl B y)

  Equiv/prod/right-htpy (A A' B : U) (e : Equiv A A') (t : A' * B)
                                : Path (A' * B) (Equiv/prod/map A A' B e (Equiv/prod/inv-map A A' B e t)) t =
    Equiv/prod/right-htpy/sg A A' B e t.1 t.2

  Equiv/prod/left-htpy/sg (A A' B : U) (e : Equiv A A') (x : A) (y : B)
                                  : Path (A * B) (Equiv/prod/inv-map A A' B e (Equiv/prod/map A A' B e (x, y))) (x, y) =
    Eq-prod/eq A B
      ( Equiv/prod/inv-map A A' B e (Equiv/prod/map A A' B e (x, y)))
      ( x, y)
      ( Equiv/inv-left-htpy A A' e x,
        refl B y)

  Equiv/prod/left-htpy (A A' B : U) (e : Equiv A A') (t : A * B)
                               : Path (A * B) (Equiv/prod/inv-map A A' B e (Equiv/prod/map A A' B e t)) t =
    Equiv/prod/left-htpy/sg A A' B e t.1 t.2

  Equiv/prod/is-equiv (A A' B : U) (e : Equiv A A') : is-equiv (A * B) (A' * B) (Equiv/prod/map A A' B e) =
    has-inverse/is-equiv
      ( A * B)
      ( A' * B)
      ( Equiv/prod/map A A' B e)
      ( Equiv/prod/inv-map A A' B e,
        ( Equiv/prod/right-htpy A A' B e,
          Equiv/prod/left-htpy A A' B e))

  Equiv/prod (A A' B : U) (e : Equiv A A') : Equiv (A * B) (A' * B) =
    ( Equiv/prod/map A A' B e,
      Equiv/prod/is-equiv A A' B e)
#+end_src

#+RESULTS:
: Typecheck has succeeded.

*** A \times B and A \times B'
If A is equivalent to C and B is equivalent to D, then A \times B is equivalent to C \times D.
#+begin_src ctt
  Equiv/prod'/map (A B B' : U) (e : Equiv B B') : (A * B) -> (A * B') =
    \ t. (t.1, Equiv/map B B' e t.2)

  Equiv/prod'/inv-map (A B B' : U) (e : Equiv B B') : (A * B') -> (A * B) =
    \ t. (t.1, Equiv/inv-map B B' e t.2)

  Equiv/prod'/right-htpy/sg (A B B' : U) (e : Equiv B B') (x : A) (y : B')
                                 : Path (A * B') (Equiv/prod'/map A B B' e (Equiv/prod'/inv-map A B B' e (x, y))) (x, y) =
    Eq-prod/eq A B'
      ( Equiv/prod'/map A B B' e (Equiv/prod'/inv-map A B B' e (x, y)))
      ( x, y)
      ( refl A x,
        Equiv/inv-right-htpy B B' e y)

  Equiv/prod'/right-htpy (A B B' : U) (e : Equiv B B') (t : A * B')
                                 : Path (A * B') (Equiv/prod'/map A B B' e (Equiv/prod'/inv-map A B B' e t)) t =
    Equiv/prod'/right-htpy/sg A B B' e t.1 t.2

  Equiv/prod'/left-htpy/sg (A B B' : U) (e : Equiv B B') (x : A) (y : B)
                                  : Path (A * B) (Equiv/prod'/inv-map A B B' e (Equiv/prod'/map A B B' e (x, y))) (x, y) =
    Eq-prod/eq A B
      ( Equiv/prod'/inv-map A B B' e (Equiv/prod'/map A B B' e (x, y)))
      ( x, y)
      ( refl A x,
        Equiv/inv-left-htpy B B' e y)

  Equiv/prod'/left-htpy (A B B' : U) (e : Equiv B B') (t : A * B)
                                : Path (A * B) (Equiv/prod'/inv-map A B B' e (Equiv/prod'/map A B B' e t)) t =
    Equiv/prod'/left-htpy/sg A B B' e t.1 t.2

  Equiv/prod'/is-equiv (A B B' : U) (e : Equiv B B') : is-equiv (A * B) (A * B') (Equiv/prod'/map A B B' e) =
    has-inverse/is-equiv
      ( A * B)
      ( A * B')
      ( Equiv/prod'/map A B B' e)
      ( Equiv/prod'/inv-map A B B' e,
        ( Equiv/prod'/right-htpy A B B' e,
          Equiv/prod'/left-htpy A B B' e))

  Equiv/prod' (A B B' : U) (e : Equiv B B') : Equiv (A * B) (A * B') =
    ( Equiv/prod'/map A B B' e,
      Equiv/prod'/is-equiv A B B' e)
#+end_src

#+RESULTS:
: Typecheck has succeeded.

*** A \times B and A' \times B'a
    #+begin_src ctt
  Equiv/double-prod (A B A' B' : U) (eA : Equiv A A') (eB : Equiv B B') : Equiv (A * B) (A' * B') =
    Equiv/trans
      ( A * B)
      ( A' * B)
      ( A' * B')
      ( Equiv/prod A A' B eA)
      ( Equiv/prod' A' B B' eB)
    #+end_src

*** \Pi_{x:A}B x and \Pi_{x: A'}B(e(x)) whenever A is equivalent to A'
    #+begin_src ctt
  Equiv/dependent/map (A B : U) (P : B -> U) (e : Equiv A B) : ((y : B) -> P y) -> (x : A) -> P (Equiv/map A B e x) =
    \ h x. h (Equiv/map A B e x)

  Equiv/dependent/inv-map (A B : U) (P : B -> U) (e : Equiv A B) : ((x : A) -> P (Equiv/map A B e x)) -> (y : B) -> P y =
    \ h y. tr B
      ( Equiv/map A B e (Equiv/inv-map A B e y)) y
      ( htpy/half-adjoint/htpy A B
        ( Equiv/map A B e)
        ( Equiv/inv-map A B e)
        ( Equiv/inv-right-htpy A B e)
        ( Equiv/inv-left-htpy A B e) y) P
      ( h (Equiv/inv-map A B e y))

  Equiv/dependent/right-htpy (A B : U) (P : B -> U) (e : Equiv A B) (h : (x : A) -> P (Equiv/map A B e x)) 
                                  : Path ((x : A) -> P (Equiv/map A B e x))
                                         (Equiv/dependent/map A B P e (Equiv/dependent/inv-map A B P e h)) h =
    let f : A -> B = Equiv/map A B e
        g : B -> A = Equiv/inv-map A B e
        G : Htpy' B B (\ x. f (g x)) (id B) = Equiv/inv-right-htpy A B e
        H : Htpy' A A (\ x. g (f x)) (id A) = Equiv/inv-left-htpy A B e
        G' : Htpy' B B (\ y. f (g y)) (id B) = htpy/half-adjoint/htpy A B f g G H
    in
    eq-htpy A
      ( \ x. P (f x))
      ( Equiv/dependent/map A B P e (Equiv/dependent/inv-map A B P e h)) h
      ( \ x. comp-n 
          ( P (f x)) three-Nat
          ( tr B (f (g (f x))) (f x) (G' (f x)) P (h (g (f x))))
          ( tr B (f (g (f x))) (f x) (ap A B f (g (f x)) x (H x)) P (h (g (f x))))
          ( ap (Path B (f (g (f x))) (f x)) (P (f x)) (\ p. tr B (f (g (f x))) (f x) p P (h (g (f x)))) (G' (f x)) (ap A B f (g (f x)) x (H x))
            ( htpy/half-adjoint' A B f g G H x))
          ( tr A (g (f x)) x (H x) (\ z. P (f z)) (h (g (f x))))
          ( tr/ap A B f P (g (f x)) x (H x) (h (g (f x))))
          ( h x)
          ( apd A
            ( \ z. P (f z)) h
            ( g (f x)) x
            ( H x)))

  Equiv/dependent/left-htpy (A B : U) (P : B -> U) (e : Equiv A B) (h : (y : B) -> P y)
                                   : Path ((y : B) -> P y)
                                          (Equiv/dependent/inv-map A B P e (Equiv/dependent/map A B P e h)) h =
    let f : A -> B = Equiv/map A B e
        g : B -> A = Equiv/inv-map A B e
        G : Htpy' B B (\ x. f (g x)) (id B) = Equiv/inv-right-htpy A B e
        H : Htpy' A A (\ x. g (f x)) (id A) = Equiv/inv-left-htpy A B e
        G' : Htpy' B B (\ y. f (g y)) (id B) = htpy/half-adjoint/htpy A B f g G H
    in
    eq-htpy B P
      ( Equiv/dependent/inv-map A B P e (Equiv/dependent/map A B P e h)) h
      ( \ y. apd B P h
            ( f (g y)) y
            ( G' y))

  Equiv/dependent (A B : U) (P : B -> U) (e : Equiv A B)
                       : Equiv ((y : B) -> P y) ((x : A) -> P (Equiv/map A B e x)) =
    has-inverse/Equiv
      ( (y : B) -> P y)
      ( (x : A) -> P (Equiv/map A B e x))
      ( Equiv/dependent/map A B P e)
      ( Equiv/dependent/inv-map A B P e,
        ( Equiv/dependent/right-htpy A B P e,
          Equiv/dependent/left-htpy A B P e))
    #+end_src

#+RESULTS:
: Typecheck has succeeded.

*** \Pi_{x: Unit}B x and B star
    #+begin_src ctt
  Equiv/pi-Unit/map (B : Unit -> U) : ((u : Unit) -> B u) -> B star =
    \ f. f star

  Equiv/pi-Unit/inv-map (B : Unit -> U) (b : B star) : (u : Unit) -> B u = split
    star -> b

  Equiv/pi-Unit/right-htpy (B : Unit -> U) (b : B star) : Path (B star) (Equiv/pi-Unit/map B (Equiv/pi-Unit/inv-map B b)) b =
    refl (B star) b

  Equiv/pi-Unit/left-htpy/star (B : Unit -> U) (f : (u : Unit) -> B u) : (u : Unit) -> Path (B u) (Equiv/pi-Unit/inv-map B (Equiv/pi-Unit/map B f) u) (f u) = split
    star -> refl (B star) (f star)

  Equiv/pi-Unit/left-htpy (B : Unit -> U) (f : (u : Unit) -> B u) : Path ((u : Unit) -> B u) (Equiv/pi-Unit/inv-map B (Equiv/pi-Unit/map B f)) f =
    eq-htpy Unit B
      ( Equiv/pi-Unit/inv-map B (Equiv/pi-Unit/map B f)) f
      ( Equiv/pi-Unit/left-htpy/star B f)

  Equiv/pi-Unit/is-equiv (B : Unit -> U) : is-equiv ((u : Unit) -> B u) (B star) (Equiv/pi-Unit/map B) =
    has-inverse/is-equiv
      ( (u : Unit) -> B u)
      ( B star)
      ( Equiv/pi-Unit/map B)
      ( Equiv/pi-Unit/inv-map B,
        ( Equiv/pi-Unit/right-htpy B,
          Equiv/pi-Unit/left-htpy B))

  Equiv/pi-Unit (B : Unit -> U) : Equiv ((u : Unit) -> B u) (B star) =
    ( Equiv/pi-Unit/map B,
      Equiv/pi-Unit/is-equiv B)
    #+end_src

#+RESULTS:
: Typecheck has succeeded.

*** (x, y) = (x', y') is \Sigma_{p: x = x'}tr_B(p, y) = y'
This result is more or less direct from the one in the prelude.
#+begin_src ctt
  PathSg/Equiv (A : U) (B : A -> U) (u v : Sg A B) : Equiv (Path (Sg A B) u v) (SgPathO A B u v) =
    path-to-equiv
      ( Path (Sg A B) u v)
      ( SgPathO A B u v)
      ( PathSg-eq-SgPathO A B u v)

  PathSg/Equiv' (A : U) (B : A -> U) (u v : Sg A B) : Equiv (SgPathO A B u v) (Path (Sg A B) u v) =
    Equiv/sym
      ( Path (Sg A B) u v)
      ( SgPathO A B u v)
      ( PathSg/Equiv A B u v)
#+end_src

#+RESULTS:
: Typecheck has succeeded.


** Closure of truncation levels under equivalence

If =B= is of level =k= and =A= is equivalent to =B=, then =A= is also of level =k=.
   #+begin_src ctt
  is-of-lvl/closed-equiv (A B : U) (e : Equiv A B) : (k : Nat) -> (H : is-of-lvl k B) -> is-of-lvl k A = split
    zero -> \ H. is-contr/is-contr-equiv A B e H
    suc k ->
      let f : A -> B = Equiv/map A B e in
      \ H x y. is-of-lvl/closed-equiv (Path A x y) (Path B (f x) (f y)) (Equiv/Equiv-id A B e x y) k (H (f x) (f y))

  is-of-lvl/closed-equiv' (A B : U) (e : Equiv A B) (k : Nat) (H : is-of-lvl k A) : is-of-lvl k B =
    is-of-lvl/closed-equiv B A (Equiv/sym A B e) k H
   #+end_src

#+RESULTS:
: Typecheck has succeeded.
** Double inverse of equivalence

   #+begin_src ctt
  lock has-inverse/is-equiv

  Equiv/sym/sym (A B : U) (e : Equiv A B)
                     : Path (Equiv A B) (Equiv/inv-equiv B A (Equiv/inv-equiv A B e)) e =
    SgPath-prop
      ( A -> B)
      ( is-equiv A B)
      ( is-equiv/is-prop A B)
      ( Equiv/inv-equiv B A (Equiv/inv-equiv A B e)) e
      ( eq-htpy' A B
          ( Equiv/map A B
            ( Equiv/inv-equiv B A
              ( Equiv/inv-equiv A B e)))
          ( Equiv/map A B e)
          ( \ x.
              let e' : Equiv B A = Equiv/inv-equiv A B e
                  e'' : Equiv A B = Equiv/inv-equiv B A e'
                  f : A -> B = Equiv/map A B e
                  f' : B -> A = Equiv/map B A e'
                  f'' : A -> B = Equiv/map A B e''
              in
              comp B
                ( f'' x)
                ( f'' (f' (f x)))
                ( ap A B f'' x
                  ( f' (f x))
                  ( inv A
                    ( f' (f x)) x
                    ( Equiv/inv-left-htpy A B e x)))
                ( f x)
                ( Equiv/inv-left-htpy B A e' (f x))))


  Equiv/sym/sym' (A B : U) (e : Equiv A B)
                     : Path (Equiv A B) e (Equiv/inv-equiv B A (Equiv/inv-equiv A B e)) =
    inv
      ( Equiv A B)
      ( Equiv/inv-equiv B A
        ( Equiv/inv-equiv A B e)) e
      ( Equiv/sym/sym A B e)

  unlock has-inverse/is-equiv  
   #+end_src
#+RESULTS:
: Typecheck has succeeded.

