module Lib.Prop.Levels where

import Stdlib.Prelude
import Lib.Prop.Proposition
import Lib.Prop.Set

is-prop/closed-equiv (A B : U) (e : Equiv A B) (H : is-prop B) : is-prop A =
  has-contr-eq/is-prop A (is-of-lvl/closed-equiv A B e one-Nat (is-prop/has-contr-eq B H))

is-prop/closed-equiv' (A B : U) (e : Equiv A B) (H : is-prop A) : is-prop B =
  has-contr-eq/is-prop B (is-of-lvl/closed-equiv' A B e one-Nat (is-prop/has-contr-eq A H))

is-set/closed-equiv (A B : U) (e : Equiv A B) (H : is-set B) : is-set A =
  let f : A -> B = Equiv/map A B e in
  \ x y. is-prop/closed-equiv (Path A x y) (Path B (f x) (f y)) (Equiv/Equiv-id A B e x y) (H (f x) (f y))

is-set/closed-equiv' (A B : U) (e : Equiv A B) (H : is-set A) : is-set B =
  is-set/closed-equiv B A (Equiv/sym A B e) H

is-prop/is-set (A : U) (is-prop-A : is-prop A) : is-set A =
  \ x y. is-contr->is-prop (Path A x y) (is-prop/has-contr-eq A is-prop-A x y)

is-prop/is-prop (A : U) : is-prop (is-prop A) =
  is-prop/ass-inh
    ( is-prop A)
    ( \ is-prop-A.
        is-prop/pi-2 A
          ( \ _. A)
          ( \ x y. Path A x y)
          ( is-prop/is-set A is-prop-A))

Prop/Set (A : UU-Prop) : UU-Set =
  (Prop/type A, is-prop/is-set (Prop/type A) (Prop/is-prop A))

is-set/is-prop (A : U) : is-prop (is-set A) =
  is-prop/ass-inh
    ( is-set A)
    ( \ is-set-A.
        is-prop/pi-2 A
          ( \ _. A)
          ( \ x y. is-prop (Path A x y))
          ( \ x y. is-prop/is-prop (Path A x y)))
