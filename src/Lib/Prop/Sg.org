#+NAME: Sg
#+AUTHOR: Johann Rosain

* \Sigma Properties

  #+begin_src ctt
  module Lib.Prop.Sg where
  #+end_src

This file proves some useful basic facts on \Sigma-types.

** Packages imports

   #+begin_src ctt
  import Stdlib.Prelude
   #+end_src

** Paths properties

*** \Sigma-Path implies subpaths

Let =u, v= be \Sigma-types such that =u = v=. Then, by path induction, we have =p : u.1 = v.1= and =(tr p u.2) = v.2=.
#+begin_src ctt
  Sg-path/left (A : U) (B : A -> U) (u v : Sg A B) (p : Path (Sg A B) u v) : Path A u.1 v.1 =
    J (Sg A B) u (\ w _. Path A u.1 w.1) (refl A u.1) v p

  -- Sg-path/right (A : U) (B : A -> U) (u v : Sg A B) (p : Path (Sg A B) u v)
  --   : PathO A u.1 v.1 (Sg-path/left A B u v p) B u.2 v.2 =
  --   J (Sg A B) u (\ w q. Path (B w.1) (tr A u.1 w.1 (Sg-path/left A B u w q) B u.2) w.2) (refl (tr A u.1 u.1 (refl A u.1) B u.2) u.2) v p
#+end_src

#+RESULTS:
#+begin_example

Checking Definition: Nat
U
[Sum]

Checking Definition: Fib
(A : U) -> (B : U) -> (f : A -> B) -> (y : B) -> U
\ A. \ B. \ f. \ y. (x : A) * Path B y (f x)

Checking Definition: is-contr
(A : U) -> U
\ A. (x : A) * (y : A) -> Path A x y

Checking Definition: is-equiv
(A : U) -> (B : U) -> (f : A -> B) -> U
\ A. \ B. \ f. (y : B) -> is-contr (Fib A B f y)

Checking Definition: Equiv
(A : U) -> (B : U) -> U
\ A. \ B. (e : A -> B) * is-equiv A B e

Checking Definition: refl
(A : U) -> (x : A) -> Path A x x
\ A. \ x. \ i. x

Checking Definition: id
(A : U) -> (x : A) -> A
\ A. \ x. x

Checking Definition: Singl
(A : U) -> (x : A) -> U
\ A. \ x. Fib A A (id A) x

Checking Definition: Singl/is-contr
(A : U) -> (x : A) -> (x' : (x' : A) * Path A x x') * (y : (x'' : A) * Path A x x'') -> Path ((x'' : A) * Path A x x'') x' y
\ A. \ x. ((x, refl A x), \ v. \ z. (v .2 @ [x, v .1] z, \ z'. v .2 @ [x, v .1] (z /\ z')))

Checking Definition: id/is-equiv
(A : U) -> (y : A) -> (x : (x : A) * Path A y x) * (y' : (x' : A) * Path A y x') -> Path ((x' : A) * Path A y x') x y'
\ A. Singl/is-contr A

Checking Definition: IdEquiv
(A : U) -> (e : A -> A) * (y : A) -> (x : (x : A) * Path A y (e x)) * (y' : (x' : A) * Path A y (e x')) -> Path ((x' : A) * Path A y (e x')) x y'
\ A. (id A, id/is-equiv A)

Checking Definition: equiv-to-path
(A : U) -> (B : U) -> (e : (e : A -> B) * (y : B) -> (x : (x : A) * Path B y (e x)) * (y' : (x' : A) * Path B y (e x')) -> Path ((x' : A) * Path B y (e x')) x y') -> Path U A B
\ A. \ B. \ e. \ i. Ext B [(i = 0) -> (A, e .1, e .2), (i = 1) -> (B, id B, id/is-equiv B)]

Checking Definition: ap
(A : U) -> (B : U) -> (f : A -> B) -> (x : A) -> (y : A) -> (p : Path A x y) -> Path B (f x) (f y)
\ A. \ B. \ f. \ x. \ y. \ p. \ i. f (p @ [x, y] i)

Checking Definition: tr
(A : U) -> (x : A) -> (y : A) -> (p : Path A x y) -> (P : A -> U) -> (u : P x) -> P y
\ A. \ x. \ y. \ p. \ P. \ u. coe 0 1 (i. P (p @ [x, y] i)) u

Checking Definition: tr/path'
(A : U) -> (x : A) -> (y : A) -> (p : Path A x y) -> (P : A -> U) -> (u : P x) -> PathP (i. P (p @ [x, y] i)) u (coe 0 1 (i. P (p @ [x, y] i)) u)
\ A. \ x. \ y. \ p. \ P. \ u. \ j. coe 0 j (i. P (p @ [x, y] i)) u

Checking Definition: tr/refl'
(A : U) -> (x : A) -> (P : A -> U) -> Path (P x -> P x) (\ x'. x') (\ u. coe 0 1 (i. P x) u)
\ A. \ x. \ P. \ j. coe 0 j (i. P x)

Checking Definition: J
(A : U) -> (x : A) -> (M : (y : A) -> (p : Path A x y) -> U) -> (m : M x (\ i. x)) -> (y : A) -> (p : Path A x y) -> M y p
\ A. \ x. \ M. \ m. \ y. \ p. tr (Singl A x) (x, refl A x) (y, p) ((Singl/is-contr A x) .2 (y, p)) (\ s. M s .1 s .2) m

Checking Definition: J/comp'
(A : U) -> (x : A) -> (M : (y : A) -> (p : Path A x y) -> U) -> (m : M x (\ i. x)) -> Path (M x (\ i. x)) m (coe 0 1 (i. M x (\ z'. x)) m)
\ A. \ x. \ M. \ m. tr/path' (Singl A x) (x, refl A x) (x, refl A x) ((Singl/is-contr A x) .2 (x, refl A x)) (\ s. M s .1 s .2) m

Checking Definition: tr/is-equiv/refl
(A : U) -> (x : A) -> (P : A -> U) -> (y : P x) -> (x' : (x' : P x) * Path (P x) y (coe 0 1 (i. P x) x')) * (y' : (x'' : P x) * Path (P x) y (coe 0 1 (i. P x) x'')) -> Path ((x'' : P x) * Path (P x) y (coe 0 1 (i. P x) x'')) x' y'
\ A. \ x. \ P. tr (P x -> P x) (id (P x)) (tr A x x (refl A x) P) (tr/refl' A x P) (is-equiv (P x) (P x)) (id/is-equiv (P x))

Checking Definition: tr/is-equiv
(A : U) -> (x : A) -> (y : A) -> (p : Path A x y) -> (P : A -> U) -> (y' : P y) -> (x' : (x' : P x) * Path (P y) y' (coe 0 1 (i. P (p @ [x, y] i)) x')) * (y'' : (x'' : P x) * Path (P y) y' (coe 0 1 (i. P (p @ [x, y] i)) x'')) -> Path ((x'' : P x) * Path (P y) y' (coe 0 1 (i. P (p @ [x, y] i)) x'')) x' y''
\ A. \ x. \ y. \ p. \ P. J A x (\ y'. \ p'. is-equiv (P x) (P y') (tr A x y' p' P)) (tr/is-equiv/refl A x P) y p

Checking Definition: inv
(A : U) -> (x : A) -> (y : A) -> Path A x y -> Path A y x
\ A. \ x. J A x (\ y. \ _. Path A y x) (refl A x)

Checking Definition: tr'
(A : U) -> (x : A) -> (y : A) -> (p : Path A y x) -> (P : A -> U) -> P x -> P y
\ A. \ x. \ y. \ p. tr A x y (inv A y x p)

Checking Definition: tr/refl
(A : U) -> (x : A) -> (P : A -> U) -> Path (P x -> P x) (\ u. coe 0 1 (i. P x) u) (\ x'. x')
\ A. \ x. \ P. inv (P x -> P x) (id (P x)) (tr A x x (refl A x) P) (tr/refl' A x P)

Checking Definition: J/comp
(A : U) -> (x : A) -> (M : (y : A) -> (p : Path A x y) -> U) -> (m : M x (\ i. x)) -> Path (M x (\ i. x)) (coe 0 1 (i. M x (\ z'. x)) m) m
\ A. \ x. \ M. \ m. inv (M x (refl A x)) m (J A x M m x (refl A x)) (J/comp' A x M m)

Checking Definition: inv/refl
(A : U) -> (x : A) -> Path (Path A x x) (coe 0 1 (i. Path A x x) (\ i. x)) (\ i. x)
\ A. \ x. J/comp A x (\ y. \ _. Path A y x) (refl A x)

Checking Definition: comp
(A : U) -> (x : A) -> (y : A) -> Path A x y -> (z : A) -> Path A y z -> Path A x z
\ A. \ x. J A x (\ y. \ _. (z : A) -> Path A y z -> Path A x z) (\ _. \ q. q)

Checking Definition: comp/ident-l
(A : U) -> (x : A) -> (z : A) -> (q : Path A x z) -> Path (Path A x z) (coe 0 1 (i. Path A x (coe 1 i (i'. A) z)) (coe 1 0 (i. Path A x (coe 1 i (i'. A) z)) q)) q
\ A. \ x. \ z. \ q. \ i. J/comp A x (\ y. \ _. (z' : A) -> Path A y z' -> Path A x z') (\ _. \ q'. q') @ [coe 0 1 (i'. (z' : A) -> Path A x z' -> Path A x z') (\ _. \ q'. q'), \ _. \ q'. q'] i z q

Checking Definition: comp/ident-l'
(A : U) -> (x : A) -> (z : A) -> (q : Path A x z) -> Path (Path A x z) q (coe 0 1 (i. Path A x (coe 1 i (i'. A) z)) (coe 1 0 (i. Path A x (coe 1 i (i'. A) z)) q))
\ A. \ x. \ z. \ q. \ i. J/comp' A x (\ y. \ _. (z' : A) -> Path A y z' -> Path A x z') (\ _. \ q'. q') @ [\ _. \ q'. q', coe 0 1 (i'. (z' : A) -> Path A x z' -> Path A x z') (\ _. \ q'. q')] i z q

Checking Definition: comp/ident-r
(A : U) -> (x : A) -> (y : A) -> (p : Path A x y) -> Path (Path A x y) (coe 0 1 (i. Path A x (coe 1 i (i'. A) y)) (coe 1 0 (i. Path A (p @ [x, y] i) (coe 1 i (i'. A) y)) (\ i. y))) p
\ A. \ x. J A x (\ y. \ p. Path (Path A x y) (comp A x y p y (refl A y)) p) (comp/ident-l A x x (refl A x))

Checking Definition: comp-n/type
(A : U) -> (x : A) -> Nat -> A -> U
\ A. \ x. [Split]

Checking Definition: comp-n/impl
(A : U) -> (x : A) -> (n : Nat) -> (z : A) -> Path A x z -> comp-n/type A x n z
\ A. \ x. [Split]

Checking Definition: comp-n
(A : U) -> (n : Nat) -> (x : A) -> comp-n/type A x n x
\ A. [Split]

Checking Definition: comp/assoc/refl
(A : U) -> (x : A) -> (z : A) -> (q : Path A x z) -> (w : A) -> (r : Path A z w) -> Path (Path A x w) (coe 0 1 (i. Path A x (coe 1 i (i'. A) w)) (coe 1 0 (i. Path A (hComp 0 1 A (coe 0 1 (i'. A) hComp 1 0 A (coe 1 0 (i'. A) (q @ [x, coe 1 0 (i'. A) z] i)) [(i = 0) -> i'. coe 0 i' (i''. A) x, (i = 1) -> i'. coe 0 i' (i''. A) (coe 1 i' (i''. A) z)]) [(i = 0) -> i'. coe 1 i' (i''. A) x, (i = 1) -> i'. coe 1 i' (i''. A) (coe 1 i' (i''. A) z)]) (coe 1 i (i'. A) w)) r)) (coe 0 1 (i. Path A x (coe 1 i (i'. A) w)) (coe 1 0 (i. Path A x (coe 1 i (i'. A) w)) (coe 0 1 (i. Path A x (coe 1 i (i'. A) w)) (coe 1 0 (i. Path A (q @ [x, z] i) (coe 1 i (i'. A) w)) r))))
\ A. \ x. \ z. \ q. \ w. \ r. comp-n Path A x w (suc (suc zero)) (comp A x z (comp A x x (refl A x) z q) w r) (comp A x z q w r) (\ i. comp A x z (comp/ident-l A x z q @ [coe 0 1 (i'. Path A x (coe 1 i' (i''. A) z)) (coe 1 0 (i'. Path A x (coe 1 i' (i''. A) z)) q), q] i) w r) (comp A x x (refl A x) w (comp A x z q w r)) (comp/ident-l' A x w (comp A x z q w r))

Checking Definition: comp/assoc
(A : U) -> (x : A) -> (y : A) -> (p : Path A x y) -> (z : A) -> (q : Path A y z) -> (w : A) -> (r : Path A z w) -> Path (Path A x w) (coe 0 1 (i. Path A x (coe 1 i (i'. A) w)) (coe 1 0 (i. Path A (hComp 0 1 A (coe 0 1 (i'. A) hComp 1 0 A (coe 1 0 (i'. A) (q @ [y, coe 1 0 (i'. A) z] i)) [(i = 0) -> i'. coe 0 i' (i''. A) (p @ [x, y] i'), (i = 1) -> i'. coe 0 i' (i''. A) (coe 1 i' (i''. A) z)]) [(i = 0) -> i'. coe 1 i' (i''. A) x, (i = 1) -> i'. coe 1 i' (i''. A) (coe 1 i' (i''. A) z)]) (coe 1 i (i'. A) w)) r)) (coe 0 1 (i. Path A x (coe 1 i (i'. A) w)) (coe 1 0 (i. Path A (p @ [x, y] i) (coe 1 i (i'. A) w)) (coe 0 1 (i. Path A y (coe 1 i (i'. A) w)) (coe 1 0 (i. Path A (q @ [y, z] i) (coe 1 i (i'. A) w)) r))))
\ A. \ x. J A x (\ y. \ p. (z : A) -> (q : Path A y z) -> (w : A) -> (r : Path A z w) -> Path (Path A x w) (comp A x z (comp A x y p z q) w r) (comp A x y p w (comp A y z q w r))) (comp/assoc/refl A x)

Checking Definition: comp/inv-l/refl
(A : U) -> (x : A) -> Path (Path A x x) (coe 0 1 (i. Path A x (coe 1 i (i'. A) x)) (coe 1 0 (i. Path A (hComp 0 1 A (coe 0 1 (i'. A) x) [(i = 0) -> i'. coe 1 i' (i''. A) x, (i = 1) -> i'. coe 1 i' (i''. A) x]) (coe 1 i (i'. A) x)) (\ i. x))) (\ i. x)
\ A. \ x. comp-n Path A x x (suc (suc zero)) (comp A x x (inv A x x (refl A x)) x (refl A x)) (comp A x x (refl A x) x (refl A x)) (\ i. comp A x x (inv/refl A x @ [coe 0 1 (i'. Path A x x) (\ i'. x), \ i'. x] i) x (refl A x)) (refl A x) (comp/ident-l A x x (refl A x))

Checking Definition: comp/inv-l
(A : U) -> (x : A) -> (y : A) -> (p : Path A x y) -> Path (Path A y y) (coe 0 1 (i. Path A y (coe 1 i (i'. A) y)) (coe 1 0 (i. Path A (hComp 0 1 A (coe 0 1 (i'. A) x) [(i = 0) -> i'. coe 1 i' (i''. A) (p @ [x, y] i'), (i = 1) -> i'. coe 1 i' (i''. A) x]) (coe 1 i (i'. A) y)) p)) (\ i. y)
\ A. \ x. J A x (\ y. \ p. Path (Path A y y) (comp A y x (inv A x y p) y p) (refl A y)) (comp/inv-l/refl A x)

Checking Definition: PathO
(A : U) -> (x : A) -> (y : A) -> (p : Path A x y) -> (B : A -> U) -> (u : B x) -> (v : B y) -> U
\ A. \ x. \ y. \ p. \ B. \ u. \ v. Path (B y) (tr A x y p B u) v

Checking Definition: PathP-eq-PathO
(A : U) -> (x : A) -> (y : A) -> (p : Path A x y) -> (B : A -> U) -> (u : B x) -> (v : B y) -> Path U (PathP (i. B (p @ [x, y] i)) u v) (Path (B y) (coe 0 1 (i. B (p @ [x, y] i)) u) v)
\ A. \ x. \ y. \ p. \ B. \ u. \ v. \ i. PathP (j. B (p @ [x, y] (i \/ j))) (coe 0 i (j. B (p @ [x, y] (i /\ j))) u) v

Checking Definition: Pi
(A : U) -> (B : A -> U) -> U
\ A. \ B. (x : A) -> B x

Checking Definition: Htpy
(A : U) -> (B : A -> U) -> (f : (x : A) -> B x) -> (g : (x : A) -> B x) -> U
\ A. \ B. \ f. \ g. (x : A) -> Path (B x) (f x) (g x)

Checking Definition: Htpy/comp
(A : U) -> (B : A -> U) -> (f : (x : A) -> B x) -> (g : (x : A) -> B x) -> (h : (x : A) -> B x) -> (H1 : (x : A) -> Path (B x) (f x) (g x)) -> (H2 : (x : A) -> Path (B x) (g x) (h x)) -> (x : A) -> Path (B x) (f x) (h x)
\ A. \ B. \ f. \ g. \ h. \ H1. \ H2. \ x. comp (B x) (f x) (g x) (H1 x) (h x) (H2 x)

Checking Definition: Htpy'
(A : U) -> (B : U) -> (f : A -> B) -> (g : A -> B) -> U
\ A. \ B. Htpy A (\ _. B)

Checking Definition: Htpy'/comp
(A : U) -> (B : U) -> (f : A -> B) -> (g : A -> B) -> (h : A -> B) -> ((x : A) -> Path B (f x) (g x)) -> ((x : A) -> Path B (g x) (h x)) -> (x : A) -> Path B (f x) (h x)
\ A. \ B. Htpy/comp A (\ _. B)

Checking Definition: Htpy'/whisker
(A : U) -> (B : U) -> (C : U) -> (D : U) -> (g1 : B -> C) -> (g2 : B -> C) -> (f : C -> D) -> (H : (x : B) -> Path C (g1 x) (g2 x)) -> (h : A -> B) -> (x : A) -> Path D (f (g1 (h x))) (f (g2 (h x)))
\ A. \ B. \ C. \ D. \ g1. \ g2. \ f. \ H. \ h. \ x. \ i. f (H (h x) @ [g1 (h x), g2 (h x)] i)

Checking Definition: is-section
(A : U) -> (B : U) -> (f : A -> B) -> (g : B -> A) -> U
\ A. \ B. \ f. \ g. Htpy' B B (\ x. f (g x)) (id B)

Checking Definition: Sec
(A : U) -> (B : U) -> (f : A -> B) -> U
\ A. \ B. \ f. (s : B -> A) * is-section A B f s

Checking Definition: Sec/left-factor
(A : U) -> (B : U) -> (C : U) -> (f : B -> C) -> (g : A -> B) -> (sec : (s : C -> A) * (x : C) -> Path C (f (g (s x))) x) -> (s : C -> B) * (x : C) -> Path C (f (s x)) x
\ A. \ B. \ C. \ f. \ g. \ sec. (\ c. g (sec .1 c), sec .2)

Checking Definition: Sec/comp
(B : U) -> (C : U) -> (f2 : B -> C) -> (s2 : (s : C -> B) * (x : C) -> Path C (f2 (s x)) x) -> (A : U) -> (f1 : A -> B) -> (s1 : (s : B -> A) * (x : B) -> Path B (f1 (s x)) x) -> (s : C -> A) * (x : C) -> Path C (f2 (f1 (s x))) x
\ B. \ C. \ f2. \ s2. \ A. \ f1. \ s1. (\ z. s1 .1 (s2 .1 z), Htpy'/comp C C (\ z. f2 (f1 (s1 .1 (s2 .1 z)))) (\ z. f2 (s2 .1 z)) (id C) (Htpy'/whisker C B B C (\ x. f1 (s1 .1 x)) (id B) f2 s1 .2 s2 .1) s2 .2)

Checking Definition: is-retraction
(A : U) -> (B : U) -> (f : A -> B) -> (g : B -> A) -> U
\ A. \ B. \ f. \ g. Htpy' A A (\ x. g (f x)) (id A)

Checking Definition: Ret
(A : U) -> (B : U) -> (f : A -> B) -> U
\ A. \ B. \ f. (r : B -> A) * is-retraction A B f r

Checking Definition: retract-of
(A : U) -> (B : U) -> U
\ A. \ B. (i : A -> B) * Ret A B i

Checking Definition: retract-ind
(A : U) -> (B : U) -> (P : A -> U) -> (ret : (i : A -> B) * (r : B -> A) * (x : A) -> Path A (r (i x)) x) -> (p : (b : B) -> P (ret .2 .1 b)) -> (a : A) -> P a
\ A. \ B. \ P. \ ret. \ p. \ a. tr A (ret .2 .1 (ret .1 a)) a (ret .2 .2 a) P (p (ret .1 a))

Checking Definition: is-bi-inv
(A : U) -> (B : U) -> (f : A -> B) -> U
\ A. \ B. \ f. Sec A B f * Ret A B f

Checking Definition: BiInv
(A : U) -> (B : U) -> U
\ A. \ B. (f : A -> B) * is-bi-inv A B f

Checking Definition: Iso
(A : U) -> (B : U) -> U
\ A. \ B. (f : A -> B) * (g : B -> A) * Htpy' B B (\ y. f (g y)) (id B) * Htpy' A A (\ x. g (f x)) (id A)

Checking Definition: is-prop
(A : U) -> U
\ A. (x : A) -> (y : A) -> Path A x y

Checking Definition: Prop
U
(P : U) * is-prop U

Checking Definition: is-prop/fam
(A : U) -> (B : A -> U) -> U
\ A. \ B. (x : A) -> is-prop (B x)

Checking Definition: PropFam
(A : U) -> U
\ A. (B : A -> U) * is-prop/fam A B

Checking Definition: is-prop/fam-2
(A : U) -> (B : A -> U) -> (C : (x : A) -> B x -> U) -> U
\ A. \ B. \ C. (x : A) -> (y : B x) -> is-prop (C x y)

Checking Definition: is-set
(A : U) -> U
\ A. (x : A) -> (y : A) -> is-prop Path A x y

Checking Definition: Set
U
(P : U) * is-set U

Checking Definition: Sg
(A : U) -> (B : A -> U) -> U
\ A. \ B. (x : A) * B x

Checking Definition: SgPathP
(A : U) -> (B : A -> U) -> (u : (x : A) * B x) -> (v : (x : A) * B x) -> U
\ A. \ B. \ u. \ v. (p : Path A u .1 v .1) * PathP (i. B (p @ [u .1, v .1] i)) u .2 v .2

Checking Definition: SgPathO
(A : U) -> (B : A -> U) -> (u : (x : A) * B x) -> (v : (x : A) * B x) -> U
\ A. \ B. \ u. \ v. (p : Path A u .1 v .1) * PathO A u .1 v .1 p B u .2 v .2

Checking Definition: SgPathP-eq-SgPathO
(A : U) -> (B : A -> U) -> (u : (x : A) * B x) -> (v : (x : A) * B x) -> Path U ((p : Path A u .1 v .1) * PathP (i. B (p @ [u .1, v .1] i)) u .2 v .2) ((p : Path A u .1 v .1) * Path (B v .1) (coe 0 1 (i. B (p @ [u .1, v .1] i)) u .2) v .2)
\ A. \ B. \ u. \ v. \ i. (p : Path A u .1 v .1) * PathP-eq-PathO A u .1 v .1 p B u .2 v .2 @ [PathP (i'. B (p @ [u .1, v .1] i')) u .2 v .2, Path (B v .1) (coe 0 1 (i'. B (p @ [u .1, v .1] i')) u .2) v .2] i

Checking Definition: SgPathP->PathSg
(A : U) -> (B : A -> U) -> (u : (x : A) * B x) -> (v : (x : A) * B x) -> (p : (p : Path A u .1 v .1) * PathP (i. B (p @ [u .1, v .1] i)) u .2 v .2) -> Path ((x : A) * B x) u v
\ A. \ B. \ u. \ v. \ p. \ i. (p .1 @ [u .1, v .1] i, p .2 @ [u .2, v .2] i)

Checking Definition: PathSg->SgPathP
(A : U) -> (B : A -> U) -> (u : (x : A) * B x) -> (v : (x : A) * B x) -> (p : Path ((x : A) * B x) u v) -> (p' : Path A u .1 v .1) * PathP (i. B (p' @ [u .1, v .1] i)) u .2 v .2
\ A. \ B. \ u. \ v. \ p. (\ i. (p @ [u, v] i) .1, \ i. (p @ [u, v] i) .2)

Checking Definition: PathSg-equiv-SgPathP
(A : U) -> (B : A -> U) -> (u : (x : A) * B x) -> (v : (x : A) * B x) -> (e : Path ((x : A) * B x) u v -> (p : Path A u .1 v .1) * PathP (i. B (p @ [u .1, v .1] i)) u .2 v .2) * (y : (p : Path A u .1 v .1) * PathP (i. B (p @ [u .1, v .1] i)) u .2 v .2) -> (x : (x : Path ((x : A) * B x) u v) * Path ((p : Path A u .1 v .1) * PathP (i. B (p @ [u .1, v .1] i)) u .2 v .2) y (e x)) * (y' : (x' : Path ((x' : A) * B x') u v) * Path ((p : Path A u .1 v .1) * PathP (i. B (p @ [u .1, v .1] i)) u .2 v .2) y (e x')) -> Path ((x' : Path ((x' : A) * B x') u v) * Path ((p : Path A u .1 v .1) * PathP (i. B (p @ [u .1, v .1] i)) u .2 v .2) y (e x')) x y'
\ A. \ B. \ u. \ v. (PathSg->SgPathP A B u v, \ pq. ((SgPathP->PathSg A B u v pq, refl (SgPathP A B u v) pq), \ f. \ i. (SgPathP->PathSg A B u v (f .2 @ [pq, (\ i'. (f .1 @ [u, v] i') .1, \ i'. (f .1 @ [u, v] i') .2)] i), \ j. f .2 @ [pq, (\ i'. (f .1 @ [u, v] i') .1, \ i'. (f .1 @ [u, v] i') .2)] (i /\ j))))

Checking Definition: PathSg-eq-SgPathP
(A : U) -> (B : A -> U) -> (u : (x : A) * B x) -> (v : (x : A) * B x) -> Path U (Path ((x : A) * B x) u v) ((p : Path A u .1 v .1) * PathP (i. B (p @ [u .1, v .1] i)) u .2 v .2)
\ A. \ B. \ u. \ v. equiv-to-path Path (Sg A B) u v (SgPathP A B u v) (PathSg-equiv-SgPathP A B u v)

Checking Definition: PathSg-eq-SgPathO
(A : U) -> (B : A -> U) -> (u : (x : A) * B x) -> (v : (x : A) * B x) -> Path U (Path ((x : A) * B x) u v) ((p : Path A u .1 v .1) * Path (B v .1) (coe 0 1 (i. B (p @ [u .1, v .1] i)) u .2) v .2)
\ A. \ B. \ u. \ v. comp U Path (Sg A B) u v (SgPathP A B u v) (PathSg-eq-SgPathP A B u v) (SgPathO A B u v) (SgPathP-eq-SgPathO A B u v)

Checking Definition: SgPathO->PathSg
(A : U) -> (B : A -> U) -> (u : (x : A) * B x) -> (v : (x : A) * B x) -> ((p : Path A u .1 v .1) * Path (B v .1) (coe 0 1 (i. B (p @ [u .1, v .1] i)) u .2) v .2) -> Path ((x : A) * B x) u v
\ A. \ B. \ u. \ v. coe 1 0 (i. PathSg-eq-SgPathO A B u v @ [Path ((x : A) * B x) u v, (p : Path A u .1 v .1) * Path (B v .1) (coe 0 1 (i'. B (p @ [u .1, v .1] i')) u .2) v .2] i)

Checking Definition: SgPath-prop
(A : U) -> (B : A -> U) -> (prop : (x : A) -> (x' : B x) -> (y : B x) -> Path (B x) x' y) -> (u : (x : A) * B x) -> (v : (x : A) * B x) -> (p : Path A u .1 v .1) -> Path ((x : A) * B x) u v
\ A. \ B. \ prop. \ u. \ v. \ p. SgPathO->PathSg A B u v (p, prop v .1 (tr A u .1 v .1 p B u .2) v .2)

Checking Definition: is-of-lvl
Nat -> U -> U
[Split]

Checking Definition: is-prop/sg
(A : U) -> (B : A -> U) -> (p : (x : A) -> (y : A) -> Path A x y) -> (q : (x : A) -> (x' : B x) -> (y : B x) -> Path (B x) x' y) -> (x : (x : A) * B x) -> (y : (x' : A) * B x') -> Path ((x' : A) * B x') x y
\ A. \ B. \ p. \ q. \ u. \ v. SgPathO->PathSg A B u v (p u .1 v .1, q v .1 (tr A u .1 v .1 (p u .1 v .1) B u .2) v .2)

Checking Definition: is-prop/ass-inh
(A : U) -> (lem : A -> (x : A) -> (y : A) -> Path A x y) -> (x : A) -> (y : A) -> Path A x y
\ A. \ lem. \ x. lem x x

Checking Definition: is-prop/pi
(A : U) -> (B : A -> U) -> (q : (x : A) -> (x' : B x) -> (y : B x) -> Path (B x) x' y) -> (x : (x : A) -> B x) -> (y : (x' : A) -> B x') -> Path ((x' : A) -> B x') x y
\ A. \ B. \ q. \ f. \ g. \ i. \ x. q x (f x) (g x) @ [f x, g x] i

Checking Definition: is-prop/pi-2
(A : U) -> (B : A -> U) -> (C : (x : A) -> B x -> U) -> (q : (x : A) -> (y : B x) -> (x' : C x y) -> (y' : C x y) -> Path (C x y) x' y') -> (x : (x : A) -> (y : B x) -> C x y) -> (y : (x' : A) -> (y : B x') -> C x' y) -> Path ((x' : A) -> (y' : B x') -> C x' y') x y
\ A. \ B. \ C. \ q. is-prop/pi A (\ x. (y : B x) -> C x y) (\ x. is-prop/pi (B x) (C x) (q x))

Checking Definition: is-contr->is-prop
(A : U) -> (cntr : (x : A) * (y : A) -> Path A x y) -> (x : A) -> (y : A) -> Path A x y
\ A. \ cntr. \ x. \ y. comp A x cntr .1 (inv A cntr .1 x (cntr .2 x)) y (cntr .2 y)

Checking Definition: is-contr/closed-upwards
(A : U) -> (cntr : (x : A) * (y : A) -> Path A x y) -> (x : A) -> (y : A) -> (x' : Path A x y) * (y' : Path A x y) -> Path (Path A x y) x' y'
\ A. \ cntr. \ x. \ y. let
{
  is-contr/closed-upwards/path : (p : Path A x y) -> Path (Path A x y) (is-contr->is-prop A cntr x y) p = J A x (\ y'. \ p'. Path (Path A x y') (is-contr->is-prop A cntr x y') p') (comp/inv-l A cntr .1 x (cntr .2 x)) y
}
in (is-contr->is-prop A cntr x y, is-contr/closed-upwards/path)

Checking Definition: is-contr/closed-retract
(A : U) -> (B : U) -> (ret : (i : A -> B) * (r : B -> A) * (x : A) -> Path A (r (i x)) x) -> (cntr : (x : B) * (y : B) -> Path B x y) -> (x : A) * (y : A) -> Path A x y
\ A. \ B. \ ret. \ cntr. let
{
  c : A = ret .2 .1 cntr .1
}
in (c, retract-ind A B (\ a. Path A c a) ret (\ b. \ i. ret .2 .1 (cntr .2 b @ [cntr .1, b] i)))

Checking Definition: is-contr->is-set
(A : U) -> (cntr : (x : A) * (y : A) -> Path A x y) -> (x : A) -> (y : A) -> (x' : Path A x y) -> (y' : Path A x y) -> Path (Path A x y) x' y'
\ A. \ cntr. \ x. \ y. is-contr->is-prop Path A x y (is-contr/closed-upwards A cntr x y)

Checking Definition: is-contr/is-prop
(A : U) -> (x : (x : A) * (y : A) -> Path A x y) -> (y : (x' : A) * (y : A) -> Path A x' y) -> Path ((x' : A) * (y' : A) -> Path A x' y') x y
\ A. is-prop/ass-inh (is-contr A) (\ cntr. is-prop/sg A (\ c. (y : A) -> Path A c y) (is-contr->is-prop A cntr) (\ c. is-prop/pi A (\ y. Path A c y) (is-contr->is-set A cntr c)))

Checking Definition: is-of-lvl/closed-upwards
(A : U) -> (n : Nat) -> is-of-lvl n A -> (x : A) -> (y : A) -> is-of-lvl n Path A x y
\ A. [Split]

Checking Definition: is-of-lvl/is-prop
(A : U) -> (n : Nat) -> (x : is-of-lvl n A) -> (y : is-of-lvl n A) -> Path (is-of-lvl n A) x y
\ A. [Split]

Checking Definition: is-equiv/is-prop
(A : U) -> (B : U) -> (f : A -> B) -> (x : (y : B) -> (x : (x : A) * Path B y (f x)) * (y' : (x' : A) * Path B y (f x')) -> Path ((x' : A) * Path B y (f x')) x y') -> (y : (y : B) -> (x' : (x' : A) * Path B y (f x')) * (y' : (x'' : A) * Path B y (f x'')) -> Path ((x'' : A) * Path B y (f x'')) x' y') -> Path ((y' : B) -> (x' : (x' : A) * Path B y' (f x')) * (y'' : (x'' : A) * Path B y' (f x'')) -> Path ((x'' : A) * Path B y' (f x'')) x' y'') x y
\ A. \ B. \ f. is-prop/pi B (\ b. is-contr (Fib A B f b)) (\ b. is-contr/is-prop (Fib A B f b))

Checking Definition: path-to-equiv
(A : U) -> (B : U) -> (p : Path U A B) -> (e : A -> B) * (y : B) -> (x : (x : A) * Path B y (e x)) * (y' : (x' : A) * Path B y (e x')) -> Path ((x' : A) * Path B y (e x')) x y'
\ A. \ B. \ p. (tr U A B p (id U), tr/is-equiv U A B p (id U))

Checking Definition: path-to-equiv/refl
(A : U) -> Path ((e : A -> A) * (y : A) -> (x : (x : A) * Path A y (e x)) * (y' : (x' : A) * Path A y (e x')) -> Path ((x' : A) * Path A y (e x')) x y') (\ u. coe 0 1 (i. A) u, coe 0 1 (i. (y : A) -> (x : (x : A) * Path A y (coe 0 1 (i'. A) x)) * (y' : (x' : A) * Path A y (coe 0 1 (i'. A) x')) -> Path ((x' : A) * Path A y (coe 0 1 (i'. A) x')) x y') (coe 0 1 (i. (y : A) -> (x : (x : A) * Path A y (coe 0 i (i'. A) x)) * (y' : (x' : A) * Path A y (coe 0 i (i'. A) x')) -> Path ((x' : A) * Path A y (coe 0 i (i'. A) x')) x y') (\ x. ((x, \ i. x), \ v. \ z. (v .2 @ [x, v .1] z, \ z'. v .2 @ [x, v .1] (z /\ z')))))) (\ x. x, \ x. ((x, \ i. x), \ v. \ z. (v .2 @ [x, v .1] z, \ z'. v .2 @ [x, v .1] (z /\ z'))))
\ A. SgPath-prop (A -> A) (is-equiv A A) (is-equiv/is-prop A A) (path-to-equiv A A (refl U A)) (IdEquiv A) (tr/refl U A (id U))

Checking Definition: equiv-to-path/comp/fun
(A : U) -> (B : U) -> (e : (e : A -> B) * (y : B) -> (x : (x : A) * Path B y (e x)) * (y' : (x' : A) * Path B y (e x')) -> Path ((x' : A) * Path B y (e x')) x y') -> Path (A -> B) (\ u. hComp 0 1 B (coe 0 1 (i'. B) (e .1 u)) []) e .1
\ A. \ B. \ e. \ i. \ a. hComp i 1 B (coe i 1 (_. B) (e .1 a)) []

Checking Definition: equiv-to-path/comp
(A : U) -> (B : U) -> (e : (e : A -> B) * (y : B) -> (x : (x : A) * Path B y (e x)) * (y' : (x' : A) * Path B y (e x')) -> Path ((x' : A) * Path B y (e x')) x y') -> Path ((e' : A -> B) * (y : B) -> (x : (x : A) * Path B y (e' x)) * (y' : (x' : A) * Path B y (e' x')) -> Path ((x' : A) * Path B y (e' x')) x y') (\ u. hComp 0 1 B (coe 0 1 (i'. B) (e .1 u)) [], coe 0 1 (i. (y : Ext B [(i = 0) -> (A, e .1, e .2), (i = 1) -> (B, \ x. x, \ x. ((x, \ i'. x), \ v. \ z. (v .2 @ [x, v .1] z, \ z'. v .2 @ [x, v .1] (z /\ z'))))]) -> (x : (x : A) * Path (Ext B [(i = 1) -> (B, \ x'. x', \ x'. ((x', \ i'. x'), \ v. \ z. (v .2 @ [x', v .1] z, \ z'. v .2 @ [x', v .1] (z /\ z')))), (i = 0) -> (A, e .1, e .2)]) y (ext hComp 0 1 B (coe 0 1 (i''. B) (e .1 x)) [(i = 0) -> i'. hComp 0 1 B (coe 0 1 (i''. B) (e .1 x)) [(i' = 1) -> i''. coe 1 i'' (i'''. B) (e .1 (coe 0 i'' (i'''. A) x)), (i' = 0) -> i''. coe 1 i'' (i'''. B) (coe 0 i'' (i'''. B) (e .1 x))], (i = 1) -> i'. hComp 0 1 B (hComp 0 1 B (coe 0 1 (i''. B) (coe 0 1 (i''. B) (e .1 x))) [(i' = 1) -> i''. coe 1 i'' (i'''. B) hComp 0 i'' B (coe 0 1 (i'''. B) (e .1 x)) [], (i' = 0) -> i''. coe 1 i'' (i'''. B) (coe 0 1 (i'''. B) (e .1 x))]) [(i' = 0) -> i''. coe 0 1 (i'''. B) (e .1 x), (i' = 1) -> i''. hComp 0 1 B (coe 0 1 (i'''. B) (e .1 x)) []]] (hComp 0 1 B (coe 0 1 (i''. B) (e .1 x)) [], coe 0 1 (i''. A) x))) * (y' : (x' : A) * Path (Ext B [(i = 1) -> (B, \ x''. x'', \ x''. ((x'', \ i'. x''), \ v. \ z. (v .2 @ [x'', v .1] z, \ z'. v .2 @ [x'', v .1] (z /\ z')))), (i = 0) -> (A, e .1, e .2)]) y (ext hComp 0 1 B (coe 0 1 (i''. B) (e .1 x')) [(i = 0) -> i'. hComp 0 1 B (coe 0 1 (i''. B) (e .1 x')) [(i' = 1) -> i''. coe 1 i'' (i'''. B) (e .1 (coe 0 i'' (i'''. A) x')), (i' = 0) -> i''. coe 1 i'' (i'''. B) (coe 0 i'' (i'''. B) (e .1 x'))], (i = 1) -> i'. hComp 0 1 B (hComp 0 1 B (coe 0 1 (i''. B) (coe 0 1 (i''. B) (e .1 x'))) [(i' = 1) -> i''. coe 1 i'' (i'''. B) hComp 0 i'' B (coe 0 1 (i'''. B) (e .1 x')) [], (i' = 0) -> i''. coe 1 i'' (i'''. B) (coe 0 1 (i'''. B) (e .1 x'))]) [(i' = 0) -> i''. coe 0 1 (i'''. B) (e .1 x'), (i' = 1) -> i''. hComp 0 1 B (coe 0 1 (i'''. B) (e .1 x')) []]] (hComp 0 1 B (coe 0 1 (i''. B) (e .1 x')) [], coe 0 1 (i''. A) x'))) -> Path ((x' : A) * Path (Ext B [(i = 0) -> (A, e .1, e .2), (i = 1) -> (B, \ x''. x'', \ x''. ((x'', \ i'. x''), \ v. \ z. (v .2 @ [x'', v .1] z, \ z'. v .2 @ [x'', v .1] (z /\ z'))))]) y (ext hComp 0 1 B (coe 0 1 (i''. B) (e .1 x')) [(i = 0) -> i'. hComp 0 1 B (coe 0 1 (i''. B) (e .1 x')) [(i' = 1) -> i''. coe 1 i'' (i'''. B) (e .1 (coe 0 i'' (i'''. A) x')), (i' = 0) -> i''. coe 1 i'' (i'''. B) (coe 0 i'' (i'''. B) (e .1 x'))], (i = 1) -> i'. hComp 0 1 B (hComp 0 1 B (coe 0 1 (i''. B) (coe 0 1 (i''. B) (e .1 x'))) [(i' = 1) -> i''. coe 1 i'' (i'''. B) hComp 0 i'' B (coe 0 1 (i'''. B) (e .1 x')) [], (i' = 0) -> i''. coe 1 i'' (i'''. B) (coe 0 1 (i'''. B) (e .1 x'))]) [(i' = 0) -> i''. coe 0 1 (i'''. B) (e .1 x'), (i' = 1) -> i''. hComp 0 1 B (coe 0 1 (i'''. B) (e .1 x')) []]] (hComp 0 1 B (coe 0 1 (i''. B) (e .1 x')) [], coe 0 1 (i''. A) x'))) x y') (coe 0 1 (i. (y : A) -> (x : (x : A) * Path A y (coe 0 i (i'. A) x)) * (y' : (x' : A) * Path A y (coe 0 i (i'. A) x')) -> Path ((x' : A) * Path A y (coe 0 i (i'. A) x')) x y') (\ x. ((x, \ i. x), \ v. \ z. (v .2 @ [x, v .1] z, \ z'. v .2 @ [x, v .1] (z /\ z')))))) e
\ A. \ B. \ e. SgPath-prop (A -> B) (is-equiv A B) (is-equiv/is-prop A B) (path-to-equiv A B (equiv-to-path A B e)) e (equiv-to-path/comp/fun A B e)

Checking Definition: equiv-to-path/IdEquiv
(A : U) -> Path (Path U A A) (\ i. Ext A [(i = 1) -> (A, \ x. x, \ x. ((x, \ i'. x), \ v. \ z. (v .2 @ [x, v .1] z, \ z'. v .2 @ [x, v .1] (z /\ z')))), (i = 0) -> (A, \ x. x, \ x. ((x, \ i'. x), \ v. \ z. (v .2 @ [x, v .1] z, \ z'. v .2 @ [x, v .1] (z /\ z'))))]) (\ i. A)
\ A. \ j. \ i. Ext A [(i = 0) -> (A, id A, id/is-equiv A), (i = 1) -> (A, id A, id/is-equiv A), (j = 1) -> (A, id A, id/is-equiv A)]

Checking Definition: equiv-to-path/unique
(A : U) -> (B : U) -> (p : Path U A B) -> Path (Path U A B) (\ i. Ext B [(i = 1) -> (B, \ x. x, \ x. ((x, \ i'. x), \ v. \ z. (v .2 @ [x, v .1] z, \ z'. v .2 @ [x, v .1] (z /\ z')))), (i = 0) -> (A, \ u. coe 0 1 (i'. p @ [A, B] i') u, coe 0 1 (i'. (y : p @ [A, B] i') -> (x : (x : A) * Path (p @ [A, B] i') y (coe 0 1 (i''. p @ [A, B] (i' /\ i'')) x)) * (y' : (x' : A) * Path (p @ [A, B] i') y (coe 0 1 (i''. p @ [A, B] (i' /\ i'')) x')) -> Path ((x' : A) * Path (p @ [A, B] i') y (coe 0 1 (i''. p @ [A, B] (i' /\ i'')) x')) x y') (coe 0 1 (i'. (y : A) -> (x : (x : A) * Path A y (coe 0 i' (i''. A) x)) * (y' : (x' : A) * Path A y (coe 0 i' (i''. A) x')) -> Path ((x' : A) * Path A y (coe 0 i' (i''. A) x')) x y') (\ x. ((x, \ i'. x), \ v. \ z. (v .2 @ [x, v .1] z, \ z'. v .2 @ [x, v .1] (z /\ z'))))))]) p
\ A. J U A (\ B. \ p. Path (Path U A B) (equiv-to-path A B (path-to-equiv A B p)) p) (comp Path U A A (equiv-to-path A A (path-to-equiv A A (refl U A))) (equiv-to-path A A (IdEquiv A)) (\ i. equiv-to-path A A (path-to-equiv/refl A @ [(\ u. coe 0 1 (i'. A) u, coe 0 1 (i'. (y : A) -> (x : (x : A) * Path A y (coe 0 1 (i''. A) x)) * (y' : (x' : A) * Path A y (coe 0 1 (i''. A) x')) -> Path ((x' : A) * Path A y (coe 0 1 (i''. A) x')) x y') (coe 0 1 (i'. (y : A) -> (x : (x : A) * Path A y (coe 0 i' (i''. A) x)) * (y' : (x' : A) * Path A y (coe 0 i' (i''. A) x')) -> Path ((x' : A) * Path A y (coe 0 i' (i''. A) x')) x y') (\ x. ((x, \ i'. x), \ v. \ z. (v .2 @ [x, v .1] z, \ z'. v .2 @ [x, v .1] (z /\ z')))))), (\ x. x, \ x. ((x, \ i'. x), \ v. \ z. (v .2 @ [x, v .1] z, \ z'. v .2 @ [x, v .1] (z /\ z'))))] i)) (refl U A) (equiv-to-path/IdEquiv A))

Checking Definition: univalence/Iso
(A : U) -> (B : U) -> (f : ((e : A -> B) * (y : B) -> (x : (x : A) * Path B y (e x)) * (y' : (x' : A) * Path B y (e x')) -> Path ((x' : A) * Path B y (e x')) x y') -> Path U A B) * (g : Path U A B -> (e : A -> B) * (y : B) -> (x : (x : A) * Path B y (e x)) * (y' : (x' : A) * Path B y (e x')) -> Path ((x' : A) * Path B y (e x')) x y') * ((x : Path U A B) -> Path (Path U A B) (f (g x)) x) * (x : (e : A -> B) * (y : B) -> (x : (x : A) * Path B y (e x)) * (y' : (x' : A) * Path B y (e x')) -> Path ((x' : A) * Path B y (e x')) x y') -> Path ((e : A -> B) * (y : B) -> (x' : (x' : A) * Path B y (e x')) * (y' : (x'' : A) * Path B y (e x'')) -> Path ((x'' : A) * Path B y (e x'')) x' y') (g (f x)) x
\ A. \ B. (equiv-to-path A B, (path-to-equiv A B, (equiv-to-path/unique A B, equiv-to-path/comp A B)))

Checking Definition: Sg-path/left
(A : U) -> (B : A -> U) -> (u : (x : A) * B x) -> (v : (x : A) * B x) -> (p : Path ((x : A) * B x) u v) -> Path A u .1 v .1
\ A. \ B. \ u. \ v. \ p. J (Sg A B) u (\ w. \ _. Path A u .1 w .1) (refl A u .1) v p

Successfully checked 94 definitions
Evaluation of \ A. \ B. \ u. \ v. \ p. J (Sg A B) u (\ w. \ _. Path A u .1 w .1) (refl A u .1) v p
Yields \ A. \ B. \ u. \ v. \ p. coe 0 1 (i. Path A u .1 (p @ [u, v] i) .1) (\ i. u .1)
#+end_example
