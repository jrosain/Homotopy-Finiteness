module Lib.Prop.Equiv where

import Lib.Prop.Contr
import Lib.Prop.Sg
import Lib.Data.Map

map-equiv (A B : U) (e : Equiv A B) : A -> B = e.1
Equiv/is-equiv (A B : U) (e : Equiv A B) : is-equiv A B (map-equiv A B e) = e.2

is-equiv/refl (A : U) : is-equiv A A (id A)
  = id/is-equiv A

Equiv/refl (A : U) : Equiv A A
  = IdEquiv A



Equiv/sym (A B : U) (e : Equiv A B) : Equiv B A =
  path-to-equiv B A (inv U A B (equiv-to-path A B e))

is-equiv/trans/center (A B C : U) (f : A -> B) (e-f : is-equiv A B f) (g : B -> C) (e-g : is-equiv B C g) (y : C)
  : Fib A C (map/comp A B C g f) y =
  let z : B = (center (Fib B C g y) (e-g y)).1 in
  let x : A = (center (Fib A B f z) (e-f z)).1 in
  (x,
   comp C y (g z) (center (Fib B C g y) (e-g y)).2
            (g (f x)) (ap B C g z (f x) (center (Fib A B f z) (e-f z)).2))

--is-equiv/trans/contr/proj1 (A B C : U) (f : A -> B) (e-f : is-equiv A B f) (g : B -> C) (e-g : is-equiv B C g) (y : C) (fib-comp : Fib A C (map/comp A B C g f) y)
--  : Path A (is-equiv/trans/center A B C f e-f g e-g y).1 fib-comp.1 =
  --(Sg-path/left A (\ x. Path B x (f fib-comp.1)) (center (Fib A B (f fib-comp.1)) e-f) fib-comp (e-f (f fib-comp.1) fib-comp)).1

-- is-equiv/trans (A B C : U) (f : A -> B) (e-f : is-equiv A B f) (g : B -> C) (e-g : is-equiv B C g) :
--   is-equiv (map/comp g f) =
--     \ y. (is-equiv/trans/center A B C f e-f g e-g y, is-equiv/trans/contr A B C f e-f g e-g y)

Equiv/trans (A B C : U) (e-AB : Equiv A B) (e-BC : Equiv B C) : Equiv A C =
   path-to-equiv A C (comp U A B (equiv-to-path A B e-AB) C (equiv-to-path B C e-BC))

-- Equiv/trans'
