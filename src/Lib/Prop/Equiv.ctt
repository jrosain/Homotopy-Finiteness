module Lib.Prop.Equiv where

import Lib.Prop.Contr
import Lib.Prop.Sg
import Lib.Data.Map
import Lib.Data.Empty
import Lib.Data.Decidability  
import Lib.QInv
import Lib.ContrMap
import Lib.Prop.ActionPaths

Equiv/map (A B : U) (e : Equiv A B) : A -> B = e.1
Equiv/is-equiv (A B : U) (e : Equiv A B) : is-equiv A B (Equiv/map A B e) = e.2

is-equiv/inv-map (A B : U) (f : A -> B) (e : is-equiv A B f) : B -> A =
  is-bi-inv/inv-map A B f (is-equiv/is-bi-inv A B f e)

Equiv/inv-map (A B : U) (e : Equiv A B) : B -> A =
  is-equiv/inv-map A B (Equiv/map A B e) (Equiv/is-equiv A B e)

is-equiv/inv-is-equiv (A B : U) (f : A -> B) (e : is-equiv A B f) : is-equiv B A (is-equiv/inv-map A B f e) =
  let b : is-bi-inv A B f = is-equiv/is-bi-inv A B f e
      g : B -> A = is-bi-inv/inv-map A B f b
      b' : is-bi-inv B A g = ((f, is-bi-inv/inv-left-htpy A B f b), (f, is-bi-inv/inv-right-htpy A B f b))
  in is-bi-inv/is-equiv B A g b'

Equiv/inv-equiv (A B : U) (e : Equiv A B) : Equiv B A =
  (Equiv/inv-map A B e, is-equiv/inv-is-equiv A B (Equiv/map A B e) (Equiv/is-equiv A B e))

is-equiv/inv-right-htpy (A B : U) (f : A -> B) (e : is-equiv A B f)
                             :  Htpy' B B (\ z. f (is-equiv/inv-map A B f e z)) (id B) =
  is-bi-inv/inv-right-htpy A B f (is-equiv/is-bi-inv A B f e)

is-equiv/inv-left-htpy (A B : U) (f : A -> B) (e : is-equiv A B f)
                            : Htpy' A A (\ z . (is-equiv/inv-map A B f e) (f z)) (id A) =
  is-bi-inv/inv-left-htpy A B f (is-equiv/is-bi-inv A B f e)

Equiv/inv-right-htpy (A B : U) (e : Equiv A B) : Htpy' B B (\ z. (Equiv/map A B e) (Equiv/inv-map A B e z)) (id B) =
  is-equiv/inv-right-htpy A B (Equiv/map A B e) (Equiv/is-equiv A B e)

Equiv/inv-left-htpy (A B : U) (e : Equiv A B) : Htpy' A A (\ z. (Equiv/inv-map A B e) (Equiv/map A B e z)) (id A) =
  is-equiv/inv-left-htpy A B (Equiv/map A B e) (Equiv/is-equiv A B e)

is-equiv/refl (A : U) : is-equiv A A (id A)
  = id/is-equiv A

Equiv/refl (A : U) : Equiv A A
  = IdEquiv A

is-equiv/sym : (A B : U) -> (f : A -> B) -> (e : is-equiv A B f) -> is-equiv B A (is-equiv/inv-map A B f e) = is-equiv/inv-is-equiv 

Equiv/sym : (A B : U) -> (e : Equiv A B) -> Equiv B A = Equiv/inv-equiv

is-equiv/trans (A B C : U) (f : A -> B) (g : B -> C) (eF : is-equiv A B f) (eG : is-equiv B C g) : is-equiv A C (map/comp A B C g f) =
  is-bi-inv/is-equiv A C (map/comp A B C g f)
                         (is-bi-inv/comp-is-bi-inv A B C f g (is-equiv/is-bi-inv A B f eF) (is-equiv/is-bi-inv B C g eG))

Equiv/trans (A B C : U) (e-AB : Equiv A B) (e-BC : Equiv B C) : Equiv A C =
  (map/comp A B C (Equiv/map B C e-BC) (Equiv/map A B e-AB), is-equiv/trans A B C (Equiv/map A B e-AB) (Equiv/map B C e-BC) (Equiv/is-equiv A B e-AB) (Equiv/is-equiv B C e-BC))

is-empty/is-equiv (A : U) (f : is-empty A) : is-equiv A Empty f =
  \ x. ind-Empty (\ y. is-contr (Fib A Empty f y)) x

Empty/equiv (A : U) (f : is-empty A) : Equiv A Empty =
  (f, is-empty/is-equiv A f)

is-decidable/is-equiv (A B : U) (f : A -> B) (e : is-equiv A B f) (dB : is-decidable B) : is-decidable A =
  Coprod/map B (neg B) A (neg A)
             (is-equiv/inv-map A B f e)
             (\ g a. g (f a)) dB

is-decidable-is-equiv' (A B : U) (f : A -> B) (e : is-equiv A B f) (dA : is-decidable A) : is-decidable B =
  is-decidable/is-equiv B A (is-equiv/inv-map A B f e) (is-equiv/sym A B f e) dA

is-decidable/Equiv (A B : U) (e : Equiv A B) (dB : is-decidable B) : is-decidable A =
  Coprod/map B (neg B) A (neg A)
             (Equiv/inv-map A B e)
             (\ f a. f ((Equiv/map A B e) a)) dB

is-decidable/Equiv' (A B : U) (e : Equiv A B) (dA : is-decidable A) : is-decidable B =
  is-decidable/Equiv B A (Equiv/sym A B e) dA

has-decidable-equality/is-equiv (A B : U) (f : A -> B) (e : is-equiv A B f) (dB : has-decidable-equality B) : has-decidable-equality A =
  \ x y.
    let eq-A : U = (Path A x y)
        eq-B : U = (Path B (f x) (f y)) 
        g : B -> A = is-equiv/inv-map A B f e
        p : Path (A -> A) (\ z. g (f z)) (id A) = eq-htpy A A (\ z. g (f z)) (id A) (is-equiv/inv-left-htpy A B f e)
        h : Path B (f x) (f y) -> Path A x y = \ q. (tr (A -> A) (\ z. g (f z)) (id A) p (\ i. Path A (i x) (i y)) (ap B A g (f x) (f y) q))
    in
    Coprod/map eq-B (neg eq-B) eq-A (neg eq-A) h
                    (\ i q. i (ap A B f x y q)) (dB (f x) (f y))

has-decidable-equality/is-equiv' (A B : U) (f : A -> B) (e : is-equiv A B f) (dA : has-decidable-equality A) : has-decidable-equality B =
  has-decidable-equality/is-equiv B A (is-equiv/inv-map A B f e) (is-equiv/inv-is-equiv A B f e) dA

has-decidable-equality/Equiv (A B : U) (e : Equiv A B) (dB : has-decidable-equality B) : has-decidable-equality A =
  has-decidable-equality/is-equiv A B (Equiv/map A B e) (Equiv/is-equiv A B e) dB

has-decidable-equality/Equiv' (A B : U) (e : Equiv A B) (dA : has-decidable-equality A) : has-decidable-equality B =
  has-decidable-equality/is-equiv' A B (Equiv/map A B e) (Equiv/is-equiv A B e) dA

is-equiv/is-equiv-id (A B : U) (f : A -> B) (e : is-equiv A B f) (x y : A)
                          : is-equiv (Path A x y) (Path B (f x) (f y)) (ap A B f x y) =
  is-bi-inv/is-equiv (Path A x y) (Path B (f x) (f y)) (ap A B f x y)
                     (ap/closure-bi-inv A B f (is-equiv/is-bi-inv A B f e) x y)

Equiv/Equiv-id (A B : U) (e : Equiv A B) (x y : A) : Equiv (Path A x y) (Path B (Equiv/map A B e x) (Equiv/map A B e y)) =
  (ap A B (Equiv/map A B e) x y, is-equiv/is-equiv-id A B (Equiv/map A B e) (Equiv/is-equiv A B e) x y)

is-contr/is-contr-equiv (A B : U) (e : Equiv A B) (c : is-contr B) : is-contr A =
  let b : B = center B c
      f : A -> B = Equiv/map A B e
      fc : Fib A B f b = (center (Fib A B f b) (Equiv/is-equiv A B e b))
      x : A = fc.1
      p : (y : A) -> Path A x y = \ y. Sg-path/left A (\ z. Path B b (f z)) fc (y, contraction B c (f y)) ((Equiv/is-equiv A B e b).2 (y, contraction B c (f y)))
  in (x, p)

is-contr/is-contr-equiv' (A B : U) (e : Equiv A B) (c : is-contr A) : is-contr B =
  is-contr/is-contr-equiv B A (Equiv/sym A B e) c

is-contr/is-equiv-contr (A B : U) (cA : is-contr A) (cB : is-contr B) : Equiv A B =
  is-bi-inv/Equiv A B (is-bi-inv/is-bi-inv-contr-map A B cB) (is-bi-inv/is-bi-inv-contr A B cA cB)

is-equiv/is-bi-inv-copr-empty-type-map (A : U) : Coprod Empty A -> A = split
  inl x -> ex-falso A x
  inr y -> y

is-equiv/is-bi-inv-copr-empty-type-inv-map (A : U) : A -> Coprod Empty A = \ x. inr x

is-equiv/is-bi-inv-copr-empty-type-left-htpy (A : U) : Htpy' (Coprod Empty A) (Coprod Empty A)
                                                             (\ z. (is-equiv/is-bi-inv-copr-empty-type-inv-map A) (is-equiv/is-bi-inv-copr-empty-type-map A z)) (id (Coprod Empty A)) = split
  inl x -> ex-falso (Path (Coprod Empty A) ((is-equiv/is-bi-inv-copr-empty-type-inv-map A) (is-equiv/is-bi-inv-copr-empty-type-map A (inl x))) (inl x)) x
  inr y -> refl (Coprod Empty A) (inr y)

is-equiv/is-bi-inv-copr-empty-type (A : U) : is-bi-inv (Coprod Empty A) A (is-equiv/is-bi-inv-copr-empty-type-map A) =
  has-inverse-is-bi-inv (Coprod Empty A) A (is-equiv/is-bi-inv-copr-empty-type-map A)
    (is-equiv/is-bi-inv-copr-empty-type-inv-map A, (\ x. refl A x, is-equiv/is-bi-inv-copr-empty-type-left-htpy A))

is-equiv/is-equiv-copr-empty-type (A : U) : is-equiv (Coprod Empty A) A (is-equiv/is-bi-inv-copr-empty-type-map A) =
  is-bi-inv/is-equiv (Coprod Empty A) A (is-equiv/is-bi-inv-copr-empty-type-map A) (is-equiv/is-bi-inv-copr-empty-type A)

Equiv/Equiv-copr-empty-type (A : U) : Equiv (Coprod Empty A) A =
  (is-equiv/is-bi-inv-copr-empty-type-map A, is-equiv/is-equiv-copr-empty-type A)

is-equiv/is-bi-inv-comm-copr-map (A B : U) : Coprod A B -> Coprod B A = split
  inl x -> inr x
  inr y -> inl y

is-equiv/is-bi-inv-comm-copr-map-htpy (A B : U) : Htpy' (Coprod B A) (Coprod B A) 
                                                        (\ z. (is-equiv/is-bi-inv-comm-copr-map A B) (is-equiv/is-bi-inv-comm-copr-map B A z)) (id (Coprod B A)) = split
  inl x -> refl (Coprod B A) (inl x)
  inr y -> refl (Coprod B A) (inr y)

is-equiv/is-bi-inv-comm-copr (A B : U) : is-bi-inv (Coprod A B) (Coprod B A) (is-equiv/is-bi-inv-comm-copr-map A B) =
  has-inverse-is-bi-inv (Coprod A B) (Coprod B A) (is-equiv/is-bi-inv-comm-copr-map A B)
    (is-equiv/is-bi-inv-comm-copr-map B A, (is-equiv/is-bi-inv-comm-copr-map-htpy A B, is-equiv/is-bi-inv-comm-copr-map-htpy B A))

is-equiv/commutative-coprod (A B : U) : is-equiv (Coprod A B) (Coprod B A) (is-equiv/is-bi-inv-comm-copr-map A B) =
  is-bi-inv/is-equiv (Coprod A B) (Coprod B A) (is-equiv/is-bi-inv-comm-copr-map A B) (is-equiv/is-bi-inv-comm-copr A B)

Equiv/commutative-coprod (A B : U) : Equiv (Coprod A B) (Coprod B A) =
  (is-equiv/is-bi-inv-comm-copr-map A B, is-equiv/commutative-coprod A B)

Equiv/Equiv-copr-type-empty (A : U) : Equiv (Coprod A Empty) A =
  Equiv/trans (Coprod A Empty) (Coprod Empty A) A (Equiv/commutative-coprod A Empty) (Equiv/Equiv-copr-empty-type A)

Equiv/is-equiv-Sg-empty-map (A : Empty -> U) : (Sg Empty A) -> Empty =
  \ u. u.1

Equiv/is-equiv-Sg-empty-inv-map (A : Empty -> U) : Empty -> (Sg Empty A) =
  \ x. (x, ex-falso (A x) x)

Equiv/is-equiv-Sg-empty-right-htpy (A : Empty -> U) : Htpy' Empty Empty
                                                           (\ z. (Equiv/is-equiv-Sg-empty-map A) (Equiv/is-equiv-Sg-empty-inv-map A z))
                                                           (id Empty) = \ x. refl Empty x

Equiv/is-equiv-Sg-empty-left-htpy (A : Empty -> U) : Htpy' (Sg Empty A) (Sg Empty A)
                                                          (\ z. (Equiv/is-equiv-Sg-empty-inv-map A) (Equiv/is-equiv-Sg-empty-map A z))
                                                          (id (Sg Empty A)) =
  \ u. ex-falso (Path (Sg Empty A) ((Equiv/is-equiv-Sg-empty-inv-map A) (Equiv/is-equiv-Sg-empty-map A u)) u) u.1

Equiv/is-equiv-Sg-empty (A : Empty -> U) : is-equiv (Sg Empty A) Empty (Equiv/is-equiv-Sg-empty-map A) =
  has-inverse/is-equiv (Sg Empty A) Empty (Equiv/is-equiv-Sg-empty-map A)
    (Equiv/is-equiv-Sg-empty-inv-map A, (Equiv/is-equiv-Sg-empty-right-htpy A, Equiv/is-equiv-Sg-empty-left-htpy A))

Equiv/Equiv-Sg-empty (A : Empty -> U) : Equiv (Sg Empty A) Empty =
  (Equiv/is-equiv-Sg-empty-map A, Equiv/is-equiv-Sg-empty A)

Equiv/Sg-distr-over-coprod-map/sg (A B : U) (C : (Coprod A B) -> U) : (z : Coprod A B) -> (C z) -> (Coprod (Sg A (\ x. C (inl x))) (Sg B (\ y. C (inr y)))) = split
  inl x -> \ c. inl (x, c)
  inr y -> \ c. inr (y, c)

Equiv/Sg-distr-over-coprod-map (A B : U) (C : (Coprod A B) -> U) : (Sg (Coprod A B) C) -> (Coprod (Sg A (\ x. C (inl x))) (Sg B (\ y. C (inr y)))) =
  \ u. Equiv/Sg-distr-over-coprod-map/sg A B C u.1 u.2

Equiv/Sg-distr-over-coprod-inv-map (A B : U) (C : (Coprod A B) -> U) : (Coprod (Sg A (\ x. C (inl x))) (Sg B (\ y. C (inr y)))) -> (Sg (Coprod A B) C) = split
  inl u -> (inl u.1, u.2)
  inr v -> (inr v.1, v.2)

Equiv/Sg-distr-over-coprod-right-htpy (A B : U) (C : (Coprod A B) -> U) : Htpy' (Coprod (Sg A (\ x. C (inl x))) (Sg B (\ y. C (inr y))))
                                                                               (Coprod (Sg A (\ x. C (inl x))) (Sg B (\ y. C (inr y))))
                                                                               (\ z. (Equiv/Sg-distr-over-coprod-map A B C) (Equiv/Sg-distr-over-coprod-inv-map A B C z))
                                                                               (id (Coprod (Sg A (\ x. C (inl x))) (Sg B (\ y. C (inr y))))) = split
  inl u -> refl (Coprod (Sg A (\ x. C (inl x))) (Sg B (\ y. C (inr y)))) (inl u)
  inr v -> refl (Coprod (Sg A (\ x. C (inl x))) (Sg B (\ y. C (inr y)))) (inr v)

Equiv/Sg-distr-over-coprod-left-htpy/sg (A B : U) (C : (Coprod A B) -> U)
                                             : (z : (Coprod A B)) -> (c : C z) -> Path (Sg (Coprod A B) C)
                                                                                     ((Equiv/Sg-distr-over-coprod-inv-map A B C) (Equiv/Sg-distr-over-coprod-map A B C (z, c)))
                                                                                     (z, c) = split
  inl x -> \ c. refl (Sg (Coprod A B) C) (inl x, c)
  inr y -> \ c. refl (Sg (Coprod A B) C) (inr y, c)

Equiv/Sg-distr-over-coprod-left-htpy (A B : U) (C : (Coprod A B) -> U) : Htpy' (Sg (Coprod A B) C) (Sg (Coprod A B) C)
                                                                              (\ z. (Equiv/Sg-distr-over-coprod-inv-map A B C) (Equiv/Sg-distr-over-coprod-map A B C z))
                                                                              (id (Sg (Coprod A B) C)) =
  \ u. Equiv/Sg-distr-over-coprod-left-htpy/sg A B C u.1 u.2

Equiv/Sg-distr-over-coprod-is-equiv (A B : U) (C : (Coprod A B) -> U) : is-equiv (Sg (Coprod A B) C) (Coprod (Sg A (\ x. C (inl x))) (Sg B (\ y. C (inr y))))
                                                                                (Equiv/Sg-distr-over-coprod-map A B C) =
  has-inverse/is-equiv (Sg (Coprod A B) C) (Coprod (Sg A (\ x. C (inl x))) (Sg B (\ y. C (inr y)))) (Equiv/Sg-distr-over-coprod-map A B C)
    (Equiv/Sg-distr-over-coprod-inv-map A B C, (Equiv/Sg-distr-over-coprod-right-htpy A B C, Equiv/Sg-distr-over-coprod-left-htpy A B C))


Equiv/Sg-distr-over-coprod (A B : U) (C : (Coprod A B) -> U) : Equiv (Sg (Coprod A B) C) (Coprod (Sg A (\ x. C (inl x))) (Sg B (\ y. C (inr y)))) =
  (Equiv/Sg-distr-over-coprod-map A B C, Equiv/Sg-distr-over-coprod-is-equiv A B C)

Equiv/Sg-unit-map/sg (A : Unit -> U) : (x : Unit) -> (A x) -> A star = split
  star -> (id (A star))

Equiv/Sg-unit-map (A : Unit -> U) : (Sg Unit A) -> (A star) = \ u. Equiv/Sg-unit-map/sg A u.1 u.2

Equiv/Sg-unit-inv-map (A : Unit -> U) : (A star) -> (Sg Unit A) = \ a. (star, a)

Equiv/Sg-unit-right-htpy (A : Unit -> U) : Htpy' (A star) (A star) (\ z. (Equiv/Sg-unit-map A) (Equiv/Sg-unit-inv-map A z)) (id (A star)) =
  \ a. refl (A star) a

Equiv/Sg-unit-left-htpy/sg (A : Unit -> U) : (x : Unit) -> (a : A x) -> Path (Sg Unit A) ((Equiv/Sg-unit-inv-map A) (Equiv/Sg-unit-map A (x, a))) (x, a) = split
  star -> \ a. refl (Sg Unit A) (star, a)

Equiv/Sg-unit-left-htpy (A : Unit -> U) : Htpy' (Sg Unit A) (Sg Unit A) (\ z. (Equiv/Sg-unit-inv-map A) (Equiv/Sg-unit-map A z)) (id (Sg Unit A)) =
  \ u. Equiv/Sg-unit-left-htpy/sg A u.1 u.2

Equiv/Sg-unit-is-equiv (A : Unit -> U) : is-equiv (Sg Unit A) (A star) (Equiv/Sg-unit-map A) =
  has-inverse/is-equiv (Sg Unit A) (A star) (Equiv/Sg-unit-map A)
    (Equiv/Sg-unit-inv-map A, (Equiv/Sg-unit-right-htpy A, Equiv/Sg-unit-left-htpy A))

Equiv/Sg-unit (A : Unit -> U) : Equiv (Sg Unit A) (A star) =
  (Equiv/Sg-unit-map A, Equiv/Sg-unit-is-equiv A)

test : Nat = zero
