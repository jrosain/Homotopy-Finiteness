module Lib.Prop.Equiv where

import Lib.Prop.Contr
import Lib.Prop.Sg
import Lib.Data.Map
import Lib.Data.Empty
import Lib.Data.Decidability  
import Lib.QInv

Equiv/map (A B : U) (e : Equiv A B) : A -> B = e.1
Equiv/is-equiv (A B : U) (e : Equiv A B) : is-equiv A B (Equiv/map A B e) = e.2

-- is-equiv/inv-map (A B : U) (f : A -> B) (e : is-equiv A B f) : B -> A =
-- Equiv/inv-map (A B : U) (e : Equiv A B) : B -> A =
--  is-equiv/inv-map A B (Equiv/map A B e) (Equiv/is-equiv A B e)  

Equiv/inv-map (A B : U) (e : Equiv A B) : B -> A =
  Equiv/map B A (path-to-equiv B A (inv U A B (equiv-to-path A B e)))

is-equiv/refl (A : U) : is-equiv A A (id A)
  = id/is-equiv A

Equiv/refl (A : U) : Equiv A A
  = IdEquiv A



Equiv/sym (A B : U) (e : Equiv A B) : Equiv B A =
  path-to-equiv B A (inv U A B (equiv-to-path A B e))

is-equiv/trans/center (A B C : U) (f : A -> B) (e-f : is-equiv A B f) (g : B -> C) (e-g : is-equiv B C g) (y : C)
  : Fib A C (map/comp A B C g f) y =
  let z : B = (center (Fib B C g y) (e-g y)).1 in
  let x : A = (center (Fib A B f z) (e-f z)).1 in
  (x,
   comp C y (g z) (center (Fib B C g y) (e-g y)).2
            (g (f x)) (ap B C g z (f x) (center (Fib A B f z) (e-f z)).2))

is-equiv/trans/fib (A B C : U) (f : A -> B) (g : B -> C) (y : C) (H : Fib A C (map/comp A B C g f) y)
  : Fib A B f (f H.1) = (H.1, refl B (f H.1))

is-equiv/trans/contr/proj1 (A B C : U) (f : A -> B) (e-f : is-equiv A B f) (g : B -> C) (e-g : is-equiv B C g) (y : C) (H : Fib A C (map/comp A B C g f) y)
 : Path A (e-f (f H.1)).1.1 H.1 =
  let x : A = (is-equiv/trans/center A B C f e-f g e-g y).1 in
  let x' : A = H.1 in
  let c : is-contr (Fib A B f (f x')) = e-f (f x') in
  let fib' : Fib A B f (f x') = is-equiv/trans/fib A B C f g y H in
  (Sg-path/left A (\ z. Path B (f x') (f z)) c.1 fib' (c.2 fib'))

-- is-equiv/trans (A B C : U) (f : A -> B) (e-f : is-equiv A B f) (g : B -> C) (e-g : is-equiv B C g) :
--   is-equiv (map/comp g f) =
--     \ y. (is-equiv/trans/center A B C f e-f g e-g y, is-equiv/trans/contr A B C f e-f g e-g y)

Equiv/trans (A B C : U) (e-AB : Equiv A B) (e-BC : Equiv B C) : Equiv A C =
   path-to-equiv A C (comp U A B (equiv-to-path A B e-AB) C (equiv-to-path B C e-BC))

is-empty/is-equiv (A : U) (f : is-empty A) : is-equiv A Empty f =
  \ x. ind-Empty (\ y. is-contr (Fib A Empty f y)) x

Empty/equiv (A : U) (f : is-empty A) : Equiv A Empty =
  (f, is-empty/is-equiv A f)

is-decidable/Equiv (A B : U) (e : Equiv A B) (dB : is-decidable B) : is-decidable A =
  Coprod/map B (neg B) A (neg A)
             (Equiv/inv-map A B e)
             (\ f a. f ((Equiv/map A B e) a)) dB

is-decidable/Equiv' (A B : U) (e : Equiv A B) (dA : is-decidable A) : is-decidable B =
  is-decidable/Equiv B A (Equiv/sym A B e) dA

-- has-decidable-equality/Equiv (A B : U) (e : Equiv A B) (dB : has-decidable-equality B) : has-decidable-equality A =
--   \ x y.
--     let eq-B = (Path B (Map/Equiv x) (Map/Equiv y))
--         eq-A = (Path A x y) in
--    Coprod/map eq-B (neg eq-B) eq-A (neg eq-A)
--               (\ p.

is-contr/is-contr-equiv (A B : U) (e : Equiv A B) (c : is-contr B) : is-contr A =
  let b : B = center B c
      f : A -> B = Equiv/map A B e
      fc : Fib A B f b = (center (Fib A B f b) (Equiv/is-equiv A B e b))
      x : A = fc.1
      p : (y : A) -> Path A x y = \ y. Sg-path/left A (\ z. Path B b (f z)) fc (y, contraction B c (f y)) ((Equiv/is-equiv A B e b).2 (y, contraction B c (f y)))
  in (x, p)

is-contr/is-contr-equiv' (A B : U) (e : Equiv A B) (c : is-contr A) : is-contr B =
  is-contr/is-contr-equiv B A (Equiv/sym A B e) c

is-contr/is-equiv-contr-map (A B : U) (cB : is-contr B) : A -> B =
  \ _. (center B cB)

is-contr/is-equiv-contr-inv-map (A B : U) (cA : is-contr A) : B -> A =
  \ _. (center A cA)
