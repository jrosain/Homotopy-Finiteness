module Lib.Prop.Equiv where

import Lib.Prop.Contr
import Lib.Prop.Sg
import Lib.Data.Map
import Lib.Data.Empty
import Lib.Data.Decidability  
import Lib.QInv
import Lib.ContrMap
import Lib.Prop.ActionPaths

Equiv/map (A B : U) (e : Equiv A B) : A -> B = e.1
Equiv/is-equiv (A B : U) (e : Equiv A B) : is-equiv A B (Equiv/map A B e) = e.2

is-equiv/inv-map (A B : U) (f : A -> B) (e : is-equiv A B f) : B -> A =
  is-bi-inv/inv-map A B f (is-equiv/is-bi-inv A B f e)

Equiv/inv-map (A B : U) (e : Equiv A B) : B -> A =
  is-equiv/inv-map A B (Equiv/map A B e) (Equiv/is-equiv A B e)

is-equiv/inv-is-equiv (A B : U) (f : A -> B) (e : is-equiv A B f) : is-equiv B A (is-equiv/inv-map A B f e) =
  let b : is-bi-inv A B f = is-equiv/is-bi-inv A B f e
      g : B -> A = is-bi-inv/inv-map A B f b
      b' : is-bi-inv B A g = ((f, is-bi-inv/inv-left-htpy A B f b), (f, is-bi-inv/inv-right-htpy A B f b))
  in is-bi-inv/is-equiv B A g b'

Equiv/inv-equiv (A B : U) (e : Equiv A B) : Equiv B A =
  (Equiv/inv-map A B e, is-equiv/inv-is-equiv A B (Equiv/map A B e) (Equiv/is-equiv A B e))

is-equiv/inv-right-htpy (A B : U) (f : A -> B) (e : is-equiv A B f)
                             :  Htpy' B B (\ z. f (is-equiv/inv-map A B f e z)) (id B) =
  is-bi-inv/inv-right-htpy A B f (is-equiv/is-bi-inv A B f e)

is-equiv/inv-left-htpy (A B : U) (f : A -> B) (e : is-equiv A B f)
                            : Htpy' A A (\ z . (is-equiv/inv-map A B f e) (f z)) (id A) =
  is-bi-inv/inv-left-htpy A B f (is-equiv/is-bi-inv A B f e)

Equiv/inv-right-htpy (A B : U) (e : Equiv A B) : Htpy' B B (\ z. (Equiv/map A B e) (Equiv/inv-map A B e z)) (id B) =
  is-equiv/inv-right-htpy A B (Equiv/map A B e) (Equiv/is-equiv A B e)

Equiv/inv-left-htpy (A B : U) (e : Equiv A B) : Htpy' A A (\ z. (Equiv/inv-map A B e) (Equiv/map A B e z)) (id A) =
  is-equiv/inv-left-htpy A B (Equiv/map A B e) (Equiv/is-equiv A B e)

is-equiv/refl (A : U) : is-equiv A A (id A)
  = id/is-equiv A

Equiv/refl (A : U) : Equiv A A
  = IdEquiv A

is-equiv/sym : (A B : U) -> (f : A -> B) -> (e : is-equiv A B f) -> is-equiv B A (is-equiv/inv-map A B f e) = is-equiv/inv-is-equiv 

Equiv/sym : (A B : U) -> (e : Equiv A B) -> Equiv B A = Equiv/inv-equiv

is-equiv/trans (A B C : U) (f : A -> B) (g : B -> C) (eF : is-equiv A B f) (eG : is-equiv B C g) : is-equiv A C (map/comp A B C g f) =
  is-bi-inv/is-equiv A C (map/comp A B C g f)
                         (is-bi-inv/comp-is-bi-inv A B C f g (is-equiv/is-bi-inv A B f eF) (is-equiv/is-bi-inv B C g eG))

Equiv/trans (A B C : U) (e-AB : Equiv A B) (e-BC : Equiv B C) : Equiv A C =
  (map/comp A B C (Equiv/map B C e-BC) (Equiv/map A B e-AB), is-equiv/trans A B C (Equiv/map A B e-AB) (Equiv/map B C e-BC) (Equiv/is-equiv A B e-AB) (Equiv/is-equiv B C e-BC))

is-empty/is-equiv (A : U) (f : is-empty A) : is-equiv A Empty f =
  \ x. ind-Empty (\ y. is-contr (Fib A Empty f y)) x

Empty/equiv (A : U) (f : is-empty A) : Equiv A Empty =
  (f, is-empty/is-equiv A f)

is-decidable/is-equiv (A B : U) (f : A -> B) (e : is-equiv A B f) (dB : is-decidable B) : is-decidable A =
  Coprod/map B (neg B) A (neg A)
             (is-equiv/inv-map A B f e)
             (\ g a. g (f a)) dB

is-decidable-is-equiv' (A B : U) (f : A -> B) (e : is-equiv A B f) (dA : is-decidable A) : is-decidable B =
  is-decidable/is-equiv B A (is-equiv/inv-map A B f e) (is-equiv/sym A B f e) dA

is-decidable/Equiv (A B : U) (e : Equiv A B) (dB : is-decidable B) : is-decidable A =
  Coprod/map B (neg B) A (neg A)
             (Equiv/inv-map A B e)
             (\ f a. f ((Equiv/map A B e) a)) dB

is-decidable/Equiv' (A B : U) (e : Equiv A B) (dA : is-decidable A) : is-decidable B =
  is-decidable/Equiv B A (Equiv/sym A B e) dA

has-decidable-equality/is-equiv (A B : U) (f : A -> B) (e : is-equiv A B f) (dB : has-decidable-equality B) : has-decidable-equality A =
  \ x y.
    let eq-A : U = (Path A x y)
        eq-B : U = (Path B (f x) (f y)) 
        g : B -> A = is-equiv/inv-map A B f e
        p : Path (A -> A) (\ z. g (f z)) (id A) = eq-htpy A A (\ z. g (f z)) (id A) (is-equiv/inv-left-htpy A B f e)
        h : Path B (f x) (f y) -> Path A x y = \ q. (tr (A -> A) (\ z. g (f z)) (id A) p (\ i. Path A (i x) (i y)) (ap B A g (f x) (f y) q))
    in
    Coprod/map eq-B (neg eq-B) eq-A (neg eq-A) h
                    (\ i q. i (ap A B f x y q)) (dB (f x) (f y))

has-decidable-equality/is-equiv' (A B : U) (f : A -> B) (e : is-equiv A B f) (dA : has-decidable-equality A) : has-decidable-equality B =
  has-decidable-equality/is-equiv B A (is-equiv/inv-map A B f e) (is-equiv/inv-is-equiv A B f e) dA

has-decidable-equality/Equiv (A B : U) (e : Equiv A B) (dB : has-decidable-equality B) : has-decidable-equality A =
  has-decidable-equality/is-equiv A B (Equiv/map A B e) (Equiv/is-equiv A B e) dB

has-decidable-equality/Equiv' (A B : U) (e : Equiv A B) (dA : has-decidable-equality A) : has-decidable-equality B =
  has-decidable-equality/is-equiv' A B (Equiv/map A B e) (Equiv/is-equiv A B e) dA

is-equiv/is-equiv-id (A B : U) (f : A -> B) (e : is-equiv A B f) (x y : A)
                          : is-equiv (Path A x y) (Path B (f x) (f y)) (ap A B f x y) =
  is-bi-inv/is-equiv (Path A x y) (Path B (f x) (f y)) (ap A B f x y)
                     (ap/closure-bi-inv A B f (is-equiv/is-bi-inv A B f e) x y)

Equiv/Equiv-id (A B : U) (e : Equiv A B) (x y : A) : Equiv (Path A x y) (Path B (Equiv/map A B e x) (Equiv/map A B e y)) =
  (ap A B (Equiv/map A B e) x y, is-equiv/is-equiv-id A B (Equiv/map A B e) (Equiv/is-equiv A B e) x y)

is-contr/is-contr-equiv (A B : U) (e : Equiv A B) (c : is-contr B) : is-contr A =
  let b : B = center B c
      f : A -> B = Equiv/map A B e
      fc : Fib A B f b = (center (Fib A B f b) (Equiv/is-equiv A B e b))
      x : A = fc.1
      p : (y : A) -> Path A x y = \ y. Sg-path/left A (\ z. Path B b (f z)) fc (y, contraction B c (f y)) ((Equiv/is-equiv A B e b).2 (y, contraction B c (f y)))
  in (x, p)

is-contr/is-contr-equiv' (A B : U) (e : Equiv A B) (c : is-contr A) : is-contr B =
  is-contr/is-contr-equiv B A (Equiv/sym A B e) c

is-contr/is-equiv-contr (A B : U) (cA : is-contr A) (cB : is-contr B) : Equiv A B =
  is-bi-inv/Equiv A B (is-bi-inv/is-bi-inv-contr-map A B cB) (is-bi-inv/is-bi-inv-contr A B cA cB)

is-equiv/is-bi-inv-copr-empty-type-map (A : U) : Coprod Empty A -> A = split
  inl x -> ex-falso A x
  inr y -> y

is-equiv/is-bi-inv-copr-empty-type-inv-map (A : U) : A -> Coprod Empty A = \ x. inr x

is-equiv/is-bi-inv-copr-empty-type-left-htpy (A : U) : Htpy' (Coprod Empty A) (Coprod Empty A)
                                                             (\ z. (is-equiv/is-bi-inv-copr-empty-type-inv-map A) (is-equiv/is-bi-inv-copr-empty-type-map A z)) (id (Coprod Empty A)) = split
  inl x -> ex-falso (Path (Coprod Empty A) ((is-equiv/is-bi-inv-copr-empty-type-inv-map A) (is-equiv/is-bi-inv-copr-empty-type-map A (inl x))) (inl x)) x
  inr y -> refl (Coprod Empty A) (inr y)

is-equiv/is-bi-inv-copr-empty-type (A : U) : is-bi-inv (Coprod Empty A) A (is-equiv/is-bi-inv-copr-empty-type-map A) =
  has-inverse-is-bi-inv (Coprod Empty A) A (is-equiv/is-bi-inv-copr-empty-type-map A)
    (is-equiv/is-bi-inv-copr-empty-type-inv-map A, (\ x. refl A x, is-equiv/is-bi-inv-copr-empty-type-left-htpy A))

is-equiv/is-equiv-copr-empty-type (A : U) : is-equiv (Coprod Empty A) A (is-equiv/is-bi-inv-copr-empty-type-map A) =
  is-bi-inv/is-equiv (Coprod Empty A) A (is-equiv/is-bi-inv-copr-empty-type-map A) (is-equiv/is-bi-inv-copr-empty-type A)

Equiv/Equiv-copr-empty-type (A : U) : Equiv (Coprod Empty A) A =
  (is-equiv/is-bi-inv-copr-empty-type-map A, is-equiv/is-equiv-copr-empty-type A)

is-equiv/is-bi-inv-comm-copr-map (A B : U) : Coprod A B -> Coprod B A = split
  inl x -> inr x
  inr y -> inl y

is-equiv/is-bi-inv-comm-copr-map-htpy (A B : U) : Htpy' (Coprod B A) (Coprod B A) 
                                                        (\ z. (is-equiv/is-bi-inv-comm-copr-map A B) (is-equiv/is-bi-inv-comm-copr-map B A z)) (id (Coprod B A)) = split
  inl x -> refl (Coprod B A) (inl x)
  inr y -> refl (Coprod B A) (inr y)

is-equiv/is-bi-inv-comm-copr (A B : U) : is-bi-inv (Coprod A B) (Coprod B A) (is-equiv/is-bi-inv-comm-copr-map A B) =
  has-inverse-is-bi-inv (Coprod A B) (Coprod B A) (is-equiv/is-bi-inv-comm-copr-map A B)
    (is-equiv/is-bi-inv-comm-copr-map B A, (is-equiv/is-bi-inv-comm-copr-map-htpy A B, is-equiv/is-bi-inv-comm-copr-map-htpy B A))

is-equiv/commutative-coprod (A B : U) : is-equiv (Coprod A B) (Coprod B A) (is-equiv/is-bi-inv-comm-copr-map A B) =
  is-bi-inv/is-equiv (Coprod A B) (Coprod B A) (is-equiv/is-bi-inv-comm-copr-map A B) (is-equiv/is-bi-inv-comm-copr A B)

Equiv/commutative-coprod (A B : U) : Equiv (Coprod A B) (Coprod B A) =
  (is-equiv/is-bi-inv-comm-copr-map A B, is-equiv/commutative-coprod A B)

Equiv/Equiv-copr-type-empty (A : U) : Equiv (Coprod A Empty) A =
  Equiv/trans (Coprod A Empty) (Coprod Empty A) A (Equiv/commutative-coprod A Empty) (Equiv/Equiv-copr-empty-type A)
