module Lib.Prop.Equiv where

import Lib.Prop.Contr
import Lib.Prop.Sg
import Lib.Data.Map
import Lib.Data.Empty
import Lib.Data.Decidability  
import Lib.QInv
import Lib.ContrMap

Equiv/map (A B : U) (e : Equiv A B) : A -> B = e.1
Equiv/is-equiv (A B : U) (e : Equiv A B) : is-equiv A B (Equiv/map A B e) = e.2

is-equiv/inv-map (A B : U) (f : A -> B) (e : is-equiv A B f) : B -> A =
  is-bi-inv/inv-map A B f (is-equiv/is-bi-inv A B f e)

Equiv/inv-map (A B : U) (e : Equiv A B) : B -> A =
  is-equiv/inv-map A B (Equiv/map A B e) (Equiv/is-equiv A B e)

is-equiv/inv-is-equiv (A B : U) (f : A -> B) (e : is-equiv A B f) : is-equiv B A (is-equiv/inv-map A B f e) =
  is-bi-inv/is-equiv-is-equiv-left-map B A f (is-equiv/is-bi-inv A B f e)

Equiv/inv-equiv (A B : U) (e : Equiv A B) : Equiv B A =
  (Equiv/inv-map A B e, is-equiv/inv-is-equiv A B (Equiv/map A B e) (Equiv/is-equiv A B e))

is-equiv/refl (A : U) : is-equiv A A (id A)
  = id/is-equiv A

Equiv/refl (A : U) : Equiv A A
  = IdEquiv A

is-equiv/sym : (A B : U) -> (f : A -> B) -> (e : is-equiv A B f) -> is-equiv B A (is-equiv/inv-map A B f e) = is-equiv/inv-is-equiv 

Equiv/sym : (A B : U) -> (e : Equiv A B) -> Equiv B A = Equiv/inv-equiv

is-equiv/trans (A B C : U) (f : A -> B) (g : B -> C) (eF : is-equiv A B f) (eG : is-equiv B C g) : is-equiv A C (map/comp A B C g f) =
  is-bi-inv/is-equiv A C (map/comp A B C g f)
                         (is-bi-inv/comp-is-bi-inv A B C f g (is-equiv/is-bi-inv A B f eF) (is-equiv/is-bi-inv B C g eG))

Equiv/trans (A B C : U) (e-AB : Equiv A B) (e-BC : Equiv B C) : Equiv A C =
  (map/comp A B C (Equiv/map B C e-BC) (Equiv/map A B e-AB), is-equiv/trans A B C (Equiv/map A B e-AB) (Equiv/map B C e-BC) (Equiv/is-equiv A B e-AB) (Equiv/is-equiv B C e-BC))

is-equiv/trans/center (A B C : U) (f : A -> B) (e-f : is-equiv A B f) (g : B -> C) (e-g : is-equiv B C g) (y : C)
  : Fib A C (map/comp A B C g f) y =
  let z : B = (center (Fib B C g y) (e-g y)).1 in
  let x : A = (center (Fib A B f z) (e-f z)).1 in
  (x,
   comp C y (g z) (center (Fib B C g y) (e-g y)).2
            (g (f x)) (ap B C g z (f x) (center (Fib A B f z) (e-f z)).2))

is-equiv/trans/fib (A B C : U) (f : A -> B) (g : B -> C) (y : C) (H : Fib A C (map/comp A B C g f) y)
  : Fib A B f (f H.1) = (H.1, refl B (f H.1))

is-equiv/trans/contr/proj1 (A B C : U) (f : A -> B) (e-f : is-equiv A B f) (g : B -> C) (e-g : is-equiv B C g) (y : C) (H : Fib A C (map/comp A B C g f) y)
 : Path A (e-f (f H.1)).1.1 H.1 =
  let x : A = (is-equiv/trans/center A B C f e-f g e-g y).1 in
  let x' : A = H.1 in
  let c : is-contr (Fib A B f (f x')) = e-f (f x') in
  let fib' : Fib A B f (f x') = is-equiv/trans/fib A B C f g y H in
  (Sg-path/left A (\ z. Path B (f x') (f z)) c.1 fib' (c.2 fib'))

-- is-equiv/trans (A B C : U) (f : A -> B) (e-f : is-equiv A B f) (g : B -> C) (e-g : is-equiv B C g) :
--   is-equiv (map/comp g f) =
--     \ y. (is-equiv/trans/center A B C f e-f g e-g y, is-equiv/trans/contr A B C f e-f g e-g y)

-- Equiv/trans (A B C : U) (e-AB : Equiv A B) (e-BC : Equiv B C) : Equiv A C =
--    path-to-equiv A C (comp U A B (equiv-to-path A B e-AB) C (equiv-to-path B C e-BC))

is-empty/is-equiv (A : U) (f : is-empty A) : is-equiv A Empty f =
  \ x. ind-Empty (\ y. is-contr (Fib A Empty f y)) x

Empty/equiv (A : U) (f : is-empty A) : Equiv A Empty =
  (f, is-empty/is-equiv A f)

is-decidable/Equiv (A B : U) (e : Equiv A B) (dB : is-decidable B) : is-decidable A =
  Coprod/map B (neg B) A (neg A)
             (Equiv/inv-map A B e)
             (\ f a. f ((Equiv/map A B e) a)) dB

is-decidable/Equiv' (A B : U) (e : Equiv A B) (dA : is-decidable A) : is-decidable B =
  is-decidable/Equiv B A (Equiv/sym A B e) dA

-- has-decidable-equality/Equiv (A B : U) (e : Equiv A B) (dB : has-decidable-equality B) : has-decidable-equality A =
--   \ x y.
--     let eq-B = (Path B (Map/Equiv x) (Map/Equiv y))
--         eq-A = (Path A x y) in
--    Coprod/map eq-B (neg eq-B) eq-A (neg eq-A)
--               (\ p.

is-contr/is-contr-equiv (A B : U) (e : Equiv A B) (c : is-contr B) : is-contr A =
  let b : B = center B c
      f : A -> B = Equiv/map A B e
      fc : Fib A B f b = (center (Fib A B f b) (Equiv/is-equiv A B e b))
      x : A = fc.1
      p : (y : A) -> Path A x y = \ y. Sg-path/left A (\ z. Path B b (f z)) fc (y, contraction B c (f y)) ((Equiv/is-equiv A B e b).2 (y, contraction B c (f y)))
  in (x, p)

is-contr/is-contr-equiv' (A B : U) (e : Equiv A B) (c : is-contr A) : is-contr B =
  is-contr/is-contr-equiv B A (Equiv/sym A B e) c

is-contr/is-equiv-contr (A B : U) (cA : is-contr A) (cB : is-contr B) : Equiv A B =
  is-bi-inv/Equiv A B (is-bi-inv/is-bi-inv-contr-map A B cB) (is-bi-inv/is-bi-inv-contr A B cA cB)
