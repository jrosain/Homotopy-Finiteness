module Lib.Prop.BiInv where

import Lib.QInv
import Lib.Prop.QInv
import Lib.Data.Nat  
import Lib.Prop.Contr

is-bi-inv/comp-is-bi-inv (A B C : U) (f : A -> B) (g : B -> C) (b : is-bi-inv A B f) (b' : is-bi-inv B C g) : is-bi-inv A C (map/comp A B C g f) =
  has-inverse-is-bi-inv A C (map/comp A B C g f)
    (has-inverse/comp-has-inverse A B C f g
      (is-bi-inv-has-inverse A B f b)
      (is-bi-inv-has-inverse B C g b'))

is-bi-inv/is-bi-inv-comp-left (A B C : U) (f : A -> B) (g : B -> C) (b : is-bi-inv B C g) (b' : is-bi-inv A C (map/comp A B C g f)) : is-bi-inv A B f =
  has-inverse-is-bi-inv A B f
    (has-inverse/has-inverse-comp-left A B C f g
      (is-bi-inv-has-inverse B C g b)
      (is-bi-inv-has-inverse A C (map/comp A B C g f) b'))

is-bi-inv/is-bi-inv-comp-right (A B C : U) (f : A -> B) (g : B -> C) (b : is-bi-inv A B f)
                               (b' : is-bi-inv A C (map/comp A B C g f)) : is-bi-inv B C g =
  has-inverse-is-bi-inv B C g
    (has-inverse/has-inverse-comp-right A B C f g
      (is-bi-inv-has-inverse A B f b)
      (is-bi-inv-has-inverse A C (map/comp A B C g f) b'))

is-bi-inv/is-contr-is-bi-inv (A B : U) (f : A -> B) (b : is-bi-inv A B f) (c : is-contr B) : is-contr A =
  let g : B -> A = is-bi-inv/inv-map A B f b
      L : Htpy' A A (\ z. g (f z)) (id A) = is-bi-inv/inv-left-htpy A B f b
      x : A = g (center B c)
  in (x, \ y. comp A x (g (f y)) (ap B A g (center B c) (f y) (contraction B c (f y)))
                    y (L y))

is-bi-inv/is-contr-is-bi-inv' (A B : U) (f : A -> B) (b : is-bi-inv A B f) (c : is-contr A) : is-contr B =
  let g : B -> A = is-bi-inv/inv-map A B f b
      R : Htpy' B B (\ z. f (g z)) (id B) = is-bi-inv/inv-right-htpy A B f b
      L : Htpy' A A (\ z. g (f z)) (id A) = is-bi-inv/inv-left-htpy A B f b
  in is-bi-inv/is-contr-is-bi-inv B A g ((f, L), (f, R)) c

is-bi-inv/is-bi-inv-contr-map (A B : U) (cB : is-contr B) : A -> B =
  \ _. (center B cB)

is-bi-inv/is-bi-inv-contr-inv-map (A B : U) (cA : is-contr A) : B -> A =
  \ _. (center A cA)  

is-bi-inv/is-bi-inv-contr (A B : U) (cA : is-contr A) (cB : is-contr B) : is-bi-inv A B (is-bi-inv/is-bi-inv-contr-map A B cB) =
  let f : A -> B = is-bi-inv/is-bi-inv-contr-map A B cB
      g : B -> A = is-bi-inv/is-bi-inv-contr-inv-map A B cA
      R : Htpy' B B (\ z. f (g z)) (id B) = \ x. (contraction B cB x)
      L : Htpy' A A (\ z. g (f z)) (id A) = \ x. (contraction A cA x)
  in ((g, R), (g, L))

is-bi-inv-comp/injective (B C D : U) (g : B -> C) (h : C -> D) (K : is-bi-inv B D (map/comp B C D h g))
                         : is-injective B C g = \ x y p.
  let i : D -> B = is-bi-inv/inv-map B D (map/comp B C D h g) K
      q : Path D (h (g x)) (h (g y)) = ap C D h (g x) (g y) p
      r : Path B (i (h (g x))) (i (h (g y))) = ap D B i (h (g x)) (h (g y)) q
      H : Htpy B (\ _. B) (\ z. i (h (g z))) (id B) = is-bi-inv/inv-left-htpy B D (map/comp B C D h g) K
  in
  comp-n B three-Nat x (i (h (g x))) (inv B (i (h (g x))) x (H x))
                       (i (h (g y))) r
                       y (H y)

is-bi-inv-comp/is-inj-is-bi-inv-left-map (A B C : U) (f : A -> B) (g : B -> C) (inj : is-injective B C g) (H : is-bi-inv A C (map/comp A B C g f)) : is-bi-inv A B f =
  let i : C -> A = is-bi-inv/inv-map A C (map/comp A B C g f) H
      h : B -> A = map/comp B C A i g
      K : Htpy B (\ _. B) (map/comp B A B f h) (id B) =
          \ x. inj (f (h x)) x (is-bi-inv/inv-right-htpy A C (map/comp A B C g f) H (g x))
  in
  has-inverse-is-bi-inv A B f
                        (h, (K, is-bi-inv/inv-left-htpy A C (map/comp A B C g f) H))

is-bi-inv-comp/is-bi-inv-left-map (A B C D : U) (f : A -> B) (g : B -> C) (h : C -> D) (H : is-bi-inv A C (map/comp A B C g f))
                                  (K : is-bi-inv B D (map/comp B C D h g)) : is-bi-inv A B f =
  is-bi-inv-comp/is-inj-is-bi-inv-left-map A B C f g (is-bi-inv-comp/injective B C D g h K) H

is-bi-inv-comp/is-bi-inv-middle-map (A B C D : U) (f : A -> B) (g : B -> C) (h : C -> D) (H : is-bi-inv A C (map/comp A B C g f))
                                   (K : is-bi-inv B D (map/comp B C D h g)) : is-bi-inv B C g =
  is-bi-inv/is-bi-inv-comp-right A B C f g (is-bi-inv-comp/is-bi-inv-left-map A B C D f g h H K) H

is-bi-inv-comp/is-bi-inv-right-map (A B C D : U) (f : A -> B) (g : B -> C) (h : C -> D) (H : is-bi-inv A C (map/comp A B C g f))
                                   (K : is-bi-inv B D (map/comp B C D h g)) : is-bi-inv C D h =
  is-bi-inv/is-bi-inv-comp-right B C D g h (is-bi-inv-comp/is-bi-inv-middle-map A B C D f g h H K) K
