module Lib.Prop.Proposition where

import Stdlib.Prelude
import Lib.Data.Map
import Lib.Data.Unit
import Lib.Prop.Contr
import Lib.Prop.Unit
import Lib.Prop.Equiv

is-proof-irrelevant (A : U) : U =
  A -> is-contr A

is-subterminal (A : U) : U =
  Equiv A Unit

has-contr-eq (A : U) : U =
  (x y : A) -> is-contr (Path A x y)

is-prop/is-proof-irrelevant (A : U) (p : is-prop A) : is-proof-irrelevant A =
  \ x. (x, p x)

const-star (A : U) : A -> Unit = \ _. star

is-proof-irrelevant/contr-center (A : U) (x : A) (f : is-proof-irrelevant A) (y : Unit) : Fib A Unit (const-star A) y =
  ((f x).1, Unit/is-prop y (const-star A (f x).1))

is-proof-irrelevant/contr-contr (A : U) (x : A) (f : is-proof-irrelevant A) (y : Unit) (v : Fib A Unit (const-star A) y)
  : Path (Fib A Unit (const-star A) y) (is-proof-irrelevant/contr-center A x f y) v =
      let u : Fib A Unit (const-star A) y = (is-proof-irrelevant/contr-center A x f y)
          p : Path A u.1 v.1 = (f x).2 v.1
          r : (Path Unit y (const-star A v.1)) = (tr A u.1 v.1 p (\ z. Path Unit y (const-star A z)) u.2)
          q : Path (Path Unit y (const-star A v.1)) r v.2 =
                    Unit/is-set y (const-star A v.1) r v.2
      in
      SgPathO->PathSg A (\ z. Path Unit y (const-star A z)) u v (p, q)

is-proof-irrelevant/is-equiv-const-star (A : U) (x : A) (f : is-proof-irrelevant A) : is-equiv A Unit (const-star A) =
  \ y.
    let c : Fib A Unit (const-star A) y = is-proof-irrelevant/contr-center A x f y
        contr : (H : Fib A Unit (const-star A) y) -> Path (Fib A Unit (const-star A) y) c H =
                    is-proof-irrelevant/contr-contr A x f y
    in (c, contr)

is-proof-irrelevant/is-subterminal (A : U) (x : A) (f : is-proof-irrelevant A) : is-subterminal A =
  (const-star A, is-proof-irrelevant/is-equiv-const-star A x f)

is-subterminal/has-contr-eq (A : U) (e : is-subterminal A) : has-contr-eq A =
  \ x y. is-contr/is-contr-equiv (Path A x y) (Path Unit (Equiv/map A Unit e x) (Equiv/map A Unit e y))
                                (Equiv/Equiv-id A Unit e x y)
                                (Unit/id-is-contr (Equiv/map A Unit e x) (Equiv/map A Unit e y))

has-contr-eq/is-prop (A : U) (c : has-contr-eq A) : is-prop A =
  \ x y. (center (Path A x y) (c x y))

is-prop/is-subterminal (A : U) (p : is-prop A) (x : A) : is-subterminal A =
  is-proof-irrelevant/is-subterminal A x (is-prop/is-proof-irrelevant A p)

is-prop/has-contr-eq' (A : U) (p : is-prop A) (x : A) : has-contr-eq A =
  is-subterminal/has-contr-eq A (is-prop/is-subterminal A p x)

is-prop/has-contr-eq (A : U) (p : is-prop A) : has-contr-eq A =
  \ x y. (p x y,
         \ q. 
          let H : is-contr (Path A x y) = is-prop/has-contr-eq' A p x x y in
          comp (Path A x y) (p x y) (H.1) (inv (Path A x y) (H.1) (p x y) (H.2 (p x y)))
                            q (H.2 q))

is-proof-irrelevant/has-contr-eq (A : U) (x : A) (f : is-proof-irrelevant A) : has-contr-eq A =
  is-subterminal/has-contr-eq A (is-proof-irrelevant/is-subterminal A x f)

is-proof-irrelevant/is-prop (A : U) (x : A) (f : is-proof-irrelevant A) : is-prop A =
  has-contr-eq/is-prop A (is-proof-irrelevant/has-contr-eq A x f)

is-subterminal/is-prop (A : U) (e : is-subterminal A) : is-prop A =
  has-contr-eq/is-prop A (is-subterminal/has-contr-eq A e)

is-subterminal/is-proof-irrelevant (A : U) (e : is-subterminal A) : is-proof-irrelevant A =
  is-prop/is-proof-irrelevant A (is-subterminal/is-prop A e)

has-contr-eq/is-proof-irrelevant (A : U) (c : has-contr-eq A) : is-proof-irrelevant A =
  is-prop/is-proof-irrelevant A (has-contr-eq/is-prop A c)

has-contr-eq/is-subterminal (A : U) (x : A) (c : has-contr-eq A) : is-subterminal A =
  is-proof-irrelevant/is-subterminal A x (has-contr-eq/is-proof-irrelevant A c)

UU-Prop : U = Sg U is-prop

Prop/type (A : UU-Prop) : U = A.1

Prop/is-prop (A : UU-Prop) : is-prop (Prop/type A) = A.2  

Prop/hom (A B : UU-Prop) : U = (Prop/type A) -> (Prop/type B)

Prop/is-equiv (A B : UU-Prop) (f : Prop/hom A B) (g : Prop/hom B A) : is-equiv (Prop/type A) (Prop/type B) f =
  let H : Htpy' (Prop/type B) (Prop/type B) (\ z. f (g z)) (id (Prop/type B)) = \ x. Prop/is-prop B (f (g x)) x
      K : Htpy' (Prop/type A) (Prop/type A) (\ z. g (f z)) (id (Prop/type A)) = \ x. Prop/is-prop A (g (f x)) x
  in
  has-inverse/is-equiv (Prop/type A) (Prop/type B) f (g, (H, K))

Prop/Equiv (A B : UU-Prop) (f : Prop/hom A B) (g : Prop/hom B A) : Equiv (Prop/type A) (Prop/type B) =
  (f, Prop/is-equiv A B f g)

is-prop/prod (A B : U) (p : is-prop A) (q : is-prop B) : is-prop (A * B) =
  is-prop/sg A (\ _. B) p (\ _. q)
