module Lib.ContrMap where

import Lib.QInv
import Lib.Prop.BiInv
import Lib.Prop.Sg  
import Lib.Prop.ActionPaths
import Lib.Prop.MiscPaths
import Lib.Prop.Contr
import Lib.FunExt

is-equiv/is-bi-inv-inv-map (A B : U) (f : A -> B) (e : is-equiv A B f) : B -> A =
  \ y. let c : Fib A B f y = (e y).1 in c.1

is-equiv/is-bi-inv-inv-right-htpy (A B : U) (f : A -> B) (e : is-equiv A B f) (y : B)
                                       : Path B (f (is-equiv/is-bi-inv-inv-map A B f e y)) y =
  let c : Fib A B f y = (e y).1
      gx : A = (is-equiv/is-bi-inv-inv-map A B f e y)
  in (inv B y (f (gx)) c.2)

is-equiv/is-bi-inv-inv-left-htpy (A B : U) (f : A -> B) (e : is-equiv A B f) (x : A)
                                      : Path A ((is-equiv/is-bi-inv-inv-map A B f e) (f x)) x =
  let c : is-contr (Fib A B f (f x)) = (e (f x))
      g : B -> A = is-equiv/is-bi-inv-inv-map A B f e
      P : A -> U = \ x'. Path B (f (g (f x'))) (f x')
      p : Path B (f x) (f (g (f x))) = inv B (f (g (f x))) (f x) (is-equiv/is-bi-inv-inv-right-htpy A B f e (f x))
      fib : Fib A B f (f x) = (g (f x), p)
      fib' : Fib A B f (f x) = (x, refl B (f x))
      r : Path (Fib A B f (f x)) fib c.1 = (inv (Fib A B f (f x)) c.1 fib (c.2 fib))
      s : Path (Fib A B f (f x)) c.1 fib' = c.2 fib'
      q : Path (Fib A B f (f x)) fib fib' = (comp (Fib A B f (f x)) fib c.1 r fib' s)
  in ap (Fib A B f (f x)) A (\ u. u.1) fib fib' q

is-equiv/is-bi-inv (A B : U) (f : A -> B) (e : is-equiv A B f) : is-bi-inv A B f =
  has-inverse-is-bi-inv A B f
    (is-equiv/is-bi-inv-inv-map A B f e,
      (is-equiv/is-bi-inv-inv-right-htpy A B f e,
       is-equiv/is-bi-inv-inv-left-htpy A B f e))

is-bi-inv/is-equiv-comp-right-is-bi-inv (A B : U) (g : B -> A) (b : is-bi-inv B A g)
                                             : is-bi-inv A A (map/comp A B A g (is-bi-inv/right-inv B A g b)) =
  let f : A -> B = is-bi-inv/right-inv B A g b
      H : Htpy A (\ _. A) (map/comp A A A (map/comp A B A g f) (id A)) (id A) =
          is-bi-inv/right-htpy B A g b
      K : Htpy A (\ _. A) (map/comp A A A (id A) (map/comp A B A g f)) (id A) =
          is-bi-inv/right-htpy B A g b
  in ((id A, H), (id A, K))

is-bi-inv/is-equiv-comp-left-is-bi-inv (A B : U) (g : B -> A) (b : is-bi-inv B A g)
                                            : is-bi-inv B B (map/comp B A B (is-bi-inv/left-inv B A g b) g) =
  let h : A -> B = is-bi-inv/left-inv B A g b
      H : Htpy B (\ _. B) (map/comp B B B (map/comp B A B h g) (id B)) (id B) =
          is-bi-inv/left-htpy B A g b
      K : Htpy B (\ _. B) (map/comp B B B (id B) (map/comp B A B h g)) (id B) =
          is-bi-inv/left-htpy B A g b
  in ((id B, H), (id B, K))

-- is-bi-inv/is-equiv-ap-comp-right-is-ap-id (A B : U) (g : B -> A) (b : is-bi-inv B A g) (x y : A)
--                                                : Path (Path A x y) (ap A A (map/comp A B A g (is-bi-inv/right-inv B A g b)) x y) (ap A A (id A) x y) =
--   let f : (A -> B) = is-bi-inv/right-inv B A g b
--       H : Htpy' A A (map/comp A B A g f) (id A) = is-bi-inv/right-htpy B A g b
--   in ap (A -> A) (Path A x y) (\ h. ap A A h x y) (map/comp A B A g f) (id A) (eq-htpy A A (map/comp A B A g f) (id A) H)

-- is-bi-inv/is-equiv-ap-comp-right-is-bi-inv (A B : U) (g : B -> A) (b : is-bi-inv B A g) (x y : A)
--                                                 : is-bi-inv (ap A A (map/comp A B A g (is-bi-inv/right-inv B A g b)) x y) =
--   let f : A -> B = is-bi-inv/right-inv B A g b
--       H : Path A A (\ z. g (f z)) (id A) = eq-htpy A A (\ z. g (f z)) (id A) (is-bi-inv/right-htpy B A g b)
--       i : (Path A (g (f x)) (g (f y))) -> Path A x y = 
--   in
--   has-inverse-is-bi-inv (Path A x y) (Path A (g (f x)) (g (f y))) (ap A A (map/comp A B A g (is-bi-inv/right-inv B A g b)) x y)
--                         (

is-bi-inv/is-equiv-is-bi-inv-map-left (A B : U) (g : B -> A) (b : is-bi-inv B A g) : is-bi-inv A B (is-bi-inv/right-inv B A g b) =
  let f : A -> B = is-bi-inv/right-inv B A g b
      h : A -> B = is-bi-inv/left-inv  B A g b
  in is-bi-inv-comp/is-bi-inv-left-map A B A B f g h
        (is-bi-inv/is-equiv-comp-right-is-bi-inv A B g b)
        (is-bi-inv/is-equiv-comp-left-is-bi-inv A B g b)

is-bi-inv/is-equiv-has-inverse-ap-map-left (A B : U) (g : B -> A) (b : is-bi-inv B A g) (x y : A)
                                              : has-inverse (Path A x y) (Path B ((is-bi-inv/right-inv B A g b) x) ((is-bi-inv/right-inv B A g b) y)) (ap A B (is-bi-inv/right-inv B A g b) x y) =
  ap/closure-bi-inv-has-inv A B (is-bi-inv/right-inv B A g b) (is-bi-inv/is-equiv-is-bi-inv-map-left A B g b) x y

is-bi-inv/is-equiv-is-bi-inv-ap-map-left (A B : U) (g : B -> A) (b : is-bi-inv B A g) (x y : A)
                                              : is-bi-inv (Path A x y) (Path B ((is-bi-inv/right-inv B A g b) x) ((is-bi-inv/right-inv B A g b) y)) (ap A B (is-bi-inv/right-inv B A g b) x y) =
  ap/closure-bi-inv A B (is-bi-inv/right-inv B A g b) (is-bi-inv/is-equiv-is-bi-inv-map-left A B g b) x y

is-bi-inv/is-equiv-retr-total-space (A B : U) (g : B -> A) (b : is-bi-inv B A g) (x : A)
                                         : retract-of (Sg A (\ y. Path B (is-bi-inv/right-inv B A g b x) (is-bi-inv/right-inv B A g b y))) (Sg A (\ y. Path A x y)) =
  let f : A -> B = is-bi-inv/right-inv B A g b
      h-i : (y : A) -> has-inverse (Path A x y) (Path B (f x) (f y)) (ap A B f x y) = \ y. is-bi-inv/is-equiv-has-inverse-ap-map-left A B g b x y
      h : (y : A) -> Path B (f x) (f y) -> Path A x y = \ y. QInv/map (Path A x y) (Path B (f x) (f y)) (ap A B f x y) (h-i y)
      i : (Sg A (\ y. Path B (f x) (f y))) -> Sg A (\ y. Path A x y) = \ p. (p.1, h p.1 p.2)
      r : (Sg A (\ y. Path A x y)) -> Sg A (\ y. Path B (f x) (f y)) = \ p. (p.1, (ap A B f x p.1 p.2))
      htpy : (y : A) -> Htpy' (Path B (f x) (f y)) (Path B (f x) (f y)) (\ q. (ap A B f x y (h y q))) (id (Path B (f x) (f y))) =
                 \ y q. QInv/right-htpy (Path A x y) (Path B (f x) (f y)) (ap A B f x y) (h-i y) q
  in (i, (r, \ q. SgPathO->PathSg A (\ y. Path B (f x) (f y)) (r (i q)) q
                                   (refl A q.1, PathO/refl A q.1 (\ y. Path B (f x) (f y)) (r (i q)).2 q.2 (htpy q.1 q.2))))

is-bi-inv/is-equiv-is-contr-total-space (A B : U) (g : B -> A) (b : is-bi-inv B A g) (x : A) : is-contr (Sg A (\ y. Path B (is-bi-inv/right-inv B A g b x) (is-bi-inv/right-inv B A g b y))) =
  let A' : U = (Sg A (\ y. Path B (is-bi-inv/right-inv B A g b x) (is-bi-inv/right-inv B A g b y)))
      B' : U = (Sg A (\ y. Path A x y))
  in
  is-contr/closed-retract A' B' (is-bi-inv/is-equiv-retr-total-space A B g b x) (is-contr/Sg-path-is-contr A x)

is-bi-inv/is-equiv-is-bi-inv-total-space-map (A B : U) (g : B -> A) (b : is-bi-inv B A g) (y : B)
                                                  : Sg A (\ x. Path B (is-bi-inv/right-inv B A g b (g y)) (is-bi-inv/right-inv B A g b x)) -> Sg A (\ x. Path B y (is-bi-inv/right-inv B A g b x)) =
  let f : A -> B = is-bi-inv/right-inv B A g b
      L : Htpy' B B (\ z. f (g z)) (id B) = is-bi-inv/inv-left-htpy B A g b
  in
  \ p. (p.1, comp B y (f (g y)) (inv B (f (g y)) y (L y)) (f p.1) p.2)

is-bi-inv/is-equiv-is-bi-inv-total-space-invmap (A B : U) (g : B -> A) (b : is-bi-inv B A g) (y : B)
                                                     : Sg A (\ x. Path B y (is-bi-inv/right-inv B A g b x)) -> Sg A (\ x. Path B (is-bi-inv/right-inv B A g b (g y)) (is-bi-inv/right-inv B A g b x)) =
  let f : A -> B = is-bi-inv/right-inv B A g b
      L : Htpy' B B (\ z. f (g z)) (id B) = is-bi-inv/inv-left-htpy B A g b
  in
  \ p. (p.1, comp B (f (g y)) y (L y) (f p.1) p.2)

is-bi-inv/is-equiv-is-bi-inv-total-space-left-htpy (A B : U) (g : B -> A) (b : is-bi-inv B A g) (y : B)
                                                        : Htpy' (Sg A (\ x. Path B (is-bi-inv/right-inv B A g b (g y)) (is-bi-inv/right-inv B A g b x)))
                                                                (Sg A (\ x. Path B (is-bi-inv/right-inv B A g b (g y)) (is-bi-inv/right-inv B A g b x)))
                                                                (\ z. (is-bi-inv/is-equiv-is-bi-inv-total-space-invmap A B g b y) (is-bi-inv/is-equiv-is-bi-inv-total-space-map A B g b y z))
                                                                (id (Sg A (\ x. Path B (is-bi-inv/right-inv B A g b (g y)) (is-bi-inv/right-inv B A g b x)))) =
  \ pair.
    let f : A -> B = is-bi-inv/right-inv B A g b
        L : Htpy' B B (\ z. f (g z)) (id B) = is-bi-inv/inv-left-htpy B A g b
        h : Sg A (\ x. Path B (f (g y)) (f x)) -> Sg A (\ x. Path B y (f x)) = is-bi-inv/is-equiv-is-bi-inv-total-space-map A B g b y                   
        i : Sg A (\ x. Path B y (f x)) -> Sg A (\ x. Path B (f (g y)) (f x)) = is-bi-inv/is-equiv-is-bi-inv-total-space-invmap A B g b y
        x : A = pair.1
        p : Path B (f (g y)) (f x) = pair.2
        q : Path (Path B (f (g y)) (f x)) (i (h pair)).2 p
                 = comp-n (Path B (f (g y)) (f x)) three-Nat (i (h pair)).2
                                                             (comp B (f (g y)) (f (g y)) (comp B (f (g y)) y (L y) (f (g y)) (inv B (f (g y)) y (L y))) (f x) p)
                                                             (comp/assoc' B (f (g y)) y (L y) (f (g y)) (inv B (f (g y)) y (L y)) (f x) p)
                                                             (comp B (f (g y)) (f (g y)) (refl B (f (g y))) (f x) p)
                                                             (ap (Path B (f (g y)) (f (g y))) (Path B (f (g y)) (f x)) (\ r. comp B (f (g y)) (f (g y)) r (f x) p)
                                                                 (comp B (f (g y)) y (L y) (f (g y)) (inv B (f (g y)) y (L y))) (refl B (f (g y)))
                                                                 (comp/inv-r B (f (g y)) y (L y)))
                                                             p (comp/ident-l B (f (g y)) (f x) p)
    in SgPathO->PathSg A (\ z. Path B (f (g y)) (f z)) (i (h pair)) (x, p) (refl A x, PathO/refl A x (\ z. Path B (f (g y)) (f z)) (i (h pair)).2 p q)

is-bi-inv/is-equiv-is-bi-inv-total-space-right-htpy (A B : U) (g : B -> A) (b : is-bi-inv B A g) (y : B)
                                                         : Htpy' (Sg A (\ x. Path B y (is-bi-inv/right-inv B A g b x)))
                                                                 (Sg A (\ x. Path B y (is-bi-inv/right-inv B A g b x)))
                                                                 (\ z. (is-bi-inv/is-equiv-is-bi-inv-total-space-map A B g b y) (is-bi-inv/is-equiv-is-bi-inv-total-space-invmap A B g b y z))
                                                                 (id (Sg A (\ x. Path B y (is-bi-inv/right-inv B A g b x)))) =
  \ pair.
    let f : A -> B = is-bi-inv/right-inv B A g b
        L : Htpy' B B (\ z. f (g z)) (id B) = is-bi-inv/inv-left-htpy B A g b
        h : Sg A (\ x. Path B (f (g y)) (f x)) -> Sg A (\ x. Path B y (f x)) = is-bi-inv/is-equiv-is-bi-inv-total-space-map A B g b y                   
        i : Sg A (\ x. Path B y (f x)) -> Sg A (\ x. Path B (f (g y)) (f x)) = is-bi-inv/is-equiv-is-bi-inv-total-space-invmap A B g b y
        x : A = pair.1
        p : Path B y (f x) = pair.2
        q : Path (Path B y (f x)) (h (i pair)).2 p
                 = comp-n (Path B y (f x)) three-Nat (h (i pair)).2
                                                     (comp B y y (comp B y (f (g y)) (inv B (f (g y)) y (L y)) y (L y)) (f x) p)
                                                     (comp/assoc' B y (f (g y)) (inv B (f (g y)) y (L y)) y (L y) (f x) p)
                                                     (comp B y y (refl B y) (f x) p)
                                                     (ap (Path B y y) (Path B y (f x)) (\ r. comp B y y r (f x) p)
                                                         (comp B y (f (g y)) (inv B (f (g y)) y (L y)) y (L y)) (refl B y)
                                                         (comp/inv-l B (f (g y)) y (L y)))
                                                     p (comp/ident-l B y (f x) p)
    in SgPathO->PathSg A (\ z. Path B y (f z)) (h (i pair)) (x, p) (refl A x, PathO/refl A x (\ z. Path B y (f z)) (h (i pair)).2 p q)

is-bi-inv/is-equiv-is-bi-inv-total-space (A B : U) (g : B -> A) (b : is-bi-inv B A g) (y : B)
                                              : is-bi-inv (Fib A B (is-bi-inv/right-inv B A g b) (is-bi-inv/right-inv B A g b (g y)))
                                                          (Fib A B (is-bi-inv/right-inv B A g b) y)
                                                          (is-bi-inv/is-equiv-is-bi-inv-total-space-map A B g b y) =
  ((is-bi-inv/is-equiv-is-bi-inv-total-space-invmap A B g b y, is-bi-inv/is-equiv-is-bi-inv-total-space-right-htpy A B g b y),
   (is-bi-inv/is-equiv-is-bi-inv-total-space-invmap A B g b y, is-bi-inv/is-equiv-is-bi-inv-total-space-left-htpy A B g b y))

is-bi-inv/is-equiv-is-bi-inv-total-space' (A B : U) (g : B -> A) (b : is-bi-inv B A g) (y : B)
                                               : is-bi-inv (Fib A B (is-bi-inv/right-inv B A g b) y)
                                                           (Fib A B (is-bi-inv/right-inv B A g b) (is-bi-inv/right-inv B A g b (g y)))
                                                           (is-bi-inv/is-equiv-is-bi-inv-total-space-invmap A B g b y) =
  ((is-bi-inv/is-equiv-is-bi-inv-total-space-map A B g b y, is-bi-inv/is-equiv-is-bi-inv-total-space-left-htpy A B g b y),
   (is-bi-inv/is-equiv-is-bi-inv-total-space-map A B g b y, is-bi-inv/is-equiv-is-bi-inv-total-space-right-htpy A B g b y))

is-bi-inv/is-equiv-is-equiv-left-map (A B : U) (g : B -> A) (b : is-bi-inv B A g) : is-equiv A B (is-bi-inv/right-inv B A g b) =
  let f : A -> B = is-bi-inv/right-inv B A g b
  in
  \ y. is-bi-inv/is-contr-is-bi-inv (Fib A B f y) (Fib A B f (f (g y)))
                                   (is-bi-inv/is-equiv-is-bi-inv-total-space-invmap A B g b y)
                                   (is-bi-inv/is-equiv-is-bi-inv-total-space' A B g b y)
                                   (is-bi-inv/is-equiv-is-contr-total-space A B g b (g y))

is-bi-inv/is-equiv-map (A B : U) (g : B -> A) (b : is-bi-inv B A g) : is-equiv B A g =
  let f : A -> B = is-bi-inv/right-inv B A g b
      i : has-inverse A B f = (g, (is-bi-inv/inv-left-htpy B A g b, is-bi-inv/inv-right-htpy B A g b))
      b' : is-bi-inv A B f = has-inverse-is-bi-inv A B f i
  in is-bi-inv/is-equiv-is-equiv-left-map B A f b'

is-bi-inv/is-equiv (A B : U) (f : A -> B) (b : is-bi-inv A B f) : is-equiv A B f =
  is-bi-inv/is-equiv-map B A f b

is-bi-inv/Equiv (A B : U) (f : A -> B) (b : is-bi-inv A B f) : Equiv A B =
  (f, is-bi-inv/is-equiv A B f b)
