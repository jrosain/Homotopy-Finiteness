module Lib.Groups where

import Stdlib.Prelude
import Lib.Prop.Set
import Lib.Prop.Proposition

is-assoc (X : U) (f : X -> X -> X) : U =
  (x y z : X) -> Path X (f (f x y) z) (f x (f y z))

has-assoc-op (X : U) : U =
  Sg (X -> X -> X) (is-assoc X)

is-semi-group (X : UU-Set) : U =
  has-assoc-op (Set/type X)

Semi-Group : U = Sg UU-Set is-semi-group

Semi-Group/Set (G : Semi-Group) : UU-Set = G.1

Semi-Group/is-semi-group (G : Semi-Group) : is-semi-group (Semi-Group/Set G) = G.2  

Semi-Group/type (G : Semi-Group) : U = Set/type (Semi-Group/Set G)

Semi-Group/is-set (G : Semi-Group) : is-set (Semi-Group/type G) = (Semi-Group/Set G).2

Semi-Group/op (G : Semi-Group) : (Semi-Group/type G) -> (Semi-Group/type G) -> (Semi-Group/type G) =
  (Semi-Group/is-semi-group G).1

Semi-Group/is-assoc (G : Semi-Group) : is-assoc (Semi-Group/type G) (Semi-Group/op G) =
  (Semi-Group/is-semi-group G).2

Semi-Group/hom (G : Semi-Group) (H : Semi-Group) : U =
  Semi-Group/type G -> Semi-Group/type H

left-unit-law (G : Semi-Group) (e : Semi-Group/type G) : U =
  (y : Semi-Group/type G) -> Path (Semi-Group/type G) (Semi-Group/op G e y) y

right-unit-law (G : Semi-Group) (e : Semi-Group/type G) : U =
  (x : Semi-Group/type G) -> Path (Semi-Group/type G) (Semi-Group/op G x e) x

is-unital (G : Semi-Group) : U =
  Sg (Semi-Group/type G) (\ e. (left-unit-law G e) * (right-unit-law G e))

Monoid : U = Sg Semi-Group is-unital

Monoid/Semi-Group (M : Monoid) : Semi-Group = M.1

Monoid/is-unital (M : Monoid) : is-unital (Monoid/Semi-Group M) = M.2  

Monoid/Set (M : Monoid) : UU-Set = Semi-Group/Set (Monoid/Semi-Group M)

Monoid/is-semi-group (M : Monoid) : is-semi-group (Monoid/Set M) = Semi-Group/is-semi-group (Monoid/Semi-Group M)

Monoid/type (M : Monoid) : U = Set/type (Monoid/Set M)

Monoid/is-set (M : Monoid) : is-set (Monoid/type M) = Set/is-set (Monoid/Set M)

Monoid/op (M : Monoid) : (Monoid/type M) -> (Monoid/type M) -> (Monoid/type M) =
  (Semi-Group/op (Monoid/Semi-Group M))

Monoid/is-assoc (M : Monoid) : is-assoc (Monoid/type M) (Monoid/op M) =
  (Semi-Group/is-assoc (Monoid/Semi-Group M))

Monoid/unit (M : Monoid) : (Monoid/type M) = (Monoid/is-unital M).1

Monoid/left-unit-law (M : Monoid) : left-unit-law (Monoid/Semi-Group M) (Monoid/unit M) = (Monoid/is-unital M).2.1

Monoid/right-unit-law (M : Monoid) : right-unit-law (Monoid/Semi-Group M) (Monoid/unit M) = (Monoid/is-unital M).2.2

is-unital/is-prop/sg (X : U) (is-set-X : is-set X) (f : X -> X -> X) (assoc-f : (x y z : X) -> Path X (f (f x y) z) (f x (f y z)))
                     (e : X) (left-unit : left-unit-law ((X, is-set-X), (f, assoc-f)) e) (right-unit : right-unit-law ((X, is-set-X), (f, assoc-f)) e)
                     (e' : X) (left-unit' : left-unit-law ((X, is-set-X), (f, assoc-f)) e') (right-unit' : right-unit-law ((X, is-set-X), (f, assoc-f)) e') 
                         : Path (is-unital ((X, is-set-X), (f, assoc-f))) (e, (left-unit, right-unit)) (e', (left-unit', right-unit')) =
  let G : Semi-Group = ((X, is-set-X), (f, assoc-f)) in
  SgPath-prop X (\ z. (left-unit-law G z) * (right-unit-law G z))
    (\ z. is-prop/prod (left-unit-law G z) (right-unit-law G z)
          (is-prop/pi X (\ y. Path X (f z y) y) (\ y. is-set-X (f z y) y))
          (is-prop/pi X (\ x. Path X (f x z) x) (\ x. is-set-X (f x z) x)))
    (e, (left-unit, right-unit)) (e', (left-unit', right-unit'))
    (comp X e (f e e') (inv X (f e e') e (right-unit' e)) e' (left-unit e'))

is-unital/is-prop (G : Semi-Group) : is-prop (is-unital G) =
  \ x y. is-unital/is-prop/sg (Semi-Group/type G) (Set/is-set (Semi-Group/Set G)) (Semi-Group/op G) (Semi-Group/is-assoc G)
          x.1 x.2.1 x.2.2 y.1 y.2.1 y.2.2

is-invertible-Monoid (M : Monoid) (x : Monoid/type M) : U =
  Sg (Monoid/type M) (\ y. (Path (Monoid/type M) (Monoid/op M y x) (Monoid/unit M)) * (Path (Monoid/type M) (Monoid/op M x y) (Monoid/unit M)))

is-invertible-Monoid/is-prop/sg (M : Monoid) (x : Monoid/type M) (y : Monoid/type M) (p : Path (Monoid/type M) (Monoid/op M y x) (Monoid/unit M))
                                (q : Path (Monoid/type M) (Monoid/op M x y) (Monoid/unit M)) (y' : Monoid/type M)
                                (p' : Path (Monoid/type M) (Monoid/op M y' x) (Monoid/unit M)) (q' : Path (Monoid/type M) (Monoid/op M x y') (Monoid/unit M))
                                    : Path (is-invertible-Monoid M x) (y, (p, q)) (y', (p', q')) =
  let X : U = Monoid/type M
      f : X -> X -> X = Monoid/op M
      e : X = Monoid/unit M
  in
  SgPath-prop X (\ z. (Path X (f z x) e) * (Path X (f x z) e))
    (\ z. is-prop/prod (Path X (f z x) e) (Path X (f x z) e)
          (Monoid/is-set M (f z x) e)
          (Monoid/is-set M (f x z) e))
    (y, (p, q)) (y', (p', q'))
    (comp-n X five-Nat y (f e y)
      (inv X (f e y) y (Monoid/left-unit-law M y))
      (f (f y' x) y) (ap X X (\ z. f z y) e (f y' x) (inv X (f y' x) e p'))
      (f y' (f x y)) (Monoid/is-assoc M y' x y)
      (f y' e) (ap X X (f y') (f x y) e q)
      y' (Monoid/right-unit-law M y'))

is-invertible-Monoid/is-prop (M : Monoid) (x : Monoid/type M) : is-prop (is-invertible-Monoid M x) =
  \ y z. is-invertible-Monoid/is-prop/sg M x y.1 y.2.1 y.2.2 z.1 z.2.1 z.2.2

left-inv  (M : Monoid) (x y : Monoid/type M) : U = Path (Monoid/type M) (Monoid/op M y x) (Monoid/unit M)
right-inv (M : Monoid) (x y : Monoid/type M) : U = Path (Monoid/type M) (Monoid/op M x y) (Monoid/unit M)

is-group' (G : Semi-Group) (e : is-unital G) : U =
  Sg (Semi-Group/hom G G) (\ i. ((x : Semi-Group/type G) -> left-inv (G, e) x (i x)) * ((x : Semi-Group/type G) -> right-inv (G, e) x (i x)))

is-group (G : Semi-Group) : U = Sg (is-unital G) (is-group' G)

Group : U = Sg Semi-Group is-group

Group/Semi-Group (G : Group) : Semi-Group = G.1

Group/is-group (G : Group) : is-group (Group/Semi-Group G) = G.2

Group/Set (G : Group) : UU-Set = Semi-Group/Set (Group/Semi-Group G)

Group/type (G : Group) : U = Semi-Group/type (Group/Semi-Group G)

Group/is-set (G : Group) : is-set (Group/type G) = (Group/Set G).2

Group/is-unital (G : Group) : is-unital (Group/Semi-Group G) = (Group/is-group G).1

Group/Monoid (G : Group) : Monoid = (Group/Semi-Group G, Group/is-unital G)

Group/is-semi-group (G : Group) : is-semi-group (Group/Set G) = Monoid/is-semi-group (Group/Monoid G)

Group/op (G : Group) : (Group/type G) -> (Group/type G) -> (Group/type G) = Semi-Group/op (Group/Semi-Group G)

Group/is-assoc (G : Group) : is-assoc (Group/type G) (Group/op G) = Semi-Group/is-assoc (Group/Semi-Group G)

Group/hom (G H : Group) : U =
  Group/type G -> Group/type H

Group/unit (G : Group) : Group/type G = Monoid/unit (Group/Monoid G)

Group/left-unit-law (G : Group) : left-unit-law (Group/Semi-Group G) (Group/unit G) =
  Monoid/left-unit-law (Group/Monoid G)

Group/right-unit-law (G : Group) : right-unit-law (Group/Semi-Group G) (Group/unit G) =
  Monoid/right-unit-law (Group/Monoid G)

Group/inv (G : Group) : Group/hom G G = (Group/is-group G).2.1

Group/left-inv (G : Group) : (x : Group/type G) -> left-inv (Group/Monoid G) x (Group/inv G x) =
  (Group/is-group G).2.2.1

Group/right-inv (G : Group) : (x : Group/type G) -> right-inv (Group/Monoid G) x (Group/inv G x) =
  (Group/is-group G).2.2.2

is-group'/is-prop/sg (G : Semi-Group) (e : Semi-Group/type G) (left-unit : left-unit-law G e) (right-unit : right-unit-law G e)
                    (i : Semi-Group/hom G G) (left-inv-i : (x : Semi-Group/type G) -> left-inv (G, (e, (left-unit, right-unit))) x (i x))
                                             (right-inv-i : (x : Semi-Group/type G) -> right-inv (G, (e, (left-unit, right-unit))) x (i x))
                    (i' : Semi-Group/hom G G) (left-inv-i' : (x : Semi-Group/type G) -> left-inv (G, (e, (left-unit, right-unit))) x (i' x))
                                             (right-inv-i' : (x : Semi-Group/type G) -> right-inv (G, (e, (left-unit, right-unit))) x (i' x))
                        : Path (is-group' G (e, (left-unit, right-unit))) (i, (left-inv-i, right-inv-i)) (i', (left-inv-i', right-inv-i')) =
  let X : U = Semi-Group/type G
      f : X -> X -> X = Semi-Group/op G
  in
  SgPath-prop (X -> X) (\ g. ((x : X) -> Path X (f (g x) x) e) * ((x : X) -> Path X (f x (g x)) e))
    (\ g. is-prop/prod ((x : X) -> Path X (f (g x) x) e) ((x : X) -> Path X (f x (g x)) e)
      (is-prop/pi X (\ x. Path X (f (g x) x) e) (\ x. Semi-Group/is-set G (f (g x) x) e))
      (is-prop/pi X (\ x. Path X (f x (g x)) e) (\ x. Semi-Group/is-set G (f x (g x)) e)))
    (i, (left-inv-i, right-inv-i)) (i', (left-inv-i', right-inv-i'))
    (eq-htpy X X i i'
      (\ x. 
        (comp-n X five-Nat (i x) (f e (i x))
          (inv X (f e (i x)) (i x) (left-unit (i x)))
          (f (f (i' x) x) (i x)) (ap X X (\ z. f z (i x)) e (f (i' x) x) (inv X (f (i' x) x) e (left-inv-i' x)))
          (f (i' x) (f x (i x))) (Semi-Group/is-assoc G (i' x) x (i x))
          (f (i' x) e) (ap X X (f (i' x)) (f x (i x)) e (right-inv-i x))
          (i' x) (right-unit (i' x)))))


is-group'/is-prop (G : Semi-Group) (e : is-unital G) : is-prop (is-group' G e) =
  \ x y. is-group'/is-prop/sg G e.1 e.2.1 e.2.2 x.1 x.2.1 x.2.2 y.1 y.2.1 y.2.2

is-group/is-prop (G : Semi-Group) : is-prop (is-group G) =
  is-prop/sg (is-unital G) (is-group' G) (is-unital/is-prop G) (is-group'/is-prop G)
