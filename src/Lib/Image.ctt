module Lib.Image where

import Stdlib.Prelude
import Lib.PropTrunc
import Lib.Prop.Levels

im (A X : U) (f : A -> X) : U =
  Sg X (\ x. Prop-trunc (Fib A X f x))

im/inclusion (A X : U) (f : A -> X) : im A X f -> X =
  \ t. t.1

im/q (A X : U) (f : A -> X) : A -> im A X f =
  \ x. (f x, Prop-trunc/unit (x, refl X (f x)))

im/htpy (A X : U) (f : A -> X) : Htpy' A X (\ x. im/inclusion A X f (im/q A X f x)) f =
  \ x. refl X (f x)

im/htpy' (A X : U) (f : A -> X) : Htpy' A X f (\ x. im/inclusion A X f (im/q A X f x)) =
  \ x. refl X (f x)

im/is-injective (A X : U) (f : A -> X) (t u : im A X f) (p : Path X (im/inclusion A X f t) (im/inclusion A X f u)) : Path (im A X f) t u =
  SgPath-prop X
    ( \ x. Prop-trunc (Fib A X f x))
    ( \ x. Prop-trunc/is-prop (Fib A X f x))
    t u p

im/Set (A : U) (X : UU-Set) (f : A -> Set/type X) : UU-Set =
  Set/closed-Sg X
    ( \ x. Prop/Set (Prop-trunc/Prop (Fib A (Set/type X) f x)))

im/is-set (A : U) (X : UU-Set) (f : A -> Set/type X) : is-set (im A (Set/type X) f) =
  Set/is-set
    ( im/Set A X f)

is-surj (A B : U) (f : A -> B) : U =
  (b : B) -> Prop-trunc (Fib A B f b)

is-surj/is-prop (A B : U) (f : A -> B) : is-prop (is-surj A B f) =
  is-prop/pi B
    ( \ b. Prop-trunc (Fib A B f b))
    ( \ b. Prop-trunc/is-prop (Fib A B f b))

is-surj/Prop (A B : U) (f : A -> B) : UU-Prop =
  ( is-surj A B f,
    is-surj/is-prop A B f)
