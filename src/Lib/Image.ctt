module Lib.Image where

import Stdlib.Prelude
import Lib.PropTrunc
import Lib.Prop.Levels
import Lib.Prop.Equiv

im (A X : U) (f : A -> X) : U =
  Sg X (\ x. Prop-trunc (Fib A X f x))

im/inclusion (A X : U) (f : A -> X) : im A X f -> X =
  \ t. t.1

im/q (A X : U) (f : A -> X) : A -> im A X f =
  \ x. (f x, Prop-trunc/unit (x, refl X (f x)))

im/htpy (A X : U) (f : A -> X) : Htpy' A X (\ x. im/inclusion A X f (im/q A X f x)) f =
  \ x. refl X (f x)

im/htpy' (A X : U) (f : A -> X) : Htpy' A X f (\ x. im/inclusion A X f (im/q A X f x)) =
  \ x. refl X (f x)

im/is-injective (A X : U) (f : A -> X) (t u : im A X f) (p : Path X (im/inclusion A X f t) (im/inclusion A X f u)) : Path (im A X f) t u =
  SgPath-prop X
    ( \ x. Prop-trunc (Fib A X f x))
    ( \ x. Prop-trunc/is-prop (Fib A X f x))
    t u p

im/Set (A : U) (X : UU-Set) (f : A -> Set/type X) : UU-Set =
  Set/closed-Sg X
    ( \ x. Prop/Set (Prop-trunc/Prop (Fib A (Set/type X) f x)))

im/is-set (A : U) (X : UU-Set) (f : A -> Set/type X) : is-set (im A (Set/type X) f) =
  Set/is-set
    ( im/Set A X f)

is-surj (A B : U) (f : A -> B) : U =
  (b : B) -> Prop-trunc (Fib A B f b)

is-surj/is-prop (A B : U) (f : A -> B) : is-prop (is-surj A B f) =
  is-prop/pi B
    ( \ b. Prop-trunc (Fib A B f b))
    ( \ b. Prop-trunc/is-prop (Fib A B f b))

is-surj/Prop (A B : U) (f : A -> B) : UU-Prop =
  ( is-surj A B f,
    is-surj/is-prop A B f)

im/q/is-surj (A X : U) (f : A -> X) : is-surj A (im A X f) (im/q A X f) =
  \ t.
    rec-Prop-trunc
      ( Fib A X f t.1)
      ( Prop-trunc/Prop (Fib A (im A X f) (im/q A X f) t))
      ( \ u.
	Prop-trunc/unit
	( u.1,
	  SgPath-prop X
	    ( \ z. Prop-trunc (Fib A X f z))
	    ( \ z. Prop-trunc/is-prop (Fib A X f z)) t
	    ( im/q A X f u.1)
	    ( u.2))) t.2

is-surj/comp (A B C : U) (g : B -> C) (is-surj-g : is-surj B C g) (f : A -> B) (is-surj-f : is-surj A B f)
		    : is-surj A C (\ x. g (f x)) =
  \ c.
    rec-Prop-trunc
    ( Fib B C g c)
    ( Prop-trunc/Prop (Fib A C (\ x. g (f x)) c))
    ( \ t. rec-Prop-trunc
	  ( Fib A B f t.1)
	  ( Prop-trunc/Prop (Fib A C (\ x. g (f x)) c))
	  ( \ u.
	      Prop-trunc/unit
	      ( u.1,
		comp C c
		( g t.1) t.2
		( g (f u.1))
		( ap B C g t.1 (f u.1) u.2))) (is-surj-f t.1))
    ( is-surj-g c)

is-inj-is-surj/is-equiv (A B : U) (is-set-B : is-set B) (f : A -> B) (is-surj-f : is-surj A B f) (is-inj-f : (x y : A) -> Path B (f x) (f y) -> Path A x y)
			     : is-equiv A B f =
  \ y.
    rec-Prop-trunc
    ( Fib A B f y)
    ( is-contr (Fib A B f y),
      is-contr/is-prop (Fib A B f y))
    ( \ v.
      let p : is-prop (Fib A B f y) =
      ( \ t u.
	SgPath-prop A
	( \ x. Path B y (f x))
	( \ x. is-set-B y (f x)) t u
	( is-inj-f t.1 u.1
	( comp B (f t.1) y
	  ( inv B y (f t.1) t.2)
	  ( f u.1) u.2))) in
	( v, p v))
    ( is-surj-f y)
