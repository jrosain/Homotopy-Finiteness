#+NAME: Set Quotients
#+AUTHOR: Johann Rosain

* Set quotients

  #+begin_src ctt
  module Lib.SetQuotients where
  #+end_src

This file contains the definition and properties of set quotients as an Higher Inductive Type (see the HoTT book, section 6.10).

** Packages imports

   #+begin_src ctt
  import Lib.Prop.Set
  import Lib.Prop.Levels
  import Lib.EquivalenceRelations
  import Lib.Image
   #+end_src

** Specification
For any set =B=, a map is a set quotient whenever precomposing with the quotient yields an equivalence: (A \to B) \simeq (\Sigma_{f: A \to B}\Pi_{x,y: A}R(a, b) \to f(a) = f(b)).
#+begin_src ctt
  precomp-Set-quotient (A : U) (R : Eq-Rel A) (B X : UU-Set) (f : reflecting-map-Eq-Rel A R (Set/type B)) (g : Set/hom B X)
                          : reflecting-map-Eq-Rel A R (Set/type X) =
    ( \ x. g (reflecting-map-Eq-Rel/map A R (Set/type B) f x),
      \ x y r. ap ( Set/type B)
                 ( Set/type X) g
                 ( reflecting-map-Eq-Rel/map A R (Set/type B) f x)
                 ( reflecting-map-Eq-Rel/map A R (Set/type B) f y)
                 ( reflecting-map-Eq-Rel/reflects-Eq A R (Set/type B) f x y r))
#+end_src
A map is a set quotient whenever its precomposition is an equivalence.
#+begin_src ctt
  is-set-quotient (A : U) (R : Eq-Rel A) (B : UU-Set) (f : reflecting-map-Eq-Rel A R (Set/type B)) : U =
    (X : UU-Set) -> is-equiv (Set/hom B X) (reflecting-map-Eq-Rel A R (Set/type X)) (precomp-Set-quotient A R B X f)
#+end_src

** Definition
A set quotient is a type, quotiented by a relation R (that is, if R(a, b) then q(a) = q(b)) such that the final type is a set.
   #+begin_src ctt
  data Set-quotient (A : U) (R : Eq-Rel A) : U
    = Set-quotient/q (a : A)
    | Set-quotient/eq (a b : A) (r : Eq-Rel/type A R a b) <i> [(i=0) -> Set-quotient/q a, (i=1) -> Set-quotient/q b]
    | Set-quotient/squash (x y : Set-quotient A R) (p q : Path (Set-quotient A R) x y) <i j> [(i=0) -> p j, (i=1) -> q j, (j=0) -> x, (j=1) -> y]
   #+end_src

As expected, quotienting respects the equivalence relation.
#+begin_src ctt
  Set-quotient/respects-relation (A : U) (R : Eq-Rel A) (x y : A) : Eq-Rel/type A R x y -> Path (Set-quotient A R) (Set-quotient/q x) (Set-quotient/q y) =
    \ r i. Set-quotient/eq x y r i
#+end_src
And it is a set.
#+begin_src ctt
  Set-quotient/is-set (A : U) (R : Eq-Rel A) : is-set (Set-quotient A R) =
    \ x y p q i j. Set-quotient/squash x y p q i j

  Set-quotient/Set (A : U) (R : Eq-Rel A) : UU-Set =
    ( Set-quotient A R,
      Set-quotient/is-set A R)
#+end_src

** Induction principle
Of course, it has an induction principle.
#+begin_src ctt
  ind-Set-quotient (A : U) (R : Eq-Rel A) (P : Set-quotient A R -> UU-Set) (f : (x : A) -> Set/type (P (Set-quotient/q x)))
                   (feq : (x y : A) -> (r : Eq-Rel/type A R x y) -> PathP (i. Set/type (P (Set-quotient/eq x y r i))) (f x) (f y)) : (x : Set-quotient A R) -> Set/type (P x) = split
    Set-quotient/q a -> f a
    Set-quotient/eq x y r i -> feq x y r i
    Set-quotient/squash x y p q i j ->
      square/dependent-fill
        ( Set-quotient A R) P x y p q
        ( \ i' j'. Set-quotient/squash x y p q i' j')
        ( ind-Set-quotient A R P f feq x)
        ( ind-Set-quotient A R P f feq y)
        ( \ k. ind-Set-quotient A R P f feq (p k))
        ( \ k. ind-Set-quotient A R P f feq (q k)) i j
#+end_src
And a recursion principle.
#+begin_src ctt
  rec-Set-quotient (A : U) (R : Eq-Rel A) (B : UU-Set) (f : A -> Set/type B) (feq : (x y : A) -> Eq-Rel/type A R x y -> Path (Set/type B) (f x) (f y))
                      : (x : Set-quotient A R) -> Set/type B =
    ind-Set-quotient A R
      ( \ _. B) f feq
#+end_src

** Using propositions
There's a (slightly simpler) induction principle if the goal is a proposition.
#+begin_src ctt
  PathO-to-PathP (A : U) (x y : A) (p : Path A x y) (B : A -> U) (u : B x) (v : B y) : (PathO A x y p B u v) -> PathP (i. B (p i)) u v =
    Equiv/inv-map 
      ( PathP (i. B (p i)) u v)
      ( PathO A x y p B u v)
      ( path-to-equiv
        ( PathP (i. B (p i)) u v)
        ( PathO A x y p B u v)
        ( PathP-eq-PathO A x y p B u v))

  ind-Set-quotient/Prop (A : U) (R : Eq-Rel A) (P : Set-quotient A R -> UU-Prop) (f : (x : A) -> Prop/type (P (Set-quotient/q x)))
                           : (x : Set-quotient A R) -> Prop/type (P x) = split
    Set-quotient/q a -> f a
    Set-quotient/eq x y r i ->
      PathO-to-PathP
        ( Set-quotient A R)
        ( Set-quotient/q x)
        ( Set-quotient/q y)
        ( Set-quotient/respects-relation A R x y r)
        ( \ z. Prop/type (P z))
        ( f x)
        ( f y)
        ( Prop/is-prop
          ( P (Set-quotient/q y))
          ( tr (Set-quotient A R) (Set-quotient/q x) (Set-quotient/q y) (Set-quotient/respects-relation A R x y r) (\ z. Prop/type (P z)) (f x))
          ( f y)) i
    Set-quotient/squash x y p q i j ->
      square/dependent-fill
        ( Set-quotient A R)
        ( \ z. Prop/Set (P z)) x y p q
        ( \ i' j'. Set-quotient/squash x y p q i' j')
        ( ind-Set-quotient/Prop A R P f x)
        ( ind-Set-quotient/Prop A R P f y)
        ( \ k. ind-Set-quotient/Prop A R P f (p k))
        ( \ k. ind-Set-quotient/Prop A R P f (q k)) i j
#+end_src
And thus, there's also a slightly simpler recursor.
#+begin_src ctt
  rec-Set-quotient/Prop (A : U) (R : Eq-Rel A) (B : UU-Prop) (f : A -> Prop/type B)
                           : (x : Set-quotient A R) -> Prop/type B =
    ind-Set-quotient/Prop A R (\ _. B) f
#+end_src

** Proposition of equality between elements of set 
   #+begin_src ctt
  Set/eq/Prop (X : UU-Set) (x y : Set/type X) : UU-Prop =
    ( Path (Set/type X) x y,
      Set/is-set X x y)
   #+end_src

** Surjectivity
The quotient of a type by an equivalence relation is obviously surjective.
#+begin_src ctt
  quotienting-is-surj (A : U) (R : Eq-Rel A) : is-surj A (Set-quotient A R) (\ a. Set-quotient/q a) =
    ind-Set-quotient/Prop A R
      ( \ x. Prop-trunc/Prop (Fib A (Set-quotient A R) (\ a. Set-quotient/q a) x))
      ( \ x. Prop-trunc/unit (x, refl (Set-quotient A R) (Set-quotient/q x)))
#+end_src

** Set quotient is a set quotient

   #+begin_src ctt
  Set-quotient/relation (A : U) (R : Eq-Rel A) : reflecting-map-Eq-Rel A R (Set-quotient A R) =
    ( (\ x. Set-quotient/q x),
      Set-quotient/respects-relation A R)

  Set-quotient/is-set-quotient/map (A : U) (R : Eq-Rel A) (B : UU-Set)
                                      : (Set-quotient A R -> Set/type B) -> (reflecting-map-Eq-Rel A R (Set/type B)) =
    precomp-Set-quotient A R
      ( Set-quotient/Set A R) B
      ( Set-quotient/relation A R)

  Set-quotient/is-set-quotient/inv-map (A : U) (R : Eq-Rel A) (B : UU-Set)
                                          : (reflecting-map-Eq-Rel A R (Set/type B)) -> (Set-quotient A R -> Set/type B) =
    \ t. rec-Set-quotient A R B t.1 t.2

  Set-quotient/is-set-quotient/right-htpy (A : U) (R : Eq-Rel A) (B : UU-Set) (t : reflecting-map-Eq-Rel A R (Set/type B))
                                             : Path (reflecting-map-Eq-Rel A R (Set/type B)) (Set-quotient/is-set-quotient/map A R B (Set-quotient/is-set-quotient/inv-map A R B t)) t =
    refl (reflecting-map-Eq-Rel A R (Set/type B)) t

  Set-quotient/is-set-quotient/left-htpy (A : U) (R : Eq-Rel A) (B : UU-Set) (f : Set-quotient A R -> Set/type B)
                                            : Path (Set-quotient A R -> Set/type B) (Set-quotient/is-set-quotient/inv-map A R B (Set-quotient/is-set-quotient/map A R B f)) f =
    \ i x.
      rec-Prop-trunc
        ( Fib A (Set-quotient A R) (\ z. Set-quotient/q z) x)
        ( Set/eq/Prop B
          ( Set-quotient/is-set-quotient/inv-map A R B (Set-quotient/is-set-quotient/map A R B f) x)
          ( f x))
        ( \ t. 
            comp
              ( Set/type B)
              ( Set-quotient/is-set-quotient/inv-map A R B (Set-quotient/is-set-quotient/map A R B f) x)
              ( f (Set-quotient/q t.1))
              ( ap (Set-quotient A R) (Set/type B) (\ z. Set-quotient/is-set-quotient/inv-map A R B (Set-quotient/is-set-quotient/map A R B f) z) x (Set-quotient/q t.1) t.2)
              ( f x)
              ( ap (Set-quotient A R) (Set/type B) f (Set-quotient/q t.1) x (inv (Set-quotient A R) x (Set-quotient/q t.1) t.2)))
        ( quotienting-is-surj A R x) i
   #+end_src
Then, we can conclude on it being an equivalence.
#+begin_src ctt
  Set-quotient/is-set-quotient (A : U) (R : Eq-Rel A) : is-set-quotient A R (Set-quotient/Set A R) (Set-quotient/relation A R) =
    \ B.
    has-inverse/is-equiv
      ( Set-quotient A R -> Set/type B)
      ( reflecting-map-Eq-Rel A R (Set/type B))
      ( Set-quotient/is-set-quotient/map A R B)
      ( Set-quotient/is-set-quotient/inv-map A R B,
        ( Set-quotient/is-set-quotient/right-htpy A R B,
          Set-quotient/is-set-quotient/left-htpy A R B))
#+end_src

** Effective on equivalence relations
The equality on set quotient is equivalent to the relation.
#+begin_src ctt
  -- is-set-quotient/is-effective/rel-aux (A : U) (R : Eq-Rel A) (x y : Set-quotient A R) : UU-Prop =
  
#+end_src

** Uniqueness principle
We show that whenever a pair (f : A \to B, g : R(x, y) \to f x = f y) is a set quotient, then any map that extends f is unique. To see this, we use the im/inclusion and im/q functions. First, we show that for any x, y such that R(x, y), im/q q x = im/q q y. Indeed, im/inclusion (im/q q x) = q x = q y = im/inclusion (im/q q y), and im/inclusion is injective.
#+begin_src ctt
  is-set-quotient/is-surj/identifying-q (A : U) (R : Eq-Rel A) (B : UU-Set) (f : reflecting-map-Eq-Rel A R (Set/type B))
                                        (x y : A) (r : Eq-Rel/type A R x y)
                                           : Path (im A (Set/type B) (reflecting-map-Eq-Rel/map A R (Set/type B) f))
                                                  (im/q A (Set/type B) (reflecting-map-Eq-Rel/map A R (Set/type B) f) x)
                                                  (im/q A (Set/type B) (reflecting-map-Eq-Rel/map A R (Set/type B) f) y) =
    let g : A -> Set/type B = (reflecting-map-Eq-Rel/map A R (Set/type B) f) in
    im/is-injective A
      ( Set/type B) g
      ( im/q A (Set/type B) g x)
      ( im/q A (Set/type B) g y)
      ( comp-n
        ( Set/type B) three-Nat
        ( im/inclusion A (Set/type B) g (im/q A (Set/type B) g x))
        ( g x)
        ( im/htpy A (Set/type B) g x)
        ( g y)
        ( reflecting-map-Eq-Rel/reflects-Eq A R (Set/type B) f x y r)
        ( im/inclusion A (Set/type B) g (im/q A (Set/type B) g y))
        ( im/htpy' A (Set/type B) g y))
#+end_src
As im(q) is a set and f a set quotient, we get an extension of q_q along q.
#+begin_src ctt
  is-set-quotient/is-surj/map (A : U) (R : Eq-Rel A) (B : UU-Set) (f : reflecting-map-Eq-Rel A R (Set/type B))
                              (is-set-quotient-f : is-set-quotient A R B f) : Set/type B -> im A (Set/type B) (reflecting-map-Eq-Rel/map A R (Set/type B) f) =
    let q : A -> Set/type B = reflecting-map-Eq-Rel/map A R (Set/type B) f in
    is-equiv/inv-map
      ( Set/type B -> im A (Set/type B) q)
      ( reflecting-map-Eq-Rel A R (Set/type (im/Set A B q)))
      ( precomp-Set-quotient A R B (im/Set A B q) f)
      ( is-set-quotient-f (im/Set A B q))
      ( im/q A (Set/type B) q,
        is-set-quotient/is-surj/identifying-q A R B f)
#+end_src
We can show that the composition of this map with image inclusion is actually q_q.
#+begin_src ctt
  lock is-prop/is-set
  is-set-quotient/is-surj/htpy (A : U) (R : Eq-Rel A) (B : UU-Set) (f : reflecting-map-Eq-Rel A R (Set/type B))
                               (H : is-set-quotient A R B f) : Htpy' A (im A (Set/type B) (reflecting-map-Eq-Rel/map A R (Set/type B) f))
                                                                     (\ x. is-set-quotient/is-surj/map A R B f H (reflecting-map-Eq-Rel/map A R (Set/type B) f x))
                                                                     (im/q A (Set/type B) (reflecting-map-Eq-Rel/map A R (Set/type B) f)) =
    let q : A -> Set/type B = reflecting-map-Eq-Rel/map A R (Set/type B) f in
    htpy-eq' A
      ( im A (Set/type B) q)
      ( \ x. is-set-quotient/is-surj/map A R B f H (q x))
      ( im/q A (Set/type B) q)
      ( \ i. ( ( is-equiv/inv-right-htpy 
                ( Set/type B -> im A (Set/type B) q)
                ( reflecting-map-Eq-Rel A R (Set/type (im/Set A B q)))
                ( precomp-Set-quotient A R B (im/Set A B q) f)
                ( H (im/Set A B q))
                ( im/q A (Set/type B) q,
                  is-set-quotient/is-surj/identifying-q A R B f)) i).1)
#+end_src
As such, the composition of the inclusion with the map and q is q.
#+begin_src ctt
  is-set-quotient/is-surj/htpy2 (A : U) (R : Eq-Rel A) (B : UU-Set) (f : reflecting-map-Eq-Rel A R (Set/type B)) (H : is-set-quotient A R B f) (x : A)
                                   : Path (Set/type B)
                                          (im/inclusion A (Set/type B) (reflecting-map-Eq-Rel/map A R (Set/type B) f)
                                                          (is-set-quotient/is-surj/map A R B f H (reflecting-map-Eq-Rel/map A R (Set/type B) f x)))
                                          (reflecting-map-Eq-Rel/map A R (Set/type B) f x) =
    let q : A -> Set/type B = reflecting-map-Eq-Rel/map A R (Set/type B) f in
    comp
      ( Set/type B)
      ( im/inclusion A
        ( Set/type B) q
        ( is-set-quotient/is-surj/map A R B f H (q x)))
      ( im/inclusion A
        ( Set/type B) q
        ( im/q A (Set/type B) q x))
      ( ap (im A (Set/type B) q) (Set/type B) (im/inclusion A (Set/type B) q) (is-set-quotient/is-surj/map A R B f H (q x)) (im/q A (Set/type B) q x)
        ( is-set-quotient/is-surj/htpy A R B f H x))
      ( q x)
      ( im/htpy A (Set/type B) q x)
#+end_src
We can conclude that q is surjective.
#+begin_src ctt
  -- is-set-quotient/is-surj (A : U) (R : Relation-Prop A) (B : UU-Set) (f : reflecting-map-Eq-Rel A R B) (H : is-set-quotient A R B f)
  --                            : is-surj A (Set/type B) (reflecting-map-Eq-Rel A R B f) =
  --   let q : A -> Set/type B = (reflecting-map-Eq-Rel A R B f) in
#+end_src

#+RESULTS:
: Typecheck has succeeded.

