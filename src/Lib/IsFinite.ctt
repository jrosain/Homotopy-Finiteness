module Lib.IsFinite where

import Lib.PropTrunc
import Lib.Counting
import Lib.Image
import Lib.Prop.Nat
import Lib.Prop.Coprod
import Lib.Prop.Empty  
import Lib.Prop.Decidability

is-finite (X : U) : U =
  Prop-trunc
    ( count X)

is-finite/is-prop (X : U) : is-prop (is-finite X) =
  Prop-trunc/is-prop
    ( count X)

is-finite/Prop (X : U) : UU-Prop =
  ( is-finite X,
    is-finite/is-prop X)

count/is-finite (X : U) (c : count X) : is-finite X =
  Prop-trunc/unit c

Unit/is-finite : is-finite Unit =
  count/is-finite Unit
    ( count/Unit)

Fin/is-finite (k : Nat) : is-finite (Fin k) =
  count/is-finite
    ( Fin k)
    ( count/fin-count k)

is-finite/closed-Equiv (A B : U) (e : Equiv A B) (is-finite-B : is-finite B) : is-finite A =
  Prop-trunc/map
    ( count B)
    ( count A)
    ( count/closed-equiv A B e) is-finite-B    

is-finite/closed-Equiv' (A B : U) (e : Equiv A B) (is-finite-A : is-finite A) : is-finite B =
  is-finite/closed-Equiv B A (Equiv/sym A B e) is-finite-A

has-cardinality (X : U) : U =
  Sg Nat
    ( \ k. mere-equiv (Fin k) X)

has-cardinality/is-prop/sg (X : U) (k : Nat) (h : mere-equiv (Fin k) X) (k' : Nat) (h' : mere-equiv (Fin k') X)
                              : Path (has-cardinality X) (k, h) (k', h') =
  SgPath-prop Nat
    ( \ n. mere-equiv (Fin n) X)
    ( \ n. mere-equiv/is-prop (Fin n) X)
    ( k, h)
    ( k', h')
    ( rec-Prop-trunc
      ( Equiv (Fin k) X)
      ( Nat/eq/Prop k k')
      ( \ e. rec-Prop-trunc
              ( Equiv (Fin k') X)
              ( Nat/eq/Prop k k')
              ( \ e'. Fin/is-inj k k'
                       ( Equiv/trans
                          ( Fin k) X
                          ( Fin k') e
                          ( Equiv/sym (Fin k') X e'))) h') h)

has-cardinality/is-prop (X : U) : is-prop (has-cardinality X) =
  \ h h'. has-cardinality/is-prop/sg X h.1 h.2 h'.1 h'.2

has-cardinality/Prop (X : U) : UU-Prop =
  ( has-cardinality X,
    has-cardinality/is-prop X)

is-finite/has-cardinality (X : U) : is-finite X -> has-cardinality X =
  rec-Prop-trunc
    ( count X)
    ( has-cardinality/Prop X)
    ( \ c. ( number-of-elements X c,
            Prop-trunc/unit (count/Equiv X c)))

has-cardinality/is-finite' (X : U) (k : Nat) (e : mere-equiv (Fin k) X) : is-finite X =
  rec-Prop-trunc
    ( Equiv (Fin k) X)
    ( is-finite/Prop X)
    ( \ e'. Prop-trunc/unit (k, e')) e    

has-cardinality/is-finite (X : U) : has-cardinality X -> is-finite X =
  \ t. has-cardinality/is-finite' X t.1 t.2

has-cardinality/card (X : U) (h : has-cardinality X) : Nat = h.1

has-cardinality/Equiv (X : U) (h : has-cardinality X) : mere-equiv (Fin (has-cardinality/card X h)) X = h.2

card (X : U) (i : is-finite X) : Nat =
  has-cardinality/card X
    ( is-finite/has-cardinality X i)

is-finite/closed-Coprod (A B : U) (is-finite-A : is-finite A) (is-finite-B : is-finite B) : is-finite (Coprod A B) =
  rec-Prop-trunc
    ( count A)
    ( is-finite/Prop (Coprod A B))
    ( \ c. rec-Prop-trunc
            ( count B)
            ( is-finite/Prop (Coprod A B))
            ( \ c'. Prop-trunc/unit (count/closed-Coprod A B c c'))
            is-finite-B)
    is-finite-A

is-finite/closed-Coprod-left (A B : U) (is-finite-copr : is-finite (Coprod A B)) : is-finite A =
  rec-Prop-trunc
    ( count (Coprod A B))
    ( is-finite/Prop A)
    ( \ c. Prop-trunc/unit (count/closed-Coprod-left A B c))
    is-finite-copr

is-finite/closed-Coprod-right (A B : U) (is-finite-copr : is-finite (Coprod A B)) : is-finite B =
  rec-Prop-trunc
    ( count (Coprod A B))
    ( is-finite/Prop B)
    ( \ c. Prop-trunc/unit (count/closed-Coprod-right A B c))
    is-finite-copr

is-finite/closed-Prod (A B : U) (is-finite-A : is-finite A) (is-finite-B : is-finite B) : is-finite (A * B) =
  rec-Prop-trunc
    ( count A)
    ( is-finite/Prop (A * B))
    ( \ c. rec-Prop-trunc
            ( count B)
            ( is-finite/Prop (A * B))
            ( \ c'. Prop-trunc/unit (count/closed-Prod A B c c'))
            is-finite-B)
    is-finite-A

Bool : U = Coprod Unit Unit

true : Bool = inl star
false : Bool = inr star

Bool/is-finite : is-finite Bool =
  is-finite/closed-Coprod
    Unit
    Unit
    Unit/is-finite
    Unit/is-finite

BoolBool/card : Nat =
  card
    ( Bool * Bool)
    ( is-finite/closed-Prod Bool Bool Bool/is-finite Bool/is-finite)

is-finite/pi' : (k : Nat) -> (B : Fin k -> U) -> ((x : Fin k) -> is-finite (B x)) -> is-finite ((x : Fin k) -> B x) = split
  zero ->
    \ B _.
      count/is-finite
        ( (x : Fin zero) -> B x)
        ( count/contr-count
          ( (x : Fin zero) -> B x)
          ( Empty/universal-dependent-property
            ( Fin zero) B
            ( Equiv/refl (Fin zero))))
  suc k ->
    \ B is-fin-B.
      is-finite/closed-Equiv
        ( (x : Fin (suc k)) -> B x)
        ( ((x : Fin k) -> B (inl x)) * (B (inr star)))
        ( Equiv/trans
          ( (x : Fin (suc k)) -> B x)
          ( ((x : Fin k) -> B (inl x)) * ((u : Unit) -> B (inr u)))
          ( ((x : Fin k) -> B (inl x)) * (B (inr star)))
          ( Coprod/dependent-universal-property
            ( Fin k) Unit B)
          ( Equiv/prod'
            ( (x : Fin k) -> B (inl x))
            ( (u : Unit) -> B (inr u))
            ( B (inr star))
            ( Equiv/pi-Unit
              ( \ u. B (inr u)))))
        ( is-finite/closed-Prod
          ( (x : Fin k) -> B (inl x))
          ( B (inr star))
          ( is-finite/pi' k
            ( \ x. B (inl x))
            ( \ x. is-fin-B (inl x)))
          ( is-fin-B (inr star)))

is-finite/Pi (A : U) (B : A -> U) (is-finite-A : is-finite A) (is-finite-B : (x : A) -> is-finite (B x))
                : is-finite ((x : A) -> B x) =
  rec-Prop-trunc
    ( count A)
    ( is-finite/Prop ((x : A) -> B x))
    ( \ c.
      is-finite/closed-Equiv
        ( (x : A) -> B x)
        ( (x : Fin (number-of-elements A c)) -> B (Equiv/map (Fin (number-of-elements A c)) A (count/Equiv A c) x))
        ( Equiv/dependent
          ( Fin (number-of-elements A c)) A B
          ( count/Equiv A c))
        ( is-finite/pi'
          ( number-of-elements A c)
          ( \ x. B (Equiv/map (Fin (number-of-elements A c)) A (count/Equiv A c) x))
          ( \ x. is-finite-B (Equiv/map (Fin (number-of-elements A c)) A (count/Equiv A c) x)))) is-finite-A

is-finite/is-set (A : U) : is-finite A -> is-set A =
  rec-Prop-trunc
    ( count A)
    ( is-set/Prop A)
    ( \ c. count/is-set A c)

is-finite/has-decidable-equality (A : U) (is-finite-A : is-finite A) : has-decidable-equality A =
  rec-Prop-trunc
    ( count A)
    ( has-decidable-equality/Prop A
      ( is-finite/is-set A is-finite-A))
    ( count/has-decidable-eq A) is-finite-A

Fin/choice : (k : Nat) (B : Fin k -> U) (H : (x : Fin k) -> Prop-trunc (B x)) -> Prop-trunc ((x : Fin k) -> B x) = split
  zero -> \ B _.
    Prop-trunc/unit
      ( center ((x : Fin zero) -> B x)
        ( Empty/universal-dependent-property
          ( Fin zero) B
          ( Equiv/refl (Fin zero))))
  suc k -> \ B.
    Equiv/map
      ( (x : Fin (suc k)) -> Prop-trunc (B x))
      ( Prop-trunc ((x : Fin (suc k)) -> B x))
      ( Equiv/comp five-Nat
        ( (x : Fin (suc k)) -> Prop-trunc (B x))
        ( ((x : Fin k) -> Prop-trunc (B (inl x))) * ((x : Unit) -> Prop-trunc (B (inr x))))
        ( Coprod/dependent-universal-property
          ( Fin k) Unit (\ x. Prop-trunc (B x)))
        ( ((x : Fin k) -> Prop-trunc (B (inl x))) * (Prop-trunc (B (inr star))))
        ( Equiv/prod'
          ( (x : Fin k) -> Prop-trunc (B (inl x)))
          ( (x : Unit) -> Prop-trunc (B (inr x)))
          ( Prop-trunc (B (inr star)))
          ( Equiv/pi-Unit
            ( \ x. Prop-trunc (B (inr x)))))
        ( (Prop-trunc ((x : Fin k) -> B (inl x))) * (Prop-trunc (B (inr star))))
        ( Equiv/prod
          ( (x : Fin k) -> Prop-trunc (B (inl x)))
          ( Prop-trunc ((x : Fin k) -> B (inl x)))
          ( Prop-trunc (B (inr star)))
          ( Prop/Equiv
            ( Prop/Pi (Fin k) (\ x. Prop-trunc/Prop (B (inl x))))
            ( Prop-trunc/Prop ((x : Fin k) -> B (inl x)))
            ( Fin/choice k (\ x. B (inl x)))
            ( Prop-trunc/Pi/map-out
              ( Fin k)
              ( \ x. B (inl x)))))
        ( Prop-trunc (((x : Fin k) -> B (inl x)) * (B (inr star))))
        ( Prop-trunc/closed-Prod
          ( (x : Fin k) -> B (inl x))
          ( B (inr star)))
        ( Prop-trunc (((x : Fin k) -> B (inl x)) * ((x : Unit) -> B (inr x))))
        ( Equiv/Prop-trunc
          (((x : Fin k) -> B (inl x)) * (B (inr star)))
          (((x : Fin k) -> B (inl x)) * ((x : Unit) -> B (inr x)))
          ( Equiv/prod'
            ( (x : Fin k) -> B (inl x))
            ( B (inr star))
            ( (x : Unit) -> B (inr x))
            ( Equiv/sym
              ( (x : Unit) -> B (inr x))
              ( B (inr star))
              ( Equiv/pi-Unit (\ x. B (inr x))))))
        ( Prop-trunc ((x : Fin (suc k)) -> B x))
        ( Equiv/Prop-trunc
          ( ((x : Fin k) -> B (inl x)) * ((x : Unit) -> B (inr x)))
          ( (x : Fin (suc k)) -> B x)
          ( Equiv/sym
            ( (x : Fin (suc k)) -> B x)
            ( ((x : Fin k) -> B (inl x)) * ((x : Unit) -> B (inr x)))
            ( Coprod/dependent-universal-property
              ( Fin k) Unit B))))

is-finite/choice (A : U) (B : A -> U) (is-finite-A : is-finite A) (H : (x : A) -> Prop-trunc (B x)) : Prop-trunc ((x : A) -> B x) =
  rec-Prop-trunc
    ( count A)
    ( Prop-trunc/Prop
      ( (x : A) -> B x))
    ( \ c. 
        let k : Nat = number-of-elements A c
            f : Fin k -> A = Equiv/map (Fin k) A (count/Equiv A c)
            g : A -> Fin k = Equiv/inv-map (Fin k) A (count/Equiv A c)
         in
        rec-Prop-trunc
          ( (x : (Fin k)) -> B (f x))
          ( Prop-trunc/Prop ((x : A) -> B x))
          ( \ h. Prop-trunc/unit
                ( \ x. tr A (f (g x)) x (Equiv/inv-right-htpy (Fin k) A (count/Equiv A c) x) B (h (g x))))
          ( Fin/choice k
            ( \ x. B (f x))
            ( \ x. H (f x)))) is-finite-A

is-finite/closed-Sg (A : U) (B : A -> U) (is-finite-A : is-finite A) (H : (x : A) -> is-finite (B x)) : is-finite (Sg A B) =
  rec-Prop-trunc
    ( count A)
    ( is-finite/Prop
        ( Sg A B))
    ( \ c. rec-Prop-trunc
            ( (x : A) -> count (B x))
            ( is-finite/Prop
              ( Sg A B))
            ( \ H'. Prop-trunc/unit (count/closed-Sg A B c H'))
            ( is-finite/choice A (\ x. count (B x)) is-finite-A H)) is-finite-A

has-decidable-equality/is-finite/base/map (B : U) (f : Empty -> B) (H : is-surj Empty B f) : B -> Empty =
  \ b. rec-Prop-trunc
      ( Fib Empty B f b)
      ( Empty/Prop)
      ( \ t. t.1)
      ( H b)

has-decidable-equality/is-finite/base/right-htpy (B : U) (f : Empty -> B) (H : is-surj Empty B f) (x : Empty)
                                                    : Path Empty (has-decidable-equality/is-finite/base/map B f H (f x)) x =
  ex-falso
    ( Path Empty (has-decidable-equality/is-finite/base/map B f H (f x)) x) x    

has-decidable-equality/is-finite/base/left-htpy (B : U) (f : Empty -> B) (H : is-surj Empty B f) (b : B)
                                                   : Path B (f (has-decidable-equality/is-finite/base/map B f H b)) b =
  ex-falso
    ( Path B (f (has-decidable-equality/is-finite/base/map B f H b)) b)
    ( rec-Prop-trunc
        ( Fib Empty B f b)
        ( Empty/Prop)
        ( \ t. t.1)
        ( H b))

has-decidable-equality/is-finite/base (B : U) (f : Empty -> B) (H : is-surj Empty B f) : count B =
  ( zero,
    has-inverse/Equiv Empty B f
      ( has-decidable-equality/is-finite/base/map B f H,
        ( has-decidable-equality/is-finite/base/left-htpy B f H,
          has-decidable-equality/is-finite/base/right-htpy B f H)))

has-decidable-equality/is-finite/decide/s'' (B : U) (y : B) (k : Nat) (f : Fin (suc k) -> B) (p : neg (Path B y (f (inr star))))
                                            (h : (x : Fin k) -> neg (Path B y (f (inl x))))
                                               : (x : Fin (suc k)) -> neg (Path B y (f x)) = split
  inl x -> h x
  inr s -> ind-Unit
            ( \ x. neg (Path B y (f (inr x)))) p s

has-decidable-equality/is-finite/decide/s' (B : U) (y : B) (k : Nat) (f : Fin (suc k) -> B) (p : neg (Path B y (f (inr star))))
                                              : Coprod (Sg (Fin k) (\ x. Path B y (f (inl x)))) ((x : Fin k) -> neg (Path B y (f (inl x))))
                                               -> Coprod (Sg (Fin (suc k)) (\ x. Path B y (f x))) ((x : Fin (suc k)) -> neg (Path B y (f x))) = split
  inl t -> inl (inl t.1, t.2)
  inr h -> inr (has-decidable-equality/is-finite/decide/s'' B y k f p h)

has-decidable-equality/is-finite/decide/s (B : U) (y : B) (k : Nat) (f : Fin (suc k) -> B)
                                          (u : Coprod (Sg (Fin k) (\ x. Path B y (f (inl x)))) ((x : Fin k) -> neg (Path B y (f (inl x)))))
                                             : Coprod (Path B y (f (inr star))) (neg (Path B y (f (inr star))))
                                              -> Coprod (Sg (Fin (suc k)) (\ x. Path B y (f x))) ((x : Fin (suc k)) -> neg (Path B y (f x))) = split
  inl p -> inl (inr star, p)
  inr p -> has-decidable-equality/is-finite/decide/s' B y k f p u

has-decidable-equality/is-finite/decide (B : U) (y : B) (Heq : has-decidable-equality B) : (k : Nat) -> (f : Fin k -> B)
                                            -> Coprod (Sg (Fin k) (\ x. Path B y (f x))) ((x : Fin k) -> neg (Path B y (f x))) = split
  zero -> \ _. inr (\ x _. x)
  suc k -> \ f. has-decidable-equality/is-finite/decide/s B y k f
                ( has-decidable-equality/is-finite/decide B y Heq k
                  ( \ x. f (inl x)))
                ( Heq y (f (inr star)))

has-decidable-equality/is-finite/subtype (k : Nat) (B : U) (f : Fin (suc k) -> B) (H : (y : B) -> Fib (Fin (suc k)) B f y) : U =
  Sg (Fin k) (\ x. Path (Fin (suc k)) (H (f (inl x))).1 (inl x))

has-decidable-equality/is-finite/map'' (k : Nat) (B : U) (f : Fin (suc k) -> B) (y : B) (p : neg (Path B y (f (inr star)))) (H : (b : B) -> Fib (Fin (suc k)) B f b)
                                          : (x : Fin (suc k)) -> Path (Fin (suc k)) (H (f x)).1 x -> Path B y (f x) -> has-decidable-equality/is-finite/subtype k B f H = split
  inl x -> \ q _. (x, q)
  inr s -> \ q. ind-Unit
                ( \ x. (Path B y (f (inr x))) -> has-decidable-equality/is-finite/subtype k B f H)
                ( \ r. ex-falso (has-decidable-equality/is-finite/subtype k B f H) (p r)) s

has-decidable-equality/is-finite/map' (k : Nat) (B : U) (f : Fin (suc k) -> B) (H : (y : B) -> Fib (Fin (suc k)) B f y) (y : B)
                                         : Coprod (Path B y (f (inr star))) (neg (Path B y (f (inr star))))
                                          -> Coprod (has-decidable-equality/is-finite/subtype k B f H) Unit = split
  inl _ -> inr star
  inr p ->
    let x : Fin (suc k) = (H y).1
        q : Path B y (f x) = (H y).2
    in inl ( has-decidable-equality/is-finite/map'' k B f y p H x
             ( ap B (Fin (suc k)) (\ b. (H b).1) (f x) y (inv B y (f x) q)) q)

has-decidable-equality/is-finite/map (k : Nat) (B : U) (Heq : has-decidable-equality B) (f : Fin (suc k) -> B) (H : (y : B) -> Fib (Fin (suc k)) B f y) (y : B)
                                        : Coprod (has-decidable-equality/is-finite/subtype k B f H) Unit =
  has-decidable-equality/is-finite/map' k B f H y
    ( Heq y (f (inr star)))

has-decidable-equality/is-finite/inv-map (k : Nat) (B : U) (f : Fin (suc k) -> B) (H : (y : B) -> Fib (Fin (suc k)) B f y)
                                            : Coprod (has-decidable-equality/is-finite/subtype k B f H) Unit -> B = split
  inl t -> f (inl t.1)
  inr _ -> f (inr star)

has-decidable-equality/is-finite/Path' (k : Nat) (B : U) (f : Fin (suc k) -> B) (H : (y : B) -> Fib (Fin (suc k)) B f y) (Heq : has-decidable-equality B)
                                       (y : B) (p : Path (Coprod (has-decidable-equality/is-finite/subtype k B f H) Unit)
                                                         (has-decidable-equality/is-finite/map k B Heq f H y) (inr star))
                                         : (u : Coprod (Path B y (f (inr star))) (neg (Path B y (f (inr star)))))
                                           -> Path (Coprod (Path B y (f (inr star))) (neg (Path B y (f (inr star)))))
                                                  u (Heq y (f (inr star)))
                                           -> Path B y (f (inr star)) = split
  inl q -> \ _. q
  inr h -> \ q.
    let x : Fin (suc k) = (H y).1
        q' : Path B y (f x) = (H y).2
        r : Path (Fin (suc k)) (H (f x)).1 (H y).1 = ap B (Fin (suc k)) (\ b. (H b).1) (f x) y (inv B y (f x) q')
    in
    ex-falso
      ( Path B y (f (inr star)))
      ( Coprod/Eq/eq-map
        ( has-decidable-equality/is-finite/subtype k B f H) Unit
        ( inl (has-decidable-equality/is-finite/map'' k B f y h H x r q'))
        ( inr star)
        ( comp
          ( Coprod (has-decidable-equality/is-finite/subtype k B f H) Unit) 
          ( inl (has-decidable-equality/is-finite/map'' k B f y h H x r q'))
          ( has-decidable-equality/is-finite/map' k B f H y (Heq y (f (inr star))))
          ( ap ( Coprod (Path B y (f (inr star))) (neg (Path B y (f (inr star)))))
               ( Coprod (has-decidable-equality/is-finite/subtype k B f H) Unit)
               ( has-decidable-equality/is-finite/map' k B f H y)
               ( inr h)
               ( Heq y (f (inr star))) q)
          ( inr star) p))

has-decidable-equality/is-finite/Path (k : Nat) (B : U) (f : Fin (suc k) -> B) (H : (y : B) -> Fib (Fin (suc k)) B f y) (Heq : has-decidable-equality B)
                                      (y : B) (p : Path (Coprod (has-decidable-equality/is-finite/subtype k B f H) Unit)
                                                        (has-decidable-equality/is-finite/map k B Heq f H y) (inr star))
                                         : Path B y (f (inr star)) =
  has-decidable-equality/is-finite/Path' k B f H Heq y p
    ( Heq y (f (inr star)))
    ( refl
      ( Coprod (Path B y (f (inr star))) (neg (Path B y (f (inr star)))))
      ( Heq y (f (inr star))))

has-decidable-equality/is-finite/right-htpy/inl' (k : Nat) (B : U) (f : Fin (suc k) -> B) (H : (y : B) -> Fib (Fin (suc k)) B f y) (HB : has-decidable-equality B)
                                                 (t : has-decidable-equality/is-finite/subtype k B f H) (p : neg (Path B (f (inl t.1)) (f (inr star))))
                                                    : (x : Fin (suc k)) -> (r : Path (Fin (suc k)) (H (f x)).1 x) -> (q : Path B (f (inl t.1)) (f x))
                                                     -> Path (has-decidable-equality/is-finite/subtype k B f H)
                                                            (has-decidable-equality/is-finite/map'' k B f (f (inl t.1)) p H x r q) t = split
  inl x -> \ r q.
    SgPath-prop
      ( Fin k)
      ( \ x'. Path (Fin (suc k)) (H (f (inl x'))).1 (inl x'))
      ( \ x'. count/is-set
              ( Fin (suc k))
              ( count/fin-count (suc k))
              ( H (f (inl x'))).1
              ( inl x'))
      ( x, r) t
      ( Coprod/inl-inj
          ( Fin k) Unit x t.1
          ( comp-n
              ( Fin (suc k)) three-Nat
              ( inl x)
              ( H (f (inl x))).1
              ( inv (Fin (suc k)) (H (f (inl x))).1 (inl x) r)
              ( H (f (inl t.1))).1
              ( ap B (Fin (suc k)) (\ b. (H b).1) (f (inl x)) (f (inl t.1))
                ( inv B (f (inl t.1)) (f (inl x)) q))
              (inl t.1) t.2))
  inr s -> \ r q.
    ex-falso
      ( Path
        ( has-decidable-equality/is-finite/subtype k B f H)
        ( has-decidable-equality/is-finite/map'' k B f (f (inl t.1)) p H (inr s) r q) t)
      ( ind-Unit (\ x. Path B (f (inl t.1)) (f (inr x)) -> Empty)
                 (\ p'. p p') s q)

has-decidable-equality/is-finite/right-htpy/inl/dec (k : Nat) (B : U) (f : Fin (suc k) -> B) (H : (y : B) -> Fib (Fin (suc k)) B f y) (HB : has-decidable-equality B)
                                                    (t : has-decidable-equality/is-finite/subtype k B f H) (u : (has-decidable-equality/is-finite/subtype k B f H))
                                                    (p : Path (Coprod (has-decidable-equality/is-finite/subtype k B f H) Unit) (has-decidable-equality/is-finite/map k B HB f H (f (inl t.1))) (inl u))
                                                       : (v : Coprod (Path B (f (inl t.1)) (f (inr star))) (neg (Path B (f (inl t.1)) (f (inr star)))))
                                                        -> Path (Coprod (Path B (f (inl t.1)) (f (inr star))) (neg (Path B (f (inl t.1)) (f (inr star))))) 
                                                               (HB (f (inl t.1)) (f (inr star))) v
                                                        -> Path (Coprod (has-decidable-equality/is-finite/subtype k B f H) Unit) (inl u) (inl t) = split
  inl p' -> \ q.
    ex-falso
    ( Path (Coprod (has-decidable-equality/is-finite/subtype k B f H) Unit) (inl u) (inl t))
    ( Coprod/Eq/eq-map
      ( has-decidable-equality/is-finite/subtype k B f H) Unit
      ( inl u)
      ( inr star)
      ( comp
        ( Coprod (has-decidable-equality/is-finite/subtype k B f H) Unit) 
        ( inl u)
        ( has-decidable-equality/is-finite/map k B HB f H (f (inl t.1)))
        ( inv
          ( Coprod (has-decidable-equality/is-finite/subtype k B f H) Unit)
          ( has-decidable-equality/is-finite/map k B HB f H (f (inl t.1)))
          ( inl u) p)
        ( has-decidable-equality/is-finite/map' k B f H (f (inl t.1)) (inl p'))
        ( ap ( Coprod (Path B (f (inl t.1)) (f (inr star))) (neg (Path B (f (inl t.1)) (f (inr star)))))
             ( Coprod (has-decidable-equality/is-finite/subtype k B f H) Unit)
             ( has-decidable-equality/is-finite/map' k B f H (f (inl t.1)))
             ( HB (f (inl t.1)) (f (inr star)))
             ( inl p') q)))
  inr p' -> \ q'.
    let x : Fin (suc k) = (H (f (inl t.1))).1
        q : Path B (f (inl t.1)) (f x) = (H (f (inl t.1))).2
        r : Path (Fin (suc k)) (H (f x)).1 x = ap B (Fin (suc k)) (\ b. (H b).1) (f x) (f (inl t.1)) (inv B (f (inl t.1)) (f x) q)
    in
    Coprod/Eq/map
      ( has-decidable-equality/is-finite/subtype k B f H) Unit
      ( inl u)
      ( inl t) 
      ( comp
        ( has-decidable-equality/is-finite/subtype k B f H) u
        ( has-decidable-equality/is-finite/map'' k B f (f (inl t.1)) p' H x r q)
        ( Coprod/inl-inj (has-decidable-equality/is-finite/subtype k B f H) Unit u
          ( has-decidable-equality/is-finite/map'' k B f (f (inl t.1)) p' H x r q)
          ( comp (Coprod (has-decidable-equality/is-finite/subtype k B f H) Unit) (inl u)
            ( has-decidable-equality/is-finite/map k B HB f H (f (inl t.1)))
            ( inv (Coprod (has-decidable-equality/is-finite/subtype k B f H) Unit) (has-decidable-equality/is-finite/map k B HB f H (f (inl t.1))) (inl u) p)
            ( inl ( has-decidable-equality/is-finite/map'' k B f (f (inl t.1)) p' H x r q))
            ( ap ( Coprod (Path B (f (inl t.1)) (f (inr star))) (neg (Path B (f (inl t.1)) (f (inr star)))))
                 ( Coprod (has-decidable-equality/is-finite/subtype k B f H) Unit)
                 ( has-decidable-equality/is-finite/map' k B f H (f (inl t.1)))
                 ( HB (f (inl t.1)) (f (inr star))) (inr p') q'))) t
        ( has-decidable-equality/is-finite/right-htpy/inl' k B f H HB t p' x r q))

has-decidable-equality/is-finite/right-htpy/inl (k : Nat) (B : U) (f : Fin (suc k) -> B) (H : (y : B) -> Fib (Fin (suc k)) B f y) (HB : has-decidable-equality B)
                                                (t : has-decidable-equality/is-finite/subtype k B f H) (Heq : (x : Fin k) -> neg (Path B (f (inr star)) (f (inl x))))
                                                   : (u : Coprod (has-decidable-equality/is-finite/subtype k B f H) Unit)
                                                    -> Path (Coprod (has-decidable-equality/is-finite/subtype k B f H) Unit)
                                                           (has-decidable-equality/is-finite/map k B HB f H (f (inl t.1))) u
                                                    -> Path (Coprod (has-decidable-equality/is-finite/subtype k B f H) Unit) u (inl t) = split
  inr s -> \ p'.
    ind-Unit
      ( \ x. Path (Coprod (has-decidable-equality/is-finite/subtype k B f H) Unit) (has-decidable-equality/is-finite/map k B HB f H (f (inl t.1))) (inr x)
                   -> Path (Coprod (has-decidable-equality/is-finite/subtype k B f H) Unit) (inr x) (inl t))
      ( \ p. ex-falso
            ( Path
              ( Coprod (has-decidable-equality/is-finite/subtype k B f H) Unit)
              ( inr star)
              ( inl t))
            ( Heq
              ( t.1)
              ( inv B
                ( f (inl t.1))
                ( f (inr star))
                ( has-decidable-equality/is-finite/Path k B f H HB (f (inl t.1)) p)))) s p'
  inl u -> \ p. has-decidable-equality/is-finite/right-htpy/inl/dec k B f H HB t u p
              ( HB (f (inl t.1)) (f (inr star)))
              ( refl (Coprod (Path B (f (inl t.1)) (f (inr star))) (neg (Path B (f (inl t.1)) (f (inr star))))) ( HB (f (inl t.1)) (f (inr star))))

has-decidable-equality/is-finite/right-htpy/inr' (k : Nat) (B : U) (f : Fin (suc k) -> B) (H : (y : B) -> Fib (Fin (suc k)) B f y) (Heq : has-decidable-equality B)
                                                    : (u : Coprod (Path B (f (inr star)) (f (inr star))) (neg (Path B (f (inr star)) (f (inr star)))))
                                                      -> Path (Coprod (Path B (f (inr star)) (f (inr star))) (neg (Path B (f (inr star)) (f (inr star)))))
                                                             (Heq (f (inr star)) (f (inr star))) u
                                                      -> Path (Coprod (has-decidable-equality/is-finite/subtype k B f H) Unit)
                                                             (has-decidable-equality/is-finite/map k B Heq f H (f (inr star)))
                                                             (inr star) = split
  inl p -> \ q.
    ( ap ( Coprod (Path B (f (inr star)) (f (inr star))) (neg (Path B (f (inr star)) (f (inr star)))))
         ( Coprod (has-decidable-equality/is-finite/subtype k B f H) Unit)
         ( has-decidable-equality/is-finite/map' k B f H (f (inr star)))
         ( Heq (f (inr star)) (f (inr star)))
         ( inl p) q)
  inr np -> \ _.
    ex-falso
      ( Path
        ( Coprod (has-decidable-equality/is-finite/subtype k B f H) Unit)
        ( has-decidable-equality/is-finite/map k B Heq f H (f (inr star)))
        ( inr star))
      ( np (refl B (f (inr star))))

has-decidable-equality/is-finite/right-htpy/inr (k : Nat) (B : U) (f : Fin (suc k) -> B) (H : (y : B) -> Fib (Fin (suc k)) B f y) (Heq : has-decidable-equality B)
                                                   : (s : Unit) -> Path (Coprod (has-decidable-equality/is-finite/subtype k B f H) Unit)
                                                                       (has-decidable-equality/is-finite/map k B Heq f H (f (inr star)))
                                                                       (inr s) = split
  star -> 
    has-decidable-equality/is-finite/right-htpy/inr' k B f H Heq
      ( Heq (f (inr star)) (f (inr star)))
      ( refl (Coprod (Path B (f (inr star)) (f (inr star))) (neg (Path B (f (inr star)) (f (inr star))))) (Heq (f (inr star)) (f (inr star))))

has-decidable-equality/is-finite/right-htpy (k : Nat) (B : U) (f : Fin (suc k) -> B) (H : (y : B) -> Fib (Fin (suc k)) B f y) (HB : has-decidable-equality B)
                                            (Heq : (x : Fin k) -> neg (Path B (f (inr star)) (f (inl x))))
                                               : (u : Coprod (has-decidable-equality/is-finite/subtype k B f H) Unit)
                                                -> Path (Coprod (has-decidable-equality/is-finite/subtype k B f H) Unit)
                                                       (has-decidable-equality/is-finite/map k B HB f H (has-decidable-equality/is-finite/inv-map k B f H u)) u = split
  inl t -> has-decidable-equality/is-finite/right-htpy/inl k B f H HB t Heq
            ( has-decidable-equality/is-finite/map k B HB f H (f (inl t.1)))
            ( refl (Coprod (has-decidable-equality/is-finite/subtype k B f H) Unit) (has-decidable-equality/is-finite/map k B HB f H (f (inl t.1))))
  inr s -> has-decidable-equality/is-finite/right-htpy/inr k B f H HB s

has-decidable-equality/is-finite/left-htpy-map (k : Nat) (B : U) (HB : has-decidable-equality B) (f : Fin (suc k) -> B) (H : (y : B) -> Fib (Fin (suc k)) B f y) (y : B)
                                               (np : neg (Path B y (f (inr star)))) (p : Path (Coprod (Path B y (f (inr star))) (neg (Path B y (f (inr star))))) (HB y (f (inr star))) (inr np))
                                                   : (x : Fin (suc k)) -> (q : Path B y (f x)) -> Path (Fib (Fin (suc k)) B f y) (H y) (x, q)
                                                    -> Path B (has-decidable-equality/is-finite/inv-map k B f H
                                                               (inl (has-decidable-equality/is-finite/map'' k B f y np H (H y).1
                                                                (ap B (Fin (suc k)) (\ b. (H b).1) (f (H y).1) y (inv B y (f (H y).1) (H y).2)) (H y).2))) y = split
  inl x -> \ q r.
    comp B
      ( has-decidable-equality/is-finite/inv-map k B f H
        ( inl (has-decidable-equality/is-finite/map'' k B f y np H (H y).1
          ( ap B (Fin (suc k)) (\ b. (H b).1) (f (H y).1) y (inv B y (f (H y).1) (H y).2)) (H y).2)))
      ( has-decidable-equality/is-finite/inv-map k B f H
        ( inl (has-decidable-equality/is-finite/map'' k B f y np H x
          ( ap B (Fin (suc k)) (\ b. (H b).1) (f x) y (inv B y (f x) q)) q)))
      ( ap (Fib (Fin (suc k)) B f y) B
        ( \ t. ( has-decidable-equality/is-finite/inv-map k B f H
                ( inl (has-decidable-equality/is-finite/map'' k B f y np H t.1
                  ( ap B (Fin (suc k)) (\ b. (H b).1) (f t.1) y (inv B y (f t.1) t.2)) t.2))))
        ( H y)
        ( inl x, q) r)
      y ( inv B y (f x) q)


  inr s -> \ _ _. refl (Coprod (has-decidable-equality/is-finite/subtype k B f H) Unit) (has-decidable-equality/is-finite/map k B HB f H y)

--      ( inl ( has-decidable-equality/is-finite/map'' k B f y p H x
--               ( ap B (Fin (suc k)) (\ b. (H b).1) (f x) y (inv B y (f x) q)) q)

-- has-decidable-equality/is-finite/left-htpy' (k : Nat) (B : U) (HB : has-decidable-equality B) (f : Fin (suc k) -> B) (H : (y : B) -> Fib (Fin (suc k)) B f y) (y : B)
--                                                : (u : Coprod (Path B y (f (inr star))) (neg (Path B y (f (inr star)))))
--                                                 -> Path (Coprod (Path B y (f (inr star))) (neg (Path B y (f (inr star)))))
--                                                        (HB y (f (inr star))) u
--                                                 -> Path B (has-decidable-equality/is-finite/inv-map k B f H (has-decidable-equality/is-finite/map k B HB f H y)) y = split
--   inl p -> \ p'.
--     comp B
--       ( has-decidable-equality/is-finite/inv-map k B f H (has-decidable-equality/is-finite/map k B HB f H y))
--       ( has-decidable-equality/is-finite/inv-map k B f H (inr star))
--       ( ap
--         ( Coprod (Path B y (f (inr star))) (neg (Path B y (f (inr star))))) B
--         ( \ q. has-decidable-equality/is-finite/inv-map k B f H (has-decidable-equality/is-finite/map' k B f H y q))
--         ( HB y (f (inr star)))
--         ( inl p) p')
--       y ( inv B y (f (inr star)) p)
--   inr np -> \ p.
--     let x : Fin (suc k) = (H y).1
--         q : Path B y (f x) = (H y).2
--     in 
--     comp B
--       ( has-decidable-equality/is-finite/inv-map k B f H (has-decidable-equality/is-finite/map k B HB f H y))
--       ( has-decidable-equality/is-finite/inv-map k B f H (x, q)) ? -- it is easy to show that it is inv-map (inl ( map'' ...)) but inside we have to show that it's only inl x.
--       y ? -- easy: it depends on the result of inv-map but it must be f (inl t.1) by np (otherwise, we have a path between y and f (inr star)) thus inv q suffices

-- Probably useful for the thing above.
    -- comp
    --   ( Coprod (has-decidable-equality/is-finite/subtype k B f H) Unit)
    --   ( has-decidable-equality/is-finite/map k B HB f H y)
    --   ( has-decidable-equality/is-finite/map' k B f H y (inr np))
    --   ( ap (Coprod (Path B y (f (inr star))) (neg (Path B y (f (inr star))))) (Coprod (has-decidable-equality/is-finite/subtype k B f H) Unit)
    --        (has-decidable-equality/is-finite/map' k B f H y) (HB y (f (inr star))) (inr np) p)
    --   ( x, q)
    --   ( ap (Fib (Fin (suc k)) B f y) (Coprod (has-decidable-equality/is-finite/subtype k B f H) Unit)
    --        (\ t. let x' : Fin (suc k) = t.1 in let q' : Path B y (f x') = t.2
    --             in inl ( has-decidable-equality/is-finite/map'' k B f y p H x'
    --                      ( ap B (Fin (suc k)) (\ b. (H b).1) (f x') y (inv B y (f x') q')) q'))
    --        (H y) (x, q) r)

-- has-decidable-equality/is-finite/left-htpy (k : Nat) (B : U) (f : Fin k -> B) (H : (y : B) -> Fib (Fin k) B f y) (y : B)
--                                                : Path B (has-decidable-equality/is-finite/map k B f H (has-decidable-equality/is-finite/inv-map k B f H y)) y =
--   (inv B y (f (H y).1) (H y).2)


-- has-decidable-equality/is-finite/Equiv (k : Nat) (B : U) (f : Fin k -> B) (H : (y : B) -> Fib (Fin k) B f y)
--                                           : Equiv (has-decidable-equality/is-finite/subtype k B f H) B =
--   has-inverse/Equiv
--     ( has-decidable-equality/is-finite/subtype k B f H) B
--     ( has-decidable-equality/is-finite/map k B f H)
--     ( has-decidable-equality/is-finite/inv-map k B f H,
--       ( has-decidable-equality/is-finite/right-htpy k B f H,
--         has-decidable-equality/is-finite/left-htpy k B f H))
