module Lib.IsFinite where

import Lib.PropTrunc
import Lib.Counting
import Lib.Image
import Lib.Prop.Nat
import Lib.Prop.Coprod
import Lib.Prop.Empty  
import Lib.Prop.Decidability

is-finite (X : U) : U =
  Prop-trunc
    ( count X)

is-finite/is-prop (X : U) : is-prop (is-finite X) =
  Prop-trunc/is-prop
    ( count X)

is-finite/Prop (X : U) : UU-Prop =
  ( is-finite X,
    is-finite/is-prop X)

count/is-finite (X : U) (c : count X) : is-finite X =
  Prop-trunc/unit c

Unit/is-finite : is-finite Unit =
  count/is-finite Unit
    ( count/Unit)

Fin/is-finite (k : Nat) : is-finite (Fin k) =
  count/is-finite
    ( Fin k)
    ( count/fin-count k)

is-finite/closed-Equiv (A B : U) (e : Equiv A B) (is-finite-B : is-finite B) : is-finite A =
  Prop-trunc/map
    ( count B)
    ( count A)
    ( count/closed-equiv A B e) is-finite-B    

is-finite/closed-Equiv' (A B : U) (e : Equiv A B) (is-finite-A : is-finite A) : is-finite B =
  is-finite/closed-Equiv B A (Equiv/sym A B e) is-finite-A

is-finite/is-decidable (X : U) (is-prop-X : is-prop X) (is-finite-X : is-finite X) : is-decidable X =
  rec-Prop-trunc
    ( count X)
    ( is-decidable/Prop X is-prop-X)
    ( \ c. count/countable-is-decidable X c)
    is-finite-X

has-cardinality (X : U) : U =
  Sg Nat
    ( \ k. mere-equiv (Fin k) X)

has-cardinality/is-prop/sg (X : U) (k : Nat) (h : mere-equiv (Fin k) X) (k' : Nat) (h' : mere-equiv (Fin k') X)
                              : Path (has-cardinality X) (k, h) (k', h') =
  SgPath-prop Nat
    ( \ n. mere-equiv (Fin n) X)
    ( \ n. mere-equiv/is-prop (Fin n) X)
    ( k, h)
    ( k', h')
    ( rec-Prop-trunc
      ( Equiv (Fin k) X)
      ( Nat/eq/Prop k k')
      ( \ e. rec-Prop-trunc
              ( Equiv (Fin k') X)
              ( Nat/eq/Prop k k')
              ( \ e'. Fin/is-inj k k'
                       ( Equiv/trans
                          ( Fin k) X
                          ( Fin k') e
                          ( Equiv/sym (Fin k') X e'))) h') h)

has-cardinality/is-prop (X : U) : is-prop (has-cardinality X) =
  \ h h'. has-cardinality/is-prop/sg X h.1 h.2 h'.1 h'.2

has-cardinality/Prop (X : U) : UU-Prop =
  ( has-cardinality X,
    has-cardinality/is-prop X)

is-finite/has-cardinality (X : U) : is-finite X -> has-cardinality X =
  rec-Prop-trunc
    ( count X)
    ( has-cardinality/Prop X)
    ( \ c. ( number-of-elements X c,
            Prop-trunc/unit (count/Equiv X c)))

has-cardinality/is-finite' (X : U) (k : Nat) (e : mere-equiv (Fin k) X) : is-finite X =
  rec-Prop-trunc
    ( Equiv (Fin k) X)
    ( is-finite/Prop X)
    ( \ e'. Prop-trunc/unit (k, e')) e    

has-cardinality/is-finite (X : U) : has-cardinality X -> is-finite X =
  \ t. has-cardinality/is-finite' X t.1 t.2

has-cardinality/card (X : U) (h : has-cardinality X) : Nat = h.1

has-cardinality/Equiv (X : U) (h : has-cardinality X) : mere-equiv (Fin (has-cardinality/card X h)) X = h.2

card (X : U) (i : is-finite X) : Nat =
  has-cardinality/card X
    ( is-finite/has-cardinality X i)

is-finite/closed-Coprod (A B : U) (is-finite-A : is-finite A) (is-finite-B : is-finite B) : is-finite (Coprod A B) =
  rec-Prop-trunc
    ( count A)
    ( is-finite/Prop (Coprod A B))
    ( \ c. rec-Prop-trunc
            ( count B)
            ( is-finite/Prop (Coprod A B))
            ( \ c'. Prop-trunc/unit (count/closed-Coprod A B c c'))
            is-finite-B)
    is-finite-A

is-finite/closed-Coprod-left (A B : U) (is-finite-copr : is-finite (Coprod A B)) : is-finite A =
  rec-Prop-trunc
    ( count (Coprod A B))
    ( is-finite/Prop A)
    ( \ c. Prop-trunc/unit (count/closed-Coprod-left A B c))
    is-finite-copr

is-finite/closed-Coprod-right (A B : U) (is-finite-copr : is-finite (Coprod A B)) : is-finite B =
  rec-Prop-trunc
    ( count (Coprod A B))
    ( is-finite/Prop B)
    ( \ c. Prop-trunc/unit (count/closed-Coprod-right A B c))
    is-finite-copr

is-finite/closed-Prod (A B : U) (is-finite-A : is-finite A) (is-finite-B : is-finite B) : is-finite (A * B) =
  rec-Prop-trunc
    ( count A)
    ( is-finite/Prop (A * B))
    ( \ c. rec-Prop-trunc
            ( count B)
            ( is-finite/Prop (A * B))
            ( \ c'. Prop-trunc/unit (count/closed-Prod A B c c'))
            is-finite-B)
    is-finite-A

Bool : U = Coprod Unit Unit

true : Bool = inl star
false : Bool = inr star

Bool/is-finite : is-finite Bool =
  is-finite/closed-Coprod
    Unit
    Unit
    Unit/is-finite
    Unit/is-finite

BoolBool/card : Nat =
  card
    ( Bool * Bool)
    ( is-finite/closed-Prod Bool Bool Bool/is-finite Bool/is-finite)

is-finite/pi' : (k : Nat) -> (B : Fin k -> U) -> ((x : Fin k) -> is-finite (B x)) -> is-finite ((x : Fin k) -> B x) = split
  zero ->
    \ B _.
      count/is-finite
        ( (x : Fin zero) -> B x)
        ( count/contr-count
          ( (x : Fin zero) -> B x)
          ( Empty/universal-dependent-property
            ( Fin zero) B
            ( Equiv/refl (Fin zero))))
  suc k ->
    \ B is-fin-B.
      is-finite/closed-Equiv
        ( (x : Fin (suc k)) -> B x)
        ( ((x : Fin k) -> B (inl x)) * (B (inr star)))
        ( Equiv/trans
          ( (x : Fin (suc k)) -> B x)
          ( ((x : Fin k) -> B (inl x)) * ((u : Unit) -> B (inr u)))
          ( ((x : Fin k) -> B (inl x)) * (B (inr star)))
          ( Coprod/dependent-universal-property
            ( Fin k) Unit B)
          ( Equiv/prod'
            ( (x : Fin k) -> B (inl x))
            ( (u : Unit) -> B (inr u))
            ( B (inr star))
            ( Equiv/pi-Unit
              ( \ u. B (inr u)))))
        ( is-finite/closed-Prod
          ( (x : Fin k) -> B (inl x))
          ( B (inr star))
          ( is-finite/pi' k
            ( \ x. B (inl x))
            ( \ x. is-fin-B (inl x)))
          ( is-fin-B (inr star)))

is-finite/Pi (A : U) (B : A -> U) (is-finite-A : is-finite A) (is-finite-B : (x : A) -> is-finite (B x))
                : is-finite ((x : A) -> B x) =
  rec-Prop-trunc
    ( count A)
    ( is-finite/Prop ((x : A) -> B x))
    ( \ c.
      is-finite/closed-Equiv
        ( (x : A) -> B x)
        ( (x : Fin (number-of-elements A c)) -> B (Equiv/map (Fin (number-of-elements A c)) A (count/Equiv A c) x))
        ( Equiv/dependent
          ( Fin (number-of-elements A c)) A B
          ( count/Equiv A c))
        ( is-finite/pi'
          ( number-of-elements A c)
          ( \ x. B (Equiv/map (Fin (number-of-elements A c)) A (count/Equiv A c) x))
          ( \ x. is-finite-B (Equiv/map (Fin (number-of-elements A c)) A (count/Equiv A c) x)))) is-finite-A

is-finite/is-set (A : U) : is-finite A -> is-set A =
  rec-Prop-trunc
    ( count A)
    ( is-set/Prop A)
    ( \ c. count/is-set A c)

is-finite/has-decidable-equality (A : U) (is-finite-A : is-finite A) : has-decidable-equality A =
  rec-Prop-trunc
    ( count A)
    ( has-decidable-equality/Prop A
      ( is-finite/is-set A is-finite-A))
    ( count/has-decidable-eq A) is-finite-A

Fin/choice : (k : Nat) (B : Fin k -> U) (H : (x : Fin k) -> Prop-trunc (B x)) -> Prop-trunc ((x : Fin k) -> B x) = split
  zero -> \ B _.
    Prop-trunc/unit
      ( center ((x : Fin zero) -> B x)
        ( Empty/universal-dependent-property
          ( Fin zero) B
          ( Equiv/refl (Fin zero))))
  suc k -> \ B.
    Equiv/map
      ( (x : Fin (suc k)) -> Prop-trunc (B x))
      ( Prop-trunc ((x : Fin (suc k)) -> B x))
      ( Equiv/comp five-Nat
        ( (x : Fin (suc k)) -> Prop-trunc (B x))
        ( ((x : Fin k) -> Prop-trunc (B (inl x))) * ((x : Unit) -> Prop-trunc (B (inr x))))
        ( Coprod/dependent-universal-property
          ( Fin k) Unit (\ x. Prop-trunc (B x)))
        ( ((x : Fin k) -> Prop-trunc (B (inl x))) * (Prop-trunc (B (inr star))))
        ( Equiv/prod'
          ( (x : Fin k) -> Prop-trunc (B (inl x)))
          ( (x : Unit) -> Prop-trunc (B (inr x)))
          ( Prop-trunc (B (inr star)))
          ( Equiv/pi-Unit
            ( \ x. Prop-trunc (B (inr x)))))
        ( (Prop-trunc ((x : Fin k) -> B (inl x))) * (Prop-trunc (B (inr star))))
        ( Equiv/prod
          ( (x : Fin k) -> Prop-trunc (B (inl x)))
          ( Prop-trunc ((x : Fin k) -> B (inl x)))
          ( Prop-trunc (B (inr star)))
          ( Prop/Equiv
            ( Prop/Pi (Fin k) (\ x. Prop-trunc/Prop (B (inl x))))
            ( Prop-trunc/Prop ((x : Fin k) -> B (inl x)))
            ( Fin/choice k (\ x. B (inl x)))
            ( Prop-trunc/Pi/map-out
              ( Fin k)
              ( \ x. B (inl x)))))
        ( Prop-trunc (((x : Fin k) -> B (inl x)) * (B (inr star))))
        ( Prop-trunc/closed-Prod
          ( (x : Fin k) -> B (inl x))
          ( B (inr star)))
        ( Prop-trunc (((x : Fin k) -> B (inl x)) * ((x : Unit) -> B (inr x))))
        ( Equiv/Prop-trunc
          (((x : Fin k) -> B (inl x)) * (B (inr star)))
          (((x : Fin k) -> B (inl x)) * ((x : Unit) -> B (inr x)))
          ( Equiv/prod'
            ( (x : Fin k) -> B (inl x))
            ( B (inr star))
            ( (x : Unit) -> B (inr x))
            ( Equiv/sym
              ( (x : Unit) -> B (inr x))
              ( B (inr star))
              ( Equiv/pi-Unit (\ x. B (inr x))))))
        ( Prop-trunc ((x : Fin (suc k)) -> B x))
        ( Equiv/Prop-trunc
          ( ((x : Fin k) -> B (inl x)) * ((x : Unit) -> B (inr x)))
          ( (x : Fin (suc k)) -> B x)
          ( Equiv/sym
            ( (x : Fin (suc k)) -> B x)
            ( ((x : Fin k) -> B (inl x)) * ((x : Unit) -> B (inr x)))
            ( Coprod/dependent-universal-property
              ( Fin k) Unit B))))

is-finite/choice (A : U) (B : A -> U) (is-finite-A : is-finite A) (H : (x : A) -> Prop-trunc (B x)) : Prop-trunc ((x : A) -> B x) =
  rec-Prop-trunc
    ( count A)
    ( Prop-trunc/Prop
      ( (x : A) -> B x))
    ( \ c. 
        let k : Nat = number-of-elements A c
            f : Fin k -> A = Equiv/map (Fin k) A (count/Equiv A c)
            g : A -> Fin k = Equiv/inv-map (Fin k) A (count/Equiv A c)
         in
        rec-Prop-trunc
          ( (x : (Fin k)) -> B (f x))
          ( Prop-trunc/Prop ((x : A) -> B x))
          ( \ h. Prop-trunc/unit
                ( \ x. tr A (f (g x)) x (Equiv/inv-right-htpy (Fin k) A (count/Equiv A c) x) B (h (g x))))
          ( Fin/choice k
            ( \ x. B (f x))
            ( \ x. H (f x)))) is-finite-A

is-finite/closed-Sg (A : U) (B : A -> U) (is-finite-A : is-finite A) (H : (x : A) -> is-finite (B x)) : is-finite (Sg A B) =
  rec-Prop-trunc
    ( count A)
    ( is-finite/Prop
        ( Sg A B))
    ( \ c. rec-Prop-trunc
            ( (x : A) -> count (B x))
            ( is-finite/Prop
              ( Sg A B))
            ( \ H'. Prop-trunc/unit (count/closed-Sg A B c H'))
            ( is-finite/choice A (\ x. count (B x)) is-finite-A H)) is-finite-A

has-decidable-equality/is-finite/base/map (B : U) (f : Empty -> B) (H : is-surj Empty B f) : B -> Empty =
  \ b. rec-Prop-trunc
      ( Fib Empty B f b)
      ( Empty/Prop)
      ( \ t. t.1)
      ( H b)

has-decidable-equality/is-finite/base/right-htpy (B : U) (f : Empty -> B) (H : is-surj Empty B f) (x : Empty)
                                                    : Path Empty (has-decidable-equality/is-finite/base/map B f H (f x)) x =
  ex-falso
    ( Path Empty (has-decidable-equality/is-finite/base/map B f H (f x)) x) x    

has-decidable-equality/is-finite/base/left-htpy (B : U) (f : Empty -> B) (H : is-surj Empty B f) (b : B)
                                                   : Path B (f (has-decidable-equality/is-finite/base/map B f H b)) b =
  ex-falso
    ( Path B (f (has-decidable-equality/is-finite/base/map B f H b)) b)
    ( rec-Prop-trunc
        ( Fib Empty B f b)
        ( Empty/Prop)
        ( \ t. t.1)
        ( H b))

has-decidable-equality/is-finite/base (B : U) (f : Empty -> B) (H : is-surj Empty B f) : count B =
  ( zero,
    has-inverse/Equiv Empty B f
      ( has-decidable-equality/is-finite/base/map B f H,
        ( has-decidable-equality/is-finite/base/left-htpy B f H,
          has-decidable-equality/is-finite/base/right-htpy B f H)))

has-decidable-equality/is-finite/decide/s'' (B : U) (y : B) (k : Nat) (f : Fin (suc k) -> B) (p : neg (Path B y (f (inr star))))
                                            (h : (x : Fin k) -> neg (Path B y (f (inl x))))
                                               : (x : Fin (suc k)) -> neg (Path B y (f x)) = split
  inl x -> h x
  inr s -> ind-Unit
            ( \ x. neg (Path B y (f (inr x)))) p s

has-decidable-equality/is-finite/decide/s' (B : U) (y : B) (k : Nat) (f : Fin (suc k) -> B) (p : neg (Path B y (f (inr star))))
                                              : Coprod (Sg (Fin k) (\ x. Path B y (f (inl x)))) ((x : Fin k) -> neg (Path B y (f (inl x))))
                                               -> Coprod (Sg (Fin (suc k)) (\ x. Path B y (f x))) ((x : Fin (suc k)) -> neg (Path B y (f x))) = split
  inl t -> inl (inl t.1, t.2)
  inr h -> inr (has-decidable-equality/is-finite/decide/s'' B y k f p h)

has-decidable-equality/is-finite/decide/s (B : U) (y : B) (k : Nat) (f : Fin (suc k) -> B)
                                          (u : Coprod (Sg (Fin k) (\ x. Path B y (f (inl x)))) ((x : Fin k) -> neg (Path B y (f (inl x)))))
                                             : Coprod (Path B y (f (inr star))) (neg (Path B y (f (inr star))))
                                              -> Coprod (Sg (Fin (suc k)) (\ x. Path B y (f x))) ((x : Fin (suc k)) -> neg (Path B y (f x))) = split
  inl p -> inl (inr star, p)
  inr p -> has-decidable-equality/is-finite/decide/s' B y k f p u

has-decidable-equality/is-finite/decide'/z' (B : U) (y : B) (f : Fin (suc (suc zero)) -> B) (np : neg (Path B y (f (inl (inr star)))))
                                               : (x : Fin (suc zero)) -> neg (Path B y (f (inl x))) = split
  inl x -> \ _. x
  inr s -> ind-Unit
            ( \ x. neg (Path B y (f (inl (inr x))))) np s            

has-decidable-equality/is-finite/decide'/z (B : U) (y : B) (f : Fin (suc (suc zero)) -> B) 
                                              : Coprod (Path B y (f (inl (inr star)))) (neg (Path B y (f (inl (inr star)))))
                                               -> Coprod (Sg (Fin (suc zero)) (\ x. Path B y (f (inl x)))) ((x : Fin (suc zero)) -> neg (Path B y (f (inl x)))) = split
  inl p -> inl (inr star, p)
  inr np -> inr (has-decidable-equality/is-finite/decide'/z' B y f np)

has-decidable-equality/is-finite/decide' (B : U) (y : B) (Heq : has-decidable-equality B) : (k : Nat) -> (f : Fin (suc (suc k)) -> B)
                                            -> Coprod (Sg (Fin (suc k)) (\ x. Path B y (f (inl x)))) ((x : Fin (suc k)) -> neg (Path B y (f (inl x)))) = split
  zero -> \ f. has-decidable-equality/is-finite/decide'/z B y f (Heq y (f (inl (inr star))))
  suc k -> \ f.
    has-decidable-equality/is-finite/decide/s B y (suc k) (\ x. f (inl x))
      ( has-decidable-equality/is-finite/decide' B y Heq k (\ x. f (inl x)))
      ( Heq y (f (inl (inr star))))

has-decidable-equality/is-finite/decide (B : U) (y : B) (Heq : has-decidable-equality B) : (k : Nat) -> (f : Fin (suc k) -> B)
                                            -> Coprod (Sg (Fin k) (\ x. Path B y (f (inl x)))) ((x : Fin k) -> neg (Path B y (f (inl x)))) = split
  zero -> \ _. inr (\ x _. x)
  suc k -> has-decidable-equality/is-finite/decide' B y Heq k

has-decidable-equality/is-finite/subtype (k : Nat) (B : U) (f : Fin (suc k) -> B) : U =
  Sg B (\ y. neg (Path B y (f (inr star))))

has-decidable-equality/is-finite/map' (k : Nat) (B : U) (f : Fin (suc k) -> B) (y : B)
                                         : Coprod (Path B y (f (inr star))) (neg (Path B y (f (inr star))))
                                          -> Maybe (has-decidable-equality/is-finite/subtype k B f) = split
  inl _ -> inr star
  inr np -> inl (y, np)

has-decidable-equality/is-finite/map (k : Nat) (B : U) (f : Fin (suc k) -> B) (H : has-decidable-equality B) (y : B) : Maybe (has-decidable-equality/is-finite/subtype k B f) =
  has-decidable-equality/is-finite/map' k B f y
    ( H y (f (inr star)))

has-decidable-equality/is-finite/inv-map (k : Nat) (B : U) (f : Fin (suc k) -> B) (H : has-decidable-equality B) : Maybe (has-decidable-equality/is-finite/subtype k B f) -> B = split
  inl t -> t.1
  inr _ -> f (inr star)

lock Coprod/Eq/map
has-decidable-equality/is-finite/right-htpy/inl (k : Nat) (B : U) (f : Fin (suc k) -> B) (H : has-decidable-equality B) (t : has-decidable-equality/is-finite/subtype k B f)
                                                   : (u : Coprod (Path B t.1 (f (inr star))) (neg (Path B t.1 (f (inr star)))))
                                                    -> Path (Coprod (Path B t.1 (f (inr star))) (neg (Path B t.1 (f (inr star)))))
                                                           (H t.1 (f (inr star))) u
                                                    -> Path (Maybe (has-decidable-equality/is-finite/subtype k B f))
                                                           (has-decidable-equality/is-finite/map k B f H t.1) (inl t) = split
  inl p -> \ _.
    ex-falso
      ( Path
        ( Maybe (has-decidable-equality/is-finite/subtype k B f))
        ( has-decidable-equality/is-finite/map k B f H t.1)
        ( inl t))
      ( t.2 p)
  inr np -> \ p.
    comp
      ( Maybe (has-decidable-equality/is-finite/subtype k B f))
      ( has-decidable-equality/is-finite/map k B f H t.1)
      ( has-decidable-equality/is-finite/map' k B f t.1 (inr np))
      ( ap
        ( Coprod (Path B t.1 (f (inr star))) (neg (Path B t.1 (f (inr star)))))
        ( Maybe (has-decidable-equality/is-finite/subtype k B f))
        ( has-decidable-equality/is-finite/map' k B f t.1)
        ( H t.1 (f (inr star))) (inr np) p)
      ( inl t)
      ( Coprod/Eq/map
        ( has-decidable-equality/is-finite/subtype k B f) Unit    
        ( inl (t.1, np))
        ( inl t)
        ( SgPath-prop B
          ( \ y. neg (Path B y (f (inr star))))
          ( \ y. Pi/is-prop
                ( Path B y (f (inr star)))
                ( \ _. Empty/Prop))
          ( t.1, np) t
          ( refl B t.1)))

has-decidable-equality/is-finite/right-htpy/inr (k : Nat) (B : U) (f : Fin (suc k) -> B) (H : has-decidable-equality B)
                                                   : (u : Coprod (Path B (f (inr star)) (f (inr star))) (neg (Path B (f (inr star)) (f (inr star)))))
                                                    -> Path (Coprod (Path B (f (inr star)) (f (inr star))) (neg (Path B (f (inr star)) (f (inr star)))))
                                                           (H (f (inr star)) (f (inr star))) u
                                                    -> Path (Maybe (has-decidable-equality/is-finite/subtype k B f))
                                                           (has-decidable-equality/is-finite/map k B f H (f (inr star))) (inr star) = split
  inl p -> \ q.
    ap
      ( Coprod (Path B (f (inr star)) (f (inr star))) (neg (Path B (f (inr star)) (f (inr star)))))
      ( Maybe (has-decidable-equality/is-finite/subtype k B f))
      ( has-decidable-equality/is-finite/map' k B f (f (inr star)))
      ( H (f (inr star)) (f (inr star)))
      ( inl p) q
  inr np -> \ _.
    ex-falso
      ( Path
        ( Maybe (has-decidable-equality/is-finite/subtype k B f))
        ( has-decidable-equality/is-finite/map k B f H (f (inr star)))
        ( inr star))
      ( np (refl B (f (inr star))))

has-decidable-equality/is-finite/right-htpy (k : Nat) (B : U) (f : Fin (suc k) -> B) (H : has-decidable-equality B)
                                               : (u : Maybe (has-decidable-equality/is-finite/subtype k B f))
                                                -> Path (Maybe (has-decidable-equality/is-finite/subtype k B f))
                                                       (has-decidable-equality/is-finite/map k B f H (has-decidable-equality/is-finite/inv-map k B f H u)) u = split
  inl t -> has-decidable-equality/is-finite/right-htpy/inl k B f H t
            ( H t.1 (f (inr star)))
            ( refl (Coprod (Path B t.1 (f (inr star))) (neg (Path B t.1 (f (inr star))))) (H t.1 (f (inr star))))
  inr s -> ind-Unit
            ( \ x. Path (Maybe (has-decidable-equality/is-finite/subtype k B f)) (has-decidable-equality/is-finite/map k B f H (f (inr star))) (inr x))
            ( has-decidable-equality/is-finite/right-htpy/inr k B f H 
              ( H (f (inr star)) (f (inr star)))
              ( refl (Coprod (Path B (f (inr star)) (f (inr star))) (neg (Path B (f (inr star)) (f (inr star))))) (H (f (inr star)) (f (inr star))))) s

has-decidable-equality/is-finite/left-htpy' (k : Nat) (B : U) (f : Fin (suc k) -> B) (H : has-decidable-equality B)
                                            (y : B) : (u : Coprod (Path B y (f (inr star))) (neg (Path B y (f (inr star)))))
                                                      -> Path (Coprod (Path B y (f (inr star))) (neg (Path B y (f (inr star))))) (H y (f (inr star))) u
                                                      -> Path B (has-decidable-equality/is-finite/inv-map k B f H (has-decidable-equality/is-finite/map k B f H y)) y = split
  inl p -> \ q.
    comp B
      ( has-decidable-equality/is-finite/inv-map k B f H (has-decidable-equality/is-finite/map k B f H y))
      ( has-decidable-equality/is-finite/inv-map k B f H (has-decidable-equality/is-finite/map' k B f y (inl p)))
      ( ap
        ( Coprod (Path B y (f (inr star))) (neg (Path B y (f (inr star))))) B
        ( \ u. has-decidable-equality/is-finite/inv-map k B f H (has-decidable-equality/is-finite/map' k B f y u))
        ( H y (f (inr star)))
        ( inl p) q)
      y (inv B y (f (inr star)) p)
  inr np -> \ q.
    ap
    ( Coprod (Path B y (f (inr star))) (neg (Path B y (f (inr star))))) B
    ( \ u. has-decidable-equality/is-finite/inv-map k B f H (has-decidable-equality/is-finite/map' k B f y u))
    ( H y (f (inr star)))
    ( inr np) q

has-decidable-equality/is-finite/left-htpy (k : Nat) (B : U) (f : Fin (suc k) -> B) (H : has-decidable-equality B)
                                           (y : B) : Path B (has-decidable-equality/is-finite/inv-map k B f H (has-decidable-equality/is-finite/map k B f H y)) y =
  has-decidable-equality/is-finite/left-htpy' k B f H y
    ( H y (f (inr star)))
    ( refl (Coprod (Path B y (f (inr star))) (neg (Path B y (f (inr star))))) (H y (f (inr star))))

has-decidable-equality/is-finite/Equiv (k : Nat) (B : U) (f : Fin (suc k) -> B) (H : has-decidable-equality B)
                                          : Equiv B (Maybe (has-decidable-equality/is-finite/subtype k B f)) =
  has-inverse/Equiv B
    ( Maybe (has-decidable-equality/is-finite/subtype k B f))
    ( has-decidable-equality/is-finite/map k B f H)
    ( has-decidable-equality/is-finite/inv-map k B f H,
      ( has-decidable-equality/is-finite/right-htpy k B f H,
        has-decidable-equality/is-finite/left-htpy k B f H))

has-decidable-equality/is-finite/subtype-has-dec-eq' (k : Nat) (B : U) (f : Fin (suc k) -> B) (H : has-decidable-equality B) (t u : has-decidable-equality/is-finite/subtype k B f)
                                                        : Coprod (Path B t.1 u.1) (neg (Path B t.1 u.1))
                                                          -> Coprod (Path (has-decidable-equality/is-finite/subtype k B f) t u)
                                                                   (neg (Path (has-decidable-equality/is-finite/subtype k B f) t u)) = split
  inl p ->
    inl
      ( SgPath-prop B
        ( \ y. neg (Path B y (f (inr star))))
        ( \ y. Pi/is-prop
              ( Path B y (f (inr star)))
              ( \ _. Empty/Prop))
        t u p)
  inr np ->
    inr (\ p. np (Sg-path/left B (\ y. neg (Path B y (f (inr star)))) t u p))

has-decidable-equality/is-finite/subtype-has-dec-eq (k : Nat) (B : U) (f : Fin (suc k) -> B) (H : has-decidable-equality B)
                                                       : has-decidable-equality (has-decidable-equality/is-finite/subtype k B f) =
  \ t u.
    has-decidable-equality/is-finite/subtype-has-dec-eq' k B f H t u
      ( H t.1 u.1)

has-decidable-equality/is-finite/is-surj'' (k : Nat) (B : U) (f : Fin (suc k) -> B) (y : B) (np : neg (Path B y (f (inr star))))
                                              : (x : Fin (suc k)) -> Path B y (f x) -> Fib (Fin k) B (\ x'. f (inl x')) y = split
  inr s ->
    ind-Unit
      ( \ x. Path B y (f (inr x)) -> ( Fib (Fin k) B (\ x'. f (inl x')) y))
      ( \ q. ex-falso
            ( Fib (Fin k) B (\ x. f (inl x)) y)
            ( np q)) s
  inl x -> \ p. (x, p)

has-decidable-equality/is-finite/is-surj' (k : Nat) (B : U) (f : Fin (suc k) -> B) (is-surj-f : is-surj (Fin (suc k)) B f) (y : B)
                                          (x : Fin k) (p : Path B (f (inr star)) (f (inl x)))
                                             : Coprod (Path B y (f (inr star))) (neg (Path B y (f (inr star))))
                                              -> Prop-trunc (Fib (Fin k) B (\ x'. f (inl x')) y) = split
  inl q -> Prop-trunc/unit (x, comp B y (f (inr star)) q (f (inl x)) p)
  inr np ->
    rec-Prop-trunc
      ( Fib (Fin (suc k)) B f y)
      ( Prop-trunc/Prop (Fib (Fin k) B (\ x'. f (inl x')) y))
      ( \ t. Prop-trunc/unit (has-decidable-equality/is-finite/is-surj'' k B f y np t.1 t.2))
      ( is-surj-f y)

has-decidable-equality/is-finite/is-surj (k : Nat) (B : U) (H : has-decidable-equality B) (f : Fin (suc k) -> B) (is-surj-f : is-surj (Fin (suc k)) B f)
                                         (x : Fin k) (p : Path B (f (inr star)) (f (inl x)))
                                            : is-surj (Fin k) B (\ x'. f (inl x')) =
  \ y. has-decidable-equality/is-finite/is-surj' k B f is-surj-f y x p (H y (f (inr star)))

has-decidable-equality/is-finite/ind-map (k : Nat) (B : U) (f : Fin (suc k) -> B) (h : (x : Fin k) -> neg (Path B (f (inr star)) (f (inl x)))) (x : Fin k)
                                            : has-decidable-equality/is-finite/subtype k B f =
  (f (inl x), (\ p. h x (inv B (f (inl x)) (f (inr star)) p)))

has-decidable-equality/is-finite/is-surj/o (k : Nat) (B : U) (f : Fin (suc k) -> B) (y : B) (np : neg (Path B y (f (inr star)))) (h : (x : Fin k) -> neg (Path B (f (inr star)) (f (inl x))))
                                              : (x : Fin (suc k)) -> Path B y (f x)
                                                -> Fib (Fin k) (has-decidable-equality/is-finite/subtype k B f) (has-decidable-equality/is-finite/ind-map k B f h) (y, np) = split
  inr s ->
    ind-Unit
      ( \ x. Path B y (f (inr x)) -> Fib (Fin k) (has-decidable-equality/is-finite/subtype k B f) (has-decidable-equality/is-finite/ind-map k B f h) (y, np))
      ( \ q. ex-falso
              ( Fib (Fin k) (has-decidable-equality/is-finite/subtype k B f) (has-decidable-equality/is-finite/ind-map k B f h) (y, np))
              ( np q)) s
  inl x -> \ q.
    ( x,
      SgPath-prop B
        ( \ z. neg (Path B z (f (inr star))))
        ( \ z. Pi/is-prop
              ( Path B z (f (inr star)))
              ( \ _. Empty/Prop))
        ( y, np)
        ( has-decidable-equality/is-finite/ind-map k B f h x) q)    

has-decidable-equality/is-finite' (k : Nat) (B : U) (H : has-decidable-equality B) (f : Fin (suc k) -> B) (is-surj-f : is-surj (Fin (suc k)) B f)
                                  (IH : (B' : U) (H' : has-decidable-equality B') (f' : Fin k -> B') -> is-surj (Fin k) B' f' -> is-finite B')
                                     : Coprod (Sg (Fin k) (\ x. Path B (f (inr star)) (f (inl x)))) ((x : Fin k) -> neg (Path B (f (inr star)) (f (inl x))))
                                      -> is-finite B = split
  inl t ->
    IH B H (\ x. f (inl x))
      ( has-decidable-equality/is-finite/is-surj k B H f is-surj-f t.1 t.2)
  inr h ->
    let g : Fin k -> has-decidable-equality/is-finite/subtype k B f = has-decidable-equality/is-finite/ind-map k B f h in
    is-finite/closed-Equiv B
      ( Maybe (has-decidable-equality/is-finite/subtype k B f))
      ( has-decidable-equality/is-finite/Equiv k B f H)
      ( is-finite/closed-Coprod 
        ( has-decidable-equality/is-finite/subtype k B f) Unit
        ( IH 
          ( has-decidable-equality/is-finite/subtype k B f)
          ( has-decidable-equality/is-finite/subtype-has-dec-eq k B f H) g          
          ( \ t. rec-Prop-trunc
                  ( Fib (Fin (suc k)) B f t.1)
                  ( Prop-trunc/Prop (Fib (Fin k) (has-decidable-equality/is-finite/subtype k B f) g t))
                  ( \ u. Prop-trunc/unit (has-decidable-equality/is-finite/is-surj/o k B f t.1 t.2 h u.1 u.2))
                  ( is-surj-f t.1)))
        ( Unit/is-finite))

has-decidable-equality/Fin-is-finite : (k : Nat) (B : U) (H : has-decidable-equality B) (f : Fin k -> B) (is-surj-f : is-surj (Fin k) B f) -> is-finite B = split
  zero -> \ B H f is-surj-f. count/is-finite B (has-decidable-equality/is-finite/base B f is-surj-f)
  suc k -> \ B H f is-surj-f.
    has-decidable-equality/is-finite' k B H f is-surj-f
      ( has-decidable-equality/Fin-is-finite k)
      ( has-decidable-equality/is-finite/decide B (f (inr star)) H k f)

has-decidable-equality/is-finite (A B : U) (is-finite-A : is-finite A) (H : has-decidable-equality B) (f : A -> B) (is-surj-f : is-surj A B f)
                                      : is-finite B =
  rec-Prop-trunc
    ( count A)
    ( is-finite/Prop B)
    ( \ c.
      let k : Nat = number-of-elements A c
          e : Equiv (Fin k) A = count/Equiv A c
          g : Fin k -> B = \ x. f (Equiv/map (Fin k) A e x) in
      has-decidable-equality/Fin-is-finite c.1 B H g            
        ( \ y. rec-Prop-trunc
                ( Fib A B f y)
                ( Prop-trunc/Prop (Fib (Fin k) B g y))
                ( \ t. Prop-trunc/unit
                        ( ( Equiv/inv-map (Fin k) A e t.1),
                          ( comp B y (f t.1) t.2 (f (Equiv/map (Fin k) A e (Equiv/inv-map (Fin k) A e t.1)))
                              (ap A B f t.1 (Equiv/map (Fin k) A e (Equiv/inv-map (Fin k) A e t.1))
                                (inv A (Equiv/map (Fin k) A e (Equiv/inv-map (Fin k) A e t.1)) t.1 (Equiv/inv-right-htpy (Fin k) A e t.1))))))
                ( is-surj-f y)))
      ( is-finite-A)

unlock Coprod/Eq/map
