module Lib.IsFinite where

import Lib.PropTrunc
import Lib.SetTrunc
import Lib.Counting
import Lib.Prop.Nat
import Lib.Prop.Coprod
import Lib.Prop.Empty

is-finite (X : U) : U =
  Prop-trunc
    ( count X)

is-finite/is-prop (X : U) : is-prop (is-finite X) =
  Prop-trunc/is-prop
    ( count X)

is-finite/Prop (X : U) : UU-Prop =
  ( is-finite X,
    is-finite/is-prop X)

count/is-finite (X : U) (c : count X) : is-finite X =
  Prop-trunc/unit c

Unit/is-finite : is-finite Unit =
  count/is-finite Unit
    ( count/Unit)

Fin/is-finite (k : Nat) : is-finite (Fin k) =
  count/is-finite
    ( Fin k)
    ( count/fin-count k)

is-finite/closed-Equiv (A B : U) (e : Equiv A B) (is-finite-B : is-finite B) : is-finite A =
  Prop-trunc/map
    ( count B)
    ( count A)
    ( count/closed-equiv A B e) is-finite-B    

is-finite/closed-Equiv' (A B : U) (e : Equiv A B) (is-finite-A : is-finite A) : is-finite B =
  is-finite/closed-Equiv B A (Equiv/sym A B e) is-finite-A

has-cardinality (X : U) : U =
  Sg Nat
    ( \ k. mere-equiv (Fin k) X)

has-cardinality/is-prop/sg (X : U) (k : Nat) (h : mere-equiv (Fin k) X) (k' : Nat) (h' : mere-equiv (Fin k') X)
                              : Path (has-cardinality X) (k, h) (k', h') =
  SgPath-prop Nat
    ( \ n. mere-equiv (Fin n) X)
    ( \ n. mere-equiv/is-prop (Fin n) X)
    ( k, h)
    ( k', h')
    ( rec-Prop-trunc
      ( Equiv (Fin k) X)
      ( Nat/eq/Prop k k')
      ( \ e. rec-Prop-trunc
              ( Equiv (Fin k') X)
              ( Nat/eq/Prop k k')
              ( \ e'. Fin/is-inj k k'
                       ( Equiv/trans
                          ( Fin k) X
                          ( Fin k') e
                          ( Equiv/sym (Fin k') X e'))) h') h)

has-cardinality/is-prop (X : U) : is-prop (has-cardinality X) =
  \ h h'. has-cardinality/is-prop/sg X h.1 h.2 h'.1 h'.2

has-cardinality/Prop (X : U) : UU-Prop =
  ( has-cardinality X,
    has-cardinality/is-prop X)

is-finite/has-cardinality (X : U) : is-finite X -> has-cardinality X =
  rec-Prop-trunc
    ( count X)
    ( has-cardinality/Prop X)
    ( \ c. ( number-of-elements X c,
            Prop-trunc/unit (count/Equiv X c)))

has-cardinality/is-finite' (X : U) (k : Nat) (e : mere-equiv (Fin k) X) : is-finite X =
  rec-Prop-trunc
    ( Equiv (Fin k) X)
    ( is-finite/Prop X)
    ( \ e'. Prop-trunc/unit (k, e')) e    

has-cardinality/is-finite (X : U) : has-cardinality X -> is-finite X =
  \ t. has-cardinality/is-finite' X t.1 t.2

has-cardinality/card (X : U) (h : has-cardinality X) : Nat = h.1

has-cardinality/Equiv (X : U) (h : has-cardinality X) : mere-equiv (Fin (has-cardinality/card X h)) X = h.2

card (X : U) (i : is-finite X) : Nat =
  has-cardinality/card X
    ( is-finite/has-cardinality X i)

is-finite/closed-Coprod (A B : U) (is-finite-A : is-finite A) (is-finite-B : is-finite B) : is-finite (Coprod A B) =
  rec-Prop-trunc
    ( count A)
    ( is-finite/Prop (Coprod A B))
    ( \ c. rec-Prop-trunc
            ( count B)
            ( is-finite/Prop (Coprod A B))
            ( \ c'. Prop-trunc/unit (count/closed-Coprod A B c c'))
            is-finite-B)
    is-finite-A

is-finite/closed-Coprod-left (A B : U) (is-finite-copr : is-finite (Coprod A B)) : is-finite A =
  rec-Prop-trunc
    ( count (Coprod A B))
    ( is-finite/Prop A)
    ( \ c. Prop-trunc/unit (count/closed-Coprod-left A B c))
    is-finite-copr

is-finite/closed-Coprod-right (A B : U) (is-finite-copr : is-finite (Coprod A B)) : is-finite B =
  rec-Prop-trunc
    ( count (Coprod A B))
    ( is-finite/Prop B)
    ( \ c. Prop-trunc/unit (count/closed-Coprod-right A B c))
    is-finite-copr

is-finite/closed-Prod (A B : U) (is-finite-A : is-finite A) (is-finite-B : is-finite B) : is-finite (A * B) =
  rec-Prop-trunc
    ( count A)
    ( is-finite/Prop (A * B))
    ( \ c. rec-Prop-trunc
            ( count B)
            ( is-finite/Prop (A * B))
            ( \ c'. Prop-trunc/unit (count/closed-Prod A B c c'))
            is-finite-B)
    is-finite-A

Bool : U = Coprod Unit Unit

true : Bool = inl star
false : Bool = inr star

Bool/is-finite : is-finite Bool =
  is-finite/closed-Coprod
    Unit
    Unit
    Unit/is-finite
    Unit/is-finite

BoolBool/card : Nat =
  card
    ( Bool * Bool)
    ( is-finite/closed-Prod Bool Bool Bool/is-finite Bool/is-finite)

is-finite/pi' : (k : Nat) -> (B : Fin k -> U) -> ((x : Fin k) -> is-finite (B x)) -> is-finite ((x : Fin k) -> B x) = split
  zero ->
    \ B _.
      count/is-finite
        ( (x : Fin zero) -> B x)
        ( count/contr-count
          ( (x : Fin zero) -> B x)
          ( Empty/universal-dependent-property
            ( Fin zero) B
            ( Equiv/refl (Fin zero))))
  suc k ->
    \ B is-fin-B.
      is-finite/closed-Equiv
        ( (x : Fin (suc k)) -> B x)
        ( ((x : Fin k) -> B (inl x)) * (B (inr star)))
        ( Equiv/trans
          ( (x : Fin (suc k)) -> B x)
          ( ((x : Fin k) -> B (inl x)) * ((u : Unit) -> B (inr u)))
          ( ((x : Fin k) -> B (inl x)) * (B (inr star)))
          ( Coprod/dependent-universal-property
            ( Fin k) Unit B)
          ( Equiv/prod'
            ( (x : Fin k) -> B (inl x))
            ( (u : Unit) -> B (inr u))
            ( B (inr star))
            ( Equiv/pi-Unit
              ( \ u. B (inr u)))))
        ( is-finite/closed-Prod
          ( (x : Fin k) -> B (inl x))
          ( B (inr star))
          ( is-finite/pi' k
            ( \ x. B (inl x))
            ( \ x. is-fin-B (inl x)))
          ( is-fin-B (inr star)))

is-finite/Pi (A : U) (B : A -> U) (is-finite-A : is-finite A) (is-finite-B : (x : A) -> is-finite (B x))
                : is-finite ((x : A) -> B x) =
  rec-Prop-trunc
    ( count A)
    ( is-finite/Prop ((x : A) -> B x))
    ( \ c.
      is-finite/closed-Equiv
        ( (x : A) -> B x)
        ( (x : Fin (number-of-elements A c)) -> B (Equiv/map (Fin (number-of-elements A c)) A (count/Equiv A c) x))
        ( Equiv/dependent
          ( Fin (number-of-elements A c)) A B
          ( count/Equiv A c))
        ( is-finite/pi'
          ( number-of-elements A c)
          ( \ x. B (Equiv/map (Fin (number-of-elements A c)) A (count/Equiv A c) x))
          ( \ x. is-finite-B (Equiv/map (Fin (number-of-elements A c)) A (count/Equiv A c) x)))) is-finite-A
