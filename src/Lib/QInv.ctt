module Lib.QInv where

import Lib.Data.BiInv

has-inverse (A B : U) (f : A -> B) : U =
  Sg (B -> A) (\ g. (Htpy B (\ _. B) (map/comp B A B f g) (id B)) *
                    (Htpy A (\ _. A) (map/comp A B A g f) (id A)))

QInv/map (A B : U) (f : A -> B) (i : has-inverse A B f) : B -> A =
  i.1

QInv/right-htpy (A B : U) (f : A -> B) (i : has-inverse A B f) : Htpy B (\ _. B) (map/comp B A B f (QInv/map A B f i)) (id B) =
  i.2.1

QInv/left-htpy (A B : U) (f : A -> B) (i : has-inverse A B f) : Htpy A (\ _. A) (map/comp A B A (QInv/map A B f i) f) (id A) =
  i.2.2

has-inverse-is-bi-inv (A B : U) (f : A -> B) (i : has-inverse A B f) : is-bi-inv A B f =
  let g : B -> A = QInv/map A B f i in
  ( (g, QInv/right-htpy A B f i),
    (g, QInv/left-htpy A B f i))

is-bi-inv-has-inverse (A B : U) (f : A -> B) (b : is-bi-inv A B f) : has-inverse A B f =
  let g : B -> A = BiInv/right-inv A B f b in
  let h : B -> A = BiInv/left-inv A B f b in
  let G : Htpy B (\ _. B) (map/comp B A B f g) (id B) = BiInv/right-htpy A B f b in
  let H : Htpy A (\ _. A) (map/comp A B A h f) (id A) = BiInv/left-htpy A B f b in
  let K : Htpy B (\ _. A) g h = \ y. comp A (g y) (h (f (g y)))
                                          (inv A (h (f (g y))) (g y) (H (g y)))
                                          (h y)
                                          (ap B A h (f (g y)) y (G y)) in
  (g, G,
    \ x. comp A (g (f x)) (h (f x))
              (K (f x))
              x (H x))

BiInv/inv-map (A B : U) (f : A -> B) (b : is-bi-inv A B f) : B -> A =
  QInv/map A B f (is-bi-inv-has-inverse A B f b)

BiInv/inv-is-bi-inv (A B : U) (f : A -> B) (b : is-bi-inv A B f) : is-bi-inv B A (BiInv/inv-map A B f b) =
  let g : B -> A = BiInv/inv-map A B f b in
  let left-htpy : Htpy A (\ _. A) (map/comp A B A g f) (id A) = QInv/left-htpy A B f (is-bi-inv-has-inverse A B f b) in
  has-inverse-is-bi-inv B A g
    (f, (left-htpy, BiInv/right-htpy A B f b))
