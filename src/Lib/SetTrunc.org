#+NAME: SetTrunc
#+AUTHOR: Johann Rosain

* Set Truncation

  #+begin_src ctt 
  module Lib.SetTrunc where
  #+end_src

This file defines set truncation.

** Packages imports

   #+begin_src ctt
  import Lib.Prop.Levels
  import Lib.PropTrunc
   #+end_src

** Specification

Let =A= be a type and =B= a set. A map f : A \to B is a set truncation whenever its precomposition is an equivalence.
#+begin_src ctt
  precomp-Set (A : U) (B : UU-Set) (f : A -> (Set/type B)) (C : UU-Set) (g : Set/hom B C) : A -> Set/type C =
    \ z. g (f z)

  is-set-trunc (A : U) (B : UU-Set) (f : A -> (Set/type B)) : U =
    (C : UU-Set) -> is-equiv (Set/hom B C) (A -> Set/type C) (precomp-Set A B f C)
#+end_src

We can extract the underlying map of a set truncation.
#+begin_src ctt
  is-set-trunc/map (A : U) (B : UU-Set) (f : A -> Set/type B) (H : is-set-trunc A B f) (C : UU-Set) (g : A -> Set/type C) : Set/hom B C =
    (H C g).1.1
#+end_src

** Definition as an higher inductive type
We can define set truncation as a higher inductive type.
#+begin_src ctt
  data Set-trunc (A : U) : U
    = Set-trunc/unit (a : A)
    | Set-trunc/squash (x y : Set-trunc A) (p q : Path (Set-trunc A) x y) <i j> [(i=0) -> p j, (i=1) -> q j, (j=0) -> x, (j=1) -> y]
#+end_src

We can remark that the second constructor makes =Set-trunc= a set.
#+begin_src ctt
  Set-trunc/is-set (A : U) : is-set (Set-trunc A) =
    \ x y p q i j. Set-trunc/squash x y p q i j
#+end_src
Thus, =Set-trunc A= is in =UU-Set=.
#+begin_src ctt
  Set-trunc/Set (A : U) : UU-Set =
    (Set-trunc A, Set-trunc/is-set A)
#+end_src
Of course, as it is an inductive type, it has a recurrence principle.
#+begin_src ctt
  rec-Set-trunc (A : U) (B : UU-Set) (f : A -> Set/type B) : Set-trunc A -> Set/type B = split
    Set-trunc/unit a -> f a
    Set-trunc/squash x y p q i j ->
      ( Set/is-set B
        ( rec-Set-trunc A B f x)
        ( rec-Set-trunc A B f y)
        ( ap ( Set-trunc A) ( Set/type B) ( rec-Set-trunc A B f) x y p)
        ( ap ( Set-trunc A) ( Set/type B) ( rec-Set-trunc A B f) x y q)) i j      
#+end_src
The recurrence principle can also be expressed using propositions.
#+begin_src ctt
  rec-Set-trunc/Prop (A : U) (B : UU-Prop) (f : A -> Prop/type B) : Set-trunc A -> Prop/type B =
    rec-Set-trunc A
      ( Prop/Set B) f
#+end_src
Moreover, =Set-trunc/unit= satisfies set truncation.
#+begin_src ctt
  -- is-set-trunc/unit (X : U) : is-set-trunc X (Set-trunc X) (\ x. Set-trunc/unit x) =
#+end_src
** Map between truncations
If there is a map between A and B, then there is a map between the set truncations of A and B.
   #+begin_src ctt
  Set-trunc/map (A B : U) (f : A -> B) : (Set-trunc A) -> Set-trunc B =
    rec-Set-trunc A
      ( Set-trunc/Set B)
      ( \ x. Set-trunc/unit (f x))
   #+end_src

** Set truncation of a set is the set itself

   #+begin_src ctt
  Set-trunc/eq/Prop (X : U) (x y : Set-trunc X) : UU-Prop =
    ( Path (Set-trunc X) x y,
      Set-trunc/is-set X x y)

  Set/Set-trunc/map (X : UU-Set) : Set-trunc (Set/type X) -> Set/type X =
    rec-Set-trunc
      ( Set/type X) X
      ( id (Set/type X))

  Prop/Set-trunc/map (X : UU-Prop) : Set-trunc (Prop/type X) -> Prop/type X =
    Set/Set-trunc/map
      ( Prop/Set X)
   #+end_src

** Mere eq and set truncation
Mere equality corresponds to equality on set truncation. Indeed, the equality on a set truncation is a proposition and we have a back-and-forth map between |x|_0 = |y|_0 and ||x = y||.
#+begin_src ctt
  Set-trunc/mere-eq/eq (X : U) (x y : X) (p : mere-eq X x y) : Path (Set-trunc X) (Set-trunc/unit x) (Set-trunc/unit y) =
    rec-Prop-trunc
      ( Path X x y)
      ( Set-trunc/eq/Prop X
        ( Set-trunc/unit x)
        ( Set-trunc/unit y))
      ( J X x
        ( \ z _. Path (Set-trunc X) (Set-trunc/unit x) (Set-trunc/unit z))
        ( refl (Set-trunc X) (Set-trunc/unit x)) y) p
#+end_src


#+RESULTS:
: Typecheck has succeeded.

** Connected type
A type is connected whenever its set truncation is contractible.
#+begin_src ctt
  is-conn (A : U) : U =
    is-contr (Set-trunc A)
#+end_src
A connected type is inhabited.
#+begin_src ctt
  is-conn/is-inhabited (A : U) (is-conn-A : is-conn A) : Prop-trunc A =
    rec-Set-trunc A
      ( Prop/Set (Prop-trunc/Prop A))
      ( \ x. Prop-trunc/unit x)
      ( center (Set-trunc A) is-conn-A)
#+end_src
Moreover, given a point of a connected type, ...
#+begin_src ctt
  -- is-conn/mere-eq (A : U) (is-conn-A : is-conn A) (x y : A) : mere-eq A x y =
#+end_src

** TODO Ex 18.5
If =A= is connected, then for any family =B= over =A=, the map B a -> \Sigma A B defined as follows:
#+begin_src ctt
  fiber-inclusion (A : U) (B : A -> U) (a : A) : B a -> Sg A B =
    \ b. (a, b)
#+end_src
is surjective:
#+begin_src ctt
  -- fiber-inclusion/is-surj/sg (A : U) (B : A -> U) (a : A) (is-conn-A : is-conn A) (x : A) (y : B x) : Prop-trunc (Fib A B f (x, y)) =
  --   Prop-trunc/map
  --     ( Prop-trunc (Path A a x))
  --     ( Prop-trunc (Fib A B f (x, y)))
  --     ( \ p.  )
  --     ( is-conn/is-inhabited A is-conn-A) -- no

  -- fiber-inclusion/is-surj (A : U) (B : A -> U) (a : A) (is-conn-A : is-conn A) : is-surj (B a) (Sg A B) (fiber-inclusion A B a) =
  --   \ t. fiber-inclusion/is-surj/sg A B a is-conn-A t.1 t.2
#+end_src

** TODO Ex 18.7.(c)

#+RESULTS:
: Typecheck has succeeded.
