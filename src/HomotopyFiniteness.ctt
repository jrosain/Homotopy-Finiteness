module HomotopyFiniteness where

import Lib.IsFinite
import Lib.SetTrunc

is-htpy-finite' (A : U) : Nat -> U = split
  zero ->  is-finite
            ( Set-trunc A)
  suc k -> is-finite
            ( Set-trunc A) *
            ( (x y : A) -> is-htpy-finite' (Path A x y) k)

is-htpy-finite (n : Nat) (A : U) : U =
  is-htpy-finite' A n

is-htpy-finite/closed-Equiv/aux : (n : Nat) -> (A B : U) -> Equiv A B -> is-htpy-finite n B -> is-htpy-finite n A = split
  zero -> \ A B e.
    is-finite/closed-Equiv
      ( Set-trunc A)
      ( Set-trunc B)
      ( Set-trunc/Equiv A B e)
  suc n -> \ A B e is-htpy-finite-B.
    ( is-finite/closed-Equiv
        ( Set-trunc A)
        ( Set-trunc B)
        ( Set-trunc/Equiv A B e)
        ( is-htpy-finite-B.1),
      \ x y.
        is-htpy-finite/closed-Equiv/aux n
        ( Path A x y)
        ( Path B (Equiv/map A B e x) (Equiv/map A B e y))
        ( Equiv/Equiv-id A B e x y)
        ( is-htpy-finite-B.2
          ( Equiv/map A B e x)
          ( Equiv/map A B e y)))

is-htpy-finite/closed-Equiv (A B : U) (e : Equiv A B) (n : Nat) (is-htpy-finite-B : is-htpy-finite n B) : is-htpy-finite n A =
  is-htpy-finite/closed-Equiv/aux n A B e is-htpy-finite-B

is-htpy-finite/closed-Equiv' (A B : U) (e : Equiv A B) (n : Nat) (is-htpy-finite-A : is-htpy-finite n A) : is-htpy-finite n B =
  is-htpy-finite/closed-Equiv B A (Equiv/sym A B e) n is-htpy-finite-A
