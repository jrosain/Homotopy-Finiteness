module HomotopyFiniteness where

import Lib.IsFinite
import Lib.SetTrunc

is-htpy-finite : Nat -> U -> U = split
  zero -> \ A. is-finite (Set-trunc A)
  suc k -> \ A. is-finite (Set-trunc A) *
              ( (x y : A) -> is-htpy-finite k (Path A x y))

is-htpy-finite/is-prop : (k : Nat) -> (A : U) -> is-prop (is-htpy-finite k A) = split
  zero -> \ A. is-finite/is-prop (Set-trunc A)
  suc k -> \ A.
    is-prop/prod
      ( is-finite (Set-trunc A))
      ( (x y : A) -> is-htpy-finite k (Path A x y))
      ( is-finite/is-prop (Set-trunc A))
      ( is-prop/pi-2 A
        ( \ _. A)
        ( \ x y. is-htpy-finite k (Path A x y))
        ( \ x y. is-htpy-finite/is-prop k (Path A x y)))

is-htpy-finite/Prop (k : Nat) (A : U) : UU-Prop =
  ( is-htpy-finite k A,
    is-htpy-finite/is-prop k A)

is-htpy-finite/closed-Equiv/aux : (n : Nat) -> (A B : U) -> Equiv A B -> is-htpy-finite n B -> is-htpy-finite n A = split
  zero -> \ A B e.
    is-finite/closed-Equiv
      ( Set-trunc A)
      ( Set-trunc B)
      ( Set-trunc/Equiv A B e)
  suc n -> \ A B e is-htpy-finite-B.
    ( is-finite/closed-Equiv
        ( Set-trunc A)
        ( Set-trunc B)
        ( Set-trunc/Equiv A B e)
        ( is-htpy-finite-B.1),
      \ x y.
        is-htpy-finite/closed-Equiv/aux n
        ( Path A x y)
        ( Path B (Equiv/map A B e x) (Equiv/map A B e y))
        ( Equiv/Equiv-id A B e x y)
        ( is-htpy-finite-B.2
          ( Equiv/map A B e x)
          ( Equiv/map A B e y)))

is-htpy-finite/closed-Equiv (A B : U) (e : Equiv A B) (n : Nat) (is-htpy-finite-B : is-htpy-finite n B) : is-htpy-finite n A =
  is-htpy-finite/closed-Equiv/aux n A B e is-htpy-finite-B

is-htpy-finite/closed-Equiv' (A B : U) (e : Equiv A B) (n : Nat) (is-htpy-finite-A : is-htpy-finite n A) : is-htpy-finite n B =
  is-htpy-finite/closed-Equiv B A (Equiv/sym A B e) n is-htpy-finite-A

Fin/Equiv-Pi-Set-trunc : (k : Nat) -> (B : Fin k -> U) -> Equiv ((x : Fin k) -> Set-trunc (B x)) (Set-trunc ((x : Fin k) -> B x)) = split
  zero -> \ B.
    is-contr/Equiv
      ( (x : Fin zero) -> Set-trunc (B x))
      ( Set-trunc ((x : Fin zero) -> B x))
      ( Empty/universal-dependent-property
        ( Fin zero)
        ( \ x. Set-trunc (B x))
        ( Equiv/refl (Fin zero)))
      ( Set-trunc/closed-contr
        ( (x : Fin zero) -> B x)
        ( Empty/universal-dependent-property
          ( Fin zero) B
          ( Equiv/refl (Fin zero))))
  suc k -> \ B.
    Equiv/comp five-Nat
      ( (x : Fin (suc k)) -> Set-trunc (B x))
      ( ((x : Fin k) -> Set-trunc (B (inl x))) * ((x : Unit) -> Set-trunc (B (inr x))))
      ( Coprod/dependent-universal-property
        ( Fin k) Unit (\ x. Set-trunc (B x)))
      ( ((x : Fin k) -> Set-trunc (B (inl x))) * (Set-trunc (B (inr star))))
      ( Equiv/prod'
        ( (x : Fin k) -> Set-trunc (B (inl x)))
        ( (x : Unit) -> Set-trunc (B (inr x)))
        ( Set-trunc (B (inr star)))
        ( Equiv/pi-Unit
          ( \ x. Set-trunc (B (inr x)))))
      ( (Set-trunc ((x : Fin k) -> B (inl x))) * (Set-trunc (B (inr star))))
      ( Equiv/prod
        ( (x : Fin k) -> Set-trunc (B (inl x)))
        ( Set-trunc ((x : Fin k) -> B (inl x)))
        ( Set-trunc (B (inr star)))
        ( Fin/Equiv-Pi-Set-trunc k
          ( \ x. B (inl x))))
      ( Set-trunc (((x : Fin k) -> B (inl x)) * (B (inr star))))
      ( Set-trunc/closed-Prod
        ( (x : Fin k) -> B (inl x))
        ( B (inr star)))
      ( Set-trunc (((x : Fin k) -> B (inl x)) * ((x : Unit) -> B (inr x))))
      ( Set-trunc/Equiv
        ( ((x : Fin k) -> B (inl x)) * (B (inr star)))
        ( ((x : Fin k) -> B (inl x)) * ((x : Unit) -> B (inr x)))
        ( Equiv/prod'
          ( (x : Fin k) -> B (inl x))
          ( B (inr star))
          ( (x : Unit) -> B (inr x))
          ( Equiv/sym
            ( (x : Unit) -> B (inr x))
            ( B (inr star))
            ( Equiv/pi-Unit (\ x. B (inr x))))))
      ( Set-trunc ((x : Fin (suc k)) -> B x))
      ( Set-trunc/Equiv
        ( ((x : Fin k) -> B (inl x)) * ((x : Unit) -> B (inr x)))
        ( (x : Fin (suc k)) -> B x)
        ( Equiv/sym
          ( (x : Fin (suc k)) -> B x)
          ( ((x : Fin k) -> B (inl x)) * ((x : Unit) -> B (inr x)))
          ( Coprod/dependent-universal-property
            ( Fin k) Unit B)))

Path/Pi (A : U) (B : A -> U) (f : A -> A) (H : (x : A) -> Path A (f x) x) : Path U ((x : A) -> B (f x)) ((x : A) -> B x) =
  \ i. (x : A) -> B (H x i)

count/Equiv-Pi-Set-trunc (A : U) (B : A -> U) (c : count A) : Equiv ((x : A) -> Set-trunc (B x)) (Set-trunc ((x : A) -> B x)) =
  let k : Nat = number-of-elements A c
      e : Equiv (Fin k) A = count/Equiv A c
      f : (Fin k) -> A = Equiv/map (Fin k) A e
      g : A -> (Fin k) = Equiv/inv-map (Fin k) A e
  in
  Equiv/comp three-Nat
    ( (x : A) -> Set-trunc (B x))
    ( (x : Fin k) -> Set-trunc (B (f x)))
    ( Equiv/dependent
      ( Fin k) A
      ( \ x. Set-trunc (B x)) e)
    ( Set-trunc ((x : Fin k) -> B (f x)))
    ( Fin/Equiv-Pi-Set-trunc k
      ( \ x. B (f x)))
    ( Set-trunc ((x : A) -> B (f (g x))))
    ( Set-trunc/Equiv
      ( (x : Fin k) -> B (f x))
      ( (x : A) -> B (f (g x)))
      ( Equiv/dependent A
        ( Fin k)
        ( \ x. B (f x))
        ( Equiv/sym
          ( Fin k) A e)))
    ( Set-trunc ((x : A) -> B x))
    ( Set-trunc/Equiv
      ( (x : A) -> B (f (g x)))
      ( (x : A) -> B x)
      ( path-to-equiv
        ( (x : A) -> B (f (g x)))
        ( (x : A) -> B x)
        ( Path/Pi A B (\ x. f (g x)) (Equiv/inv-right-htpy (Fin k) A e))))

is-htpy-finite/pred : (n : Nat) -> (A : U) -> is-htpy-finite (suc n) A -> is-htpy-finite n A = split
  zero -> \ A H. H.1
  suc n -> \ A H.
      ( H.1,
        \ x y.
          is-htpy-finite/pred n
            ( Path A x y) (H.2 x y))

is-htpy-finite/is-finite-Set-trunc (A : U) : (n : Nat) -> is-htpy-finite n A -> is-finite (Set-trunc A) = split
  zero -> id (is-finite (Set-trunc A))
  suc n -> \ H. H.1

is-htpy-finite/closed-Pi : (n : Nat) -> (A : U) -> (B : A -> U) -> is-finite A -> ((x : A) -> is-htpy-finite n (B x)) -> is-htpy-finite n ((x : A) -> B x) = split
 zero -> \ A B HA HB.
    (rec-Prop-trunc
      ( count A)
      ( is-finite/Prop (Set-trunc ((x : A) -> B x)))
      ( \ c.
          is-finite/closed-Equiv'
            ( (x : A) -> Set-trunc (B x))
            ( Set-trunc ((x : A) -> B x))
            ( count/Equiv-Pi-Set-trunc A B c)
            ( is-finite/Pi A
              ( \ x. Set-trunc (B x)) HA HB)) HA)

 suc n -> \ A B HA HB.
      let IH : is-htpy-finite n ((x : A) -> B x) = is-htpy-finite/closed-Pi n A B HA (\ x. is-htpy-finite/pred n (B x) (HB x)) in
      ( is-htpy-finite/is-finite-Set-trunc ((x : A) -> B x) n IH,
        \ f g.
          is-htpy-finite/closed-Equiv
            ( Path ((x : A) -> B x) f g)
            ( Htpy A B f g)
            ( htpy-eq/Equiv A B f g) n
            ( is-htpy-finite/closed-Pi n A
              ( \ x. Path (B x) (f x) (g x)) HA
              ( \ x. (HB x).2 (f x) (g x))))

is-htpy-finite/closed-Sg/base' (A : U) (B : A -> U) (H : is-conn A) (is-htpy-finite-A : is-htpy-finite one-Nat A)
                               (is-htpy-finite-B : (x : A) -> is-htpy-finite zero (B x))
                               (has-dec-eq-Sg : has-decidable-equality (Set-trunc (Sg A B))) : is-htpy-finite zero (Sg A B) =
  rec-Prop-trunc A
    ( is-htpy-finite/Prop zero (Sg A B))
    ( \ a. has-decidable-equality/is-finite
            ( Set-trunc (B a))
            ( Set-trunc (Sg A B))
            ( is-htpy-finite-B a)
            ( has-dec-eq-Sg)
            ( Set-trunc-map
              ( B a)
              ( Sg A B)
              ( fiber-inclusion A B a))
            ( Set-trunc-map/is-surj
              ( B a)
              ( Sg A B)
              ( fiber-inclusion A B a)
              ( is-connected/fiber-inclusion-is-surj A B H a)))
    ( is-conn/is-inhabited A H)

is-htpy-finite/closed-Sg/dec-mere-eq' (A : U) (B : A -> U) (is-conn-A : is-conn A) (a : A)
                                      (h : (y y' : B a) -> is-decidable (mere-eq (Sg A B) (a, y) (a, y')))
                                      (y : B a) (x' : A) (y' : B x')
                                         : is-decidable (mere-eq (Sg A B) (a, y) (x', y')) =
  rec-Prop-trunc
    ( Path A a x')
    ( is-decidable/Prop
        ( mere-eq (Sg A B) (a, y) (x', y'))
        ( Prop-trunc/is-prop (Path (Sg A B) (a, y) (x', y'))))
    ( \ p. J A a
          ( \ z _. (b : B z) -> is-decidable (mere-eq (Sg A B) (a, y) (z, b)))
          ( h y) x' p y')
    ( Set-trunc/is-effective/map A a x'
      ( is-contr/all-elements-equal
        ( Set-trunc A)
        ( is-conn-A)
        ( Set-trunc/unit a)
        ( Set-trunc/unit x')))

is-htpy-finite/closed-Sg/dec-mere-eq (A : U) (B : A -> U) (is-conn-A : is-conn A) (a : A)
                                     (h : (y y' : B a) -> is-decidable (mere-eq (Sg A B) (a, y) (a, y')))
                                     (x : A) (y : B x) (x' : A) (y' : B x')
                                        : is-decidable (mere-eq (Sg A B) (x, y) (x', y')) =
  rec-Prop-trunc
    ( Path A a x)
    ( is-decidable/Prop
        ( mere-eq (Sg A B) (x, y) (x', y'))
        ( Prop-trunc/is-prop (Path (Sg A B) (x, y) (x', y'))))
    ( \ p. J A a
          ( \ z _. (b : B z) -> is-decidable (mere-eq (Sg A B) (z, b) (x', y')))
          ( \ b. is-htpy-finite/closed-Sg/dec-mere-eq' A B is-conn-A a h b x' y') x p y)
    ( Set-trunc/is-effective/map A a x
      ( is-contr/all-elements-equal
        ( Set-trunc A)
        ( is-conn-A)
        ( Set-trunc/unit a)
        ( Set-trunc/unit x)))

is-htpy-finite/closed-Sg/dec-mere-eq-dec-eq' (A : U) (B : A -> U) (is-conn-A : is-conn A) (a : A)
                                             (h : (y y' : B a) -> is-decidable (mere-eq (Sg A B) (a, y) (a, y')))
                                             (x : A) (y : B x) (x' : A) (y' : B x')
                                                : is-decidable (Path (Set-trunc (Sg A B)) (Set-trunc/unit (x, y)) (Set-trunc/unit (x', y'))) =
  is-decidable/closed-Equiv
    ( Path (Set-trunc (Sg A B)) (Set-trunc/unit (x, y)) (Set-trunc/unit (x', y')))
    ( mere-eq (Sg A B) (x, y) (x', y'))
    ( Set-trunc/is-effective (Sg A B) (x, y) (x', y'))
    ( is-htpy-finite/closed-Sg/dec-mere-eq A B is-conn-A a h x y x' y')

is-htpy-finite/closed-Sg/dec-mere-eq-dec-eq (A : U) (B : A -> U) (is-conn-A : is-conn A) (a : A)
                                            (h : (y y' : B a) -> is-decidable (mere-eq (Sg A B) (a, y) (a, y')))
                                            (t u : Set-trunc (Sg A B))
                                                 : is-decidable (Path (Set-trunc (Sg A B)) t u) =
  ind-Set-trunc/Prop
    ( Sg A B)
    ( \ t'. is-decidable/Prop
            ( Path (Set-trunc (Sg A B)) t' u)
            ( Set-trunc/is-set (Sg A B) t' u))
    ( \ t'. ind-Set-trunc/Prop
            ( Sg A B)
            ( \ u'. is-decidable/Prop
                    ( Path (Set-trunc (Sg A B)) (Set-trunc/unit t') u')
                    ( Set-trunc/is-set (Sg A B) (Set-trunc/unit t') u'))
            ( \ u'. is-htpy-finite/closed-Sg/dec-mere-eq-dec-eq' A B is-conn-A a h t'.1 t'.2 u'.1 u'.2) u) t

is-htpy-finite/closed-Sg/type (A : U) (B : A -> U) (a : A) (y y' : B a) : Set-trunc (Path A a a) -> UU-Prop =
  rec-Set-trunc
    ( Path A a a)
    ( UU-Prop/Set)
    ( \ p. mere-eq/Prop (B a) (tr A a a p B y) y')

lock Prop-trunc/is-prop UU-Prop/is-set
is-htpy-finite/closed-Sg/Equiv/map (A : U) (B : A -> U) (a : A) (y y' : B a) : (p : Prop-trunc (Path (Sg A B) (a, y) (a, y')))
                                       -> (Prop-trunc (Sg (Set-trunc (Path A a a)) (\ q. Prop/type (is-htpy-finite/closed-Sg/type A B a y y' q)))) =
  rec-Prop-trunc
    ( Path (Sg A B) (a, y) (a, y'))
    ( Prop-trunc/Prop (Sg (Set-trunc (Path A a a)) (\ q. Prop/type (is-htpy-finite/closed-Sg/type A B a y y' q))))
    ( \ p. let t : SgPathO A B (a, y) (a, y') = PathSg->SgPathO A B (a, y) (a, y') p in
          Prop-trunc/unit
          ( Set-trunc/unit t.1,
            Prop-trunc/unit t.2))

is-htpy-finite/closed-Sg/Equiv/inv-map (A : U) (B : A -> U) (a : A) (y y' : B a)
                                          : (Prop-trunc (Sg (Set-trunc (Path A a a)) (\ q. Prop/type (is-htpy-finite/closed-Sg/type A B a y y' q))))
                                           -> Prop-trunc (Path (Sg A B) (a, y) (a, y')) =
  rec-Prop-trunc
    ( Sg (Set-trunc (Path A a a)) (\ q. Prop/type (is-htpy-finite/closed-Sg/type A B a y y' q)))
    ( Prop-trunc/Prop (Path (Sg A B) (a, y) (a, y')))
    ( \ t. ind-Set-trunc/Prop
            ( Path A a a)
            ( \ p. Prop/Pi
                    ( Prop/type (is-htpy-finite/closed-Sg/type A B a y y' p))
                    ( \ _. Prop-trunc/Prop (Path (Sg A B) (a, y) (a, y'))))
            ( \ p. rec-Prop-trunc
                    ( Path (B a) (tr A a a p B y) y')
                    ( Prop-trunc/Prop (Path (Sg A B) (a, y) (a, y')))
                    ( \ q'. Prop-trunc/unit ( SgPathO->PathSg A B
                                             ( a, y)
                                             ( a, y')
                                             ( p, q')))) t.1 t.2)

is-htpy-finite/closed-Sg/Equiv (A : U) (B : A -> U) (a : A) (y y' : B a)
                                  : Equiv (Prop-trunc (Path (Sg A B) (a, y) (a, y')))
                                          (Prop-trunc (Sg (Set-trunc (Path A a a)) (\ q. Prop/type (is-htpy-finite/closed-Sg/type A B a y y' q)))) =
  Prop/Equiv 
    ( Prop-trunc/Prop (Path (Sg A B) (a, y) (a, y')))
    ( Prop-trunc/Prop (Sg (Set-trunc (Path A a a)) (\ q. Prop/type (is-htpy-finite/closed-Sg/type A B a y y' q))))
    ( is-htpy-finite/closed-Sg/Equiv/map A B a y y')
    ( is-htpy-finite/closed-Sg/Equiv/inv-map A B a y y')

is-htpy-finite/closed-Sg/subtype-decidable (A : U) (B : A -> U) (is-finite-A : is-htpy-finite one-Nat A)
                                           (is-finite-B : (x : A) -> is-htpy-finite zero (B x)) (a : A) (y y' : B a)
                                                        : is-decidable (Prop-trunc (Sg (Set-trunc (Path A a a)) (\ q. Prop/type (is-htpy-finite/closed-Sg/type A B a y y' q)))) =
  is-finite/is-decidable-Prop-trunc
    ( Sg (Set-trunc (Path A a a)) (\ q. Prop/type (is-htpy-finite/closed-Sg/type A B a y y' q)))
    ( is-finite/closed-Sg
        ( Set-trunc (Path A a a))
        ( \ q. Prop/type (is-htpy-finite/closed-Sg/type A B a y y' q))
        ( is-finite-A.2 a a)
        ( ind-Set-trunc/Prop
          ( Path A a a)
          ( \ q. is-finite/Prop (Prop/type (is-htpy-finite/closed-Sg/type A B a y y' q)))
          ( \ w. is-finite/closed-Equiv
                  ( Prop-trunc (Path (B a) (tr A a a w B y) y'))
                  ( Path (Set-trunc (B a)) (Set-trunc/unit (tr A a a w B y)) (Set-trunc/unit y'))
                  ( Set-trunc/is-effective' (B a) (tr A a a w B y) y')
                  ( is-decidable/is-finite
                    ( Path (Set-trunc (B a)) (Set-trunc/unit (tr A a a w B y)) (Set-trunc/unit y'))
                    ( Set-trunc/is-set (B a) (Set-trunc/unit (tr A a a w B y)) (Set-trunc/unit y'))
                    ( is-finite/has-decidable-equality
                      ( Set-trunc (B a))
                      ( is-finite-B a)
                      ( Set-trunc/unit (tr A a a w B y))
                      ( Set-trunc/unit y'))))))

is-htpy-finite/closed-Sg/mere-eq-decidable (A : U) (B : A -> U) (is-finite-A : is-htpy-finite one-Nat A)
                                           (is-finite-B : (x : A) -> is-htpy-finite zero (B x)) (a : A) (y y' : B a)
                                                        : is-decidable (mere-eq (Sg A B) (a, y) (a, y')) =
  is-decidable/closed-Equiv
    ( mere-eq (Sg A B) (a, y) (a, y'))
    ( Prop-trunc (Sg (Set-trunc (Path A a a)) (\ q. Prop/type (is-htpy-finite/closed-Sg/type A B a y y' q))))
    ( is-htpy-finite/closed-Sg/Equiv A B a y y')
    ( is-htpy-finite/closed-Sg/subtype-decidable A B is-finite-A is-finite-B a y y')

is-htpy-finite/closed-Sg/has-decidable-equality (A : U) (B : A -> U) (is-finite-A : is-htpy-finite one-Nat A) (is-conn-A : is-conn A)
                                                (is-finite-B : (x : A) -> is-htpy-finite zero (B x)) (t u : Set-trunc (Sg A B))
                                                  : is-decidable (Path (Set-trunc (Sg A B)) t u) =
  rec-Prop-trunc A
    ( is-decidable/Prop
      ( Path (Set-trunc (Sg A B)) t u)
      ( Set/is-set (Set-trunc/Set (Sg A B)) t u))
    ( \ a. is-htpy-finite/closed-Sg/dec-mere-eq-dec-eq A B is-conn-A a
            ( is-htpy-finite/closed-Sg/mere-eq-decidable A B is-finite-A is-finite-B a) t u)
    ( is-conn/is-inhabited A is-conn-A)

is-htpy-finite/closed-Sg/base (A : U) (B : A -> U) (H : is-conn A) (is-htpy-finite-A : is-htpy-finite one-Nat A)
                              (is-htpy-finite-B : (x : A) -> is-htpy-finite zero (B x))
                                 : is-htpy-finite zero (Sg A B) =
  is-htpy-finite/closed-Sg/base' A B H is-htpy-finite-A is-htpy-finite-B
    ( is-htpy-finite/closed-Sg/has-decidable-equality A B is-htpy-finite-A H is-htpy-finite-B)

unlock Prop-trunc/is-prop UU-Prop/is-set
